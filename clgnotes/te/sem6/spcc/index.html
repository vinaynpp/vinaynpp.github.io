<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../favicon/favicon-16x16.png">
    <link rel="manifest" href="../../../favicon/site.webmanifest">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat+Alternates:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../notesstyle.css">
    <title> SPCC PATRAVALI</title>
</head>

<body>
    <main> PATRAVALI </main>
    <ul class="collapsibleList">
        <li>SPCC<ul>
                <li>Chapter 1<ul>
                        <li>Prerequisites<ul>
                                <li>Language processing activities<ul>
                                        <li>The designers express the ideas in terms related to
                                            the application domain of the software. </li>
                                        <li>To implement these ideas, their descriptions need to
                                            be interpreted in terms of related to the execution
                                            domain of the computer system.</li>
                                        <li>Semantics is used to represent the rules of meaning
                                            of a domain </li>
                                        <li>Semantic gap to represent the difference between the
                                            semantics of two domains.</li>
                                        <li>The gap between the application domain and PL domain
                                            is called the specification gap and it is bridged by
                                            software Development Team.</li>
                                        <li>The gap between the PL domain and the Execution
                                            Domain is bridged by the designer of the PL
                                            processors.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Concept of System Software<ul>
                                <li>System software consist of variety of programs that support
                                    operation of computer.</li>
                                <li>User can concentrate on application without knowing details
                                    of machine</li>
                            </ul>
                        </li>
                        <li>Goals of system softwares<ul>
                                <li>User Convenience<ul>
                                        <li>Primary goal is to make computer system easier for
                                            user. So we have OS that provides interface between
                                            user and Hardware.</li>
                                    </ul>
                                </li>
                                <li>Efficient use <ul>
                                        <li>Allocate system resources to various application
                                            programs as efficient as possible</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Features of System Software <ul>
                                <li>Close to the system</li>
                                <li>Fast speed</li>
                                <li>Difficult to manipulate</li>
                                <li>Written in low level language</li>
                                <li>Difficult to design </li>
                            </ul>
                        </li>
                        <li>System Software vs Application Software<ul>
                                <li>1.<ul>
                                        <li>System Software maintain the system resources and
                                            give the path for application software to run.</li>
                                        <li>Application software is built for specific tasks.
                                        </li>
                                    </ul>
                                </li>
                                <li>2.<ul>
                                        <li>Low level languages are used to write the system
                                            software.</li>
                                        <li>While high level languages are used to write the
                                            application software.</li>
                                    </ul>
                                </li>
                                <li>3.<ul>
                                        <li>Its a general purpose software.</li>
                                        <li>While its a specific purpose software.</li>
                                    </ul>
                                </li>
                                <li>4.<ul>
                                        <li>Without system software, system can’t run.</li>
                                        <li>While without application software system always
                                            runs.</li>
                                    </ul>
                                </li>
                                <li>5.<ul>
                                        <li>System software runs when system is turned on and
                                            stop when system is turned off.</li>
                                        <li>While application software runs as per the user’s
                                            request.</li>
                                    </ul>
                                </li>
                                <li>6.<ul>
                                        <li>Example of system software are operating system,
                                            etc.</li>
                                        <li>Example of application software are Photoshop, VLC
                                            player etc.</li>
                                    </ul>
                                </li>
                                <li>7.<ul>
                                        <li>System Software programming is complex than
                                            application software.</li>
                                        <li>Application software programming is simpler as
                                            comparison to system software.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Introduction to system programs<ul>
                                <li>Program Development Environment<ul>
                                        <li>Editors<ul>
                                                <li>Are interactive tool which helps user to
                                                    create and revise document on a computer
                                                </li>
                                                <li>Types<ul>
                                                        <li>Line- only one line (Sequential line
                                                            number)</li>
                                                        <li>Stream- paragraph (RE)</li>
                                                        <li>Screen- para+ copy paste (Note pad)
                                                        </li>
                                                        <li>Word- change
                                                            font,style,size,image,video
                                                            (Microsoft word) </li>
                                                        <li>Structure- Focus on programming
                                                            (Turboc, Netbeans)</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Compiler<ul>
                                                <li>Compiler: a program that translates a
                                                    program in one language (the source
                                                    language) into an equivalent program in
                                                    another language (the object or target
                                                    language).</li>
                                                <li>Converts High level language into machine or
                                                    Assembly language depends on requirements.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Assembler<ul>
                                                <li>An assembler is a program that accepts as
                                                    input an assembly language program and
                                                    produces its machine language equivalent
                                                    along with information for the loader.</li>
                                                <li>Computer can understand only 0 and 1. </li>
                                                <li>But for programmer difficult to read and
                                                    write. </li>
                                                <li>Assembly language (Mnemonics)</li>
                                                <li>Add R1,R2</li>
                                            </ul>
                                        </li>
                                        <li>Debuggers<ul>
                                                <li>Is a computer program that is used to test
                                                    and debug the program </li>
                                            </ul>
                                        </li>
                                        <li>Interpreter<ul>
                                                <li>HLL into Machine Language </li>
                                                <li>Line by line</li>
                                                <li>Does not create object file</li>
                                            </ul>
                                        </li>
                                        <li>Macro processor<ul>
                                                <li>It accepts an assembly program containing
                                                    macro definitions and calls and translates
                                                    it into an assembly program which does not
                                                    contain any macro definition or calls.</li>
                                                <li>Single line abbreviation for group of
                                                    instructions.</li>
                                                <li>Programmer define a single instruction to
                                                    represent a block of code. </li>
                                            </ul>
                                        </li>
                                        <li>Linker<ul>
                                                <li>The Linker is the software program which
                                                    binds many object modules to make a single
                                                    object program</li>
                                                <li>Linking meaning<ul>
                                                        <li>The Process of merging many object
                                                            modules to form a single object
                                                            program is called as linking.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Runtime Environment<ul>
                                        <li>Loader<ul>
                                                <li>A Loader is system program that place the
                                                    object program into main memory and prepares
                                                    it for execution.</li>
                                                <li>Basic functions of loader<ul>
                                                        <li>Allocation</li>
                                                        <li>Linking </li>
                                                        <li>Relocation</li>
                                                        <li>Loading</li>
                                                    </ul>
                                                </li>
                                                <li>Types<ul>
                                                        <li>Compile-and-go Loader</li>
                                                        <li>Relocating Loader</li>
                                                        <li>Direct Linking Loader</li>
                                                        <li>Absolute Loader</li>
                                                        <li>General Loader</li>
                                                        <li>Dynamic Loader</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Operating system<ul>
                                                <li>Heart of computer</li>
                                                <li>Most important </li>
                                                <li>Interface between user and hardware</li>
                                                <li>Concerned with allocation of services and
                                                    resources. </li>
                                                <li>It manages resources like memory,file,IO
                                                    etc.</li>
                                                <li>It is a program that control the execution
                                                    of application program and acts as interface
                                                    between application and computer hardware.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Device Drivers<ul>
                                                <li>It is a computer program that operates or
                                                    controls a particular type of device that is
                                                    attached to a computer.</li>
                                                <li>It enables OS and other computer programs to
                                                    access the hardware functions.</li>
                                                <li>It is hardware dependent and operating
                                                    system specific.</li>
                                            </ul>
                                        </li>
                                        <li>Libraries</li>
                                    </ul>
                                </li>
                                <li>Compiler vs Interpreter<ul>
                                        <li>Programming Steps<ul>
                                                <li>Compiler<ul>
                                                        <li>Create the program.</li>
                                                        <li>Compile will parse or analyses all
                                                            of the language statements for its
                                                            correctness. </li>
                                                        <li>If incorrect, throws an errorIf no
                                                            error, the compiler will convert
                                                            source code to machine code.</li>
                                                        <li>It links different code files into a
                                                            runnable program(know as exe)</li>
                                                        <li>Run the Program.</li>
                                                    </ul>
                                                </li>
                                                <li>Interpreter<ul>
                                                        <li>Create the Program</li>
                                                        <li>No linking of files or machine code
                                                            generation</li>
                                                        <li>Source statements executed line by
                                                            line DURING Execution</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Advantage<ul>
                                                <li>The program code is already translated into
                                                    machine code. Thus, it code execution time
                                                    is less.</li>
                                                <li>Interpreters are easier to use, especially
                                                    for beginners.</li>
                                            </ul>
                                        </li>
                                        <li>Disadvantage<ul>
                                                <li>You can't change the program without going
                                                    back to the source code.</li>
                                                <li>Interpreted programs can run on computers
                                                    that have the corresponding interpreter.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Machine code<ul>
                                                <li>Store machine language as machine code on
                                                    the disk</li>
                                                <li>Not saving machine code at all.</li>
                                            </ul>
                                        </li>
                                        <li>Running time<ul>
                                                <li>Compiled code run faster</li>
                                                <li>Interpreted code run slower</li>
                                            </ul>
                                        </li>
                                        <li>Model<ul>
                                                <li>It is based on language
                                                    translationlinking-loading model.</li>
                                                <li>It is based on Interpretation Method.</li>
                                            </ul>
                                        </li>
                                        <li>Program generation<ul>
                                                <li>Generates output program (in the form of
                                                    exe) which can be run independently from the
                                                    original program.</li>
                                                <li>Do not generate output program. So they
                                                    evaluate the source program at every time
                                                    during execution.</li>
                                            </ul>
                                        </li>
                                        <li>Execution<ul>
                                                <li>Program execution is separate from the
                                                    compilation. It performed only after the
                                                    entire output program is compiled.</li>
                                                <li>Program Execution is a part of
                                                    Interpretation process, so it is performed
                                                    line by line.</li>
                                            </ul>
                                        </li>
                                        <li>Memory requirement<ul>
                                                <li>Target program executeindependently and do
                                                    not require the compiler in the memory.</li>
                                                <li>The interpreter exists in the memory during
                                                    interpretation.</li>
                                            </ul>
                                        </li>
                                        <li>Best suited for<ul>
                                                <li>Bounded to the specific target machine and
                                                    cannot be ported. C and C++ are a most
                                                    popular a programming language which uses
                                                    compilation model.</li>
                                                <li>For web environments, where load times are
                                                    important. Due to all the exhaustive
                                                    analysis is done, compiles take relatively
                                                    larger time to compile even small code that
                                                    may not be run multiple times. In such
                                                    cases, interpreters are better.</li>
                                            </ul>
                                        </li>
                                        <li>Code Optimization<ul>
                                                <li>The compiler sees the entire code upfront.
                                                    Hence, they perform lots of optimizations
                                                    that make code run faster</li>
                                                <li>Interpreters see code line by line, and thus
                                                    optimizations are not as robust as compilers
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Dynamic Typing<ul>
                                                <li>Difficult to implement as compilers cannot
                                                    predict what happens at turn time.</li>
                                                <li>Interpreted languages support Dynamic Typing
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Usage<ul>
                                                <li>It is best suited for the Production
                                                    Environment</li>
                                                <li>It is best suited for the program and
                                                    development environment.</li>
                                            </ul>
                                        </li>
                                        <li>Error execution<ul>
                                                <li>Compiler displays all errors and warning at
                                                    the compilation time. Therefore, you can't
                                                    run the program without fixing errors</li>
                                                <li>The interpreter reads a single statement and
                                                    shows the error if any. You must correct the
                                                    error to interpret next line.</li>
                                            </ul>
                                        </li>
                                        <li>Input<ul>
                                                <li>It takes an entire program</li>
                                                <li>It takes a single line of code.</li>
                                            </ul>
                                        </li>
                                        <li>Output<ul>
                                                <li>Compliers generates intermediate machine
                                                    code.</li>
                                                <li>Interpreter never generate any intermediate
                                                    machine code.</li>
                                            </ul>
                                        </li>
                                        <li>Errors<ul>
                                                <li>Display all errors after, compilation, all
                                                    at the same time.</li>
                                                <li>Displays all errors of each line one by one.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Pertaining Programming languages<ul>
                                                <li>C,C++,C#, Scala, Java all use complier.</li>
                                                <li>Python, PHP, Perl, Ruby uses an interpreter.
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Chapter 2<ul>
                        <li>Assembly<ul>
                                <li>An assembler is a program that accepts as input an assembly
                                    language program and produces its machine language
                                    equivalent along with information for the loader.</li>
                                <li>The Assembler must also produce other information for the
                                    loader to use.</li>
                                <li>Advantages<ul>
                                        <li>1. Assembly language allows getting the better
                                            performance out of the processor as possible
                                            (because assembly language program run faster than
                                            their higher language counterparts.) </li>
                                        <li>2. It helps us to gain access to specific
                                            characteristics of the hardware that might not be
                                            possible from a higher level language. </li>
                                        <li>3. It is mnemonic; e.g., we write ST instead of the
                                            big configuration 01010000 for the store
                                            instruction. </li>
                                        <li>4. Addresses are symbolic, not absolute. </li>
                                        <li>5. Reading is easier. </li>
                                        <li>6. Introduction of data to program is easier. </li>
                                    </ul>
                                </li>
                                <li>Disadvantages<ul>
                                        <li>1. It always requires the use of an assembler to
                                            translate a source program into an object code.
                                        </li>
                                        <li>2. Assembly language are specific to a given
                                            micro-processor /computer and hence are not
                                            portable.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Elements of Assembly Language programming<ul>
                                <li>Literals<ul>
                                        <li>Literals are plain values that are not associated
                                            with any variable name. </li>
                                        <li>They are often used by programmers as ad-hoc values
                                            that are not needed throughout the program, but only
                                            for few statements.</li>
                                        <li>These literals are handled by the Assembler by using
                                            a separate data structure called Literal Table (LT).
                                        </li>
                                        <li>For example, an integer variable abc is to be
                                            increased by 4 units, we write the statement as abc
                                            = abc + 4; Here, it is assumed that 4 is not needed
                                            again in the program. So, the value ‘4’ is used as
                                            an integer literal here. </li>
                                    </ul>
                                </li>
                                <li>Symbols<ul>
                                        <li>Symbols are the variable names that hold values
                                            needed throughout the program. </li>
                                        <li>The assembler stores these symbols and their
                                            definition addresses in a data structure called as
                                            the Symbol Table (ST).</li>
                                        <li>Symbols can be used for labels, operands and
                                            procedure names. </li>
                                        <li>The function of assembler is to search the symbol
                                            table when a symbol is found in the program and
                                            replace it with its definition addresses (where the
                                            value is stored).</li>
                                        <li>For example, an integer variable abc is increased by
                                            4 units once, and then this value 4 is incremented
                                            and added repeatedly to abc in a loop. Here, value 4
                                            is used once but it is referred from inside a loop
                                            again and again. So, we define a variable (i.e. a
                                            symbol) incr = 4 and then this variable is used to
                                            increment the value repeatedly inside the loop by
                                            using incr = incr +1.</li>
                                    </ul>
                                </li>
                                <li>Assembly Language Statements<ul>
                                        <li>Imperative statements<ul>
                                                <li>An imperative statement indicates an action
                                                    to be performed during the execution at the
                                                    assembled program. </li>
                                                <li>Each imperative statement typically
                                                    translates into a machine instruction.</li>
                                                <li>For example, ADD A1, B1 is an imperative
                                                    statement.</li>
                                            </ul>
                                        </li>
                                        <li>Declarative statements<ul>
                                                <li>The syntax of declaration statement is as
                                                    follows:</li>
                                                <li>[label] DS &lt;constant&gt;</li>
                                                <li>The DS (declare storage) statement reserves
                                                    areas of memory and associates names with
                                                    them. Consider the following DS statement:
                                                    <ul>
                                                        <li>A DS 1</li>
                                                        <li>G DS 200</li>
                                                    </ul>
                                                </li>
                                                <li>The statements reserve a memory area of 1
                                                    word and associates the name A with it.</li>
                                                <li>The second statement reserves a block of 200
                                                    memory words.</li>
                                            </ul>
                                        </li>
                                        <li>DC (Declare Constant) statements<ul>
                                                <li>The DC (Declare Constant) statements
                                                    constructs memory words containing
                                                    constants.</li>
                                                <li>ONE DC ‘1’</li>
                                                <li>The above statement associates the name ONE
                                                    with a memory word containing the value ‘1’.
                                                    The programmer can declare constants in
                                                    different forms decimal, binary,
                                                    hexadecimal, etc.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Assembler directives<ul>
                                        <li>Introduction<ul>
                                                <li>Assembler directives instruct the assembler
                                                    to perform certain action during the
                                                    assembly of a program.</li>
                                                <li>Some assembler directives are described in
                                                    the following manner. </li>
                                                <li>They are not a part of executable
                                                    instructions. </li>
                                                <li>So, they are not included in the final
                                                    object file generated by Assembler as
                                                    output.</li>
                                            </ul>
                                        </li>
                                        <li>START<ul>
                                                <li>This directive indicates that the first word
                                                    of the target program generated by the
                                                    assembler should be placed in the memory
                                                    word with address &lt;addr&gt;</li>
                                                <li>Example:</li>
                                                <li>PG1 START 2000; Start storing the program
                                                    PG1 from address 2000</li>
                                            </ul>
                                        </li>
                                        <li>END<ul>
                                                <li>This directive indicates the End of the
                                                    source program. </li>
                                            </ul>
                                        </li>
                                        <li>ORIGIN<ul>
                                                <li>This directive indicates that LC should be
                                                    set to the address given by &lt;addr&gt;.
                                                </li>
                                                <li>It has a similar purpose as START, but since
                                                    it does not include the program name, it is
                                                    to be used inside the program just before
                                                    the start of code segment or any other
                                                    segment.</li>
                                                <li>Example:</li>
                                                <li>ORG 3000; Start storing current program from
                                                    address 3000</li>
                                            </ul>
                                        </li>
                                        <li>EQU<ul>
                                                <li>The EQU statement defines the symbol to
                                                    represent &lt;addr&gt;. This differs from
                                                    the DC/DS statement as no LC processing is
                                                    implied.</li>
                                                <li>Thus EQU simply associates the name
                                                    &lt;symbol&gt; with &lt;addr&gt;.</li>
                                                <li>The EQU statement is as assembler directive
                                                    used to equate a symbolic name to a value
                                                    and make program more readable. </li>
                                                <li>Whenever a symbol is defined using EQU
                                                    directive, no memory is allocated to it;
                                                    only an entry is made in symbol table.</li>
                                                <li>Example,</li>
                                                <li>SUNDAY EQU 1</li>
                                                <li>Now, whenever in the program we use the
                                                    symbol SUNDAY, assembler will replace it by
                                                    1, i.e. its equated value.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Assembly scheme</li>
                        <li>Pass structure of assembler</li>
                        <li>Assembler Design<ul>
                                <li>Two pass assembler Design for Hypothetical / X86 family
                                    processor</li>
                                <li>Single pass Assembler Design for Hypothetical / X86 family
                                    processor</li>
                                <li>Data structures used. </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Chapter 5<ul>
                        <li>Introduction to compilers<ul>
                                <li>A compiler is a program that can read a program in one
                                    language (the source language) and translate it into an
                                    equivalent program in another language (the target
                                    language). An important role of the compiler is to report
                                    any errors in the source program that it detects during the
                                    translation process. </li>
                                <li>Commonly, the source language is a high-level programming
                                    language (i.e. a problem-oriented language), and the target
                                    language is a machine language or assembly language (i.e. a
                                    machine-oriented language). Thus compilation is a
                                    fundamental concept in the production of software: it is the
                                    link between the (abstract) world of application development
                                    and the low-level world of application execution on
                                    machines. </li>
                            </ul>
                        </li>
                        <li>Phases of compilers<ul>
                                <li>The process of compilation is split up into six phases, each
                                    of which interacts with a symbol table manager and an error
                                    handler. This is called the analysis/synthesis model of
                                    compilation. </li>
                            </ul>
                        </li>
                        <li>Lexical Analysis<ul>
                                <li>Introduction<ul>
                                        <li>A very first phase of compiler</li>
                                        <li>Read source program and generate tokens for syntax
                                            analyzer</li>
                                        <li>It scans the whole program so called as scanner.
                                        </li>
                                        <li>A lexical analyser or scanner is a program that
                                            groups sequences of characters into lexemes, and
                                            outputs (to the syntax analyser) a sequence of
                                            tokens. Here: <ul>
                                                <li>Functions<ul>
                                                        <li>It produces stream of tokens</li>
                                                        <li>Eliminates blank space and comments
                                                        </li>
                                                        <li>Generate symbol table which stores
                                                            the information about identifier,
                                                            constant…</li>
                                                        <li>Report error </li>
                                                    </ul>
                                                </li>
                                                <li>Lexeme<ul>
                                                        <li>A lexeme is a sequence of characters
                                                            from the input that match a pattern
                                                            (and hence constitute an instance of
                                                            a token); for example, if matches
                                                            the pattern for if, and foo123bar
                                                            matches the pattern for id. </li>
                                                        <li>Smallest logical unit of a program
                                                        </li>
                                                        <li>Sequence of characters for which
                                                            token is produced</li>
                                                    </ul>
                                                </li>
                                                <li>Token<ul>
                                                        <li>Tokens are symbolic names for the
                                                            entities that make up the text of
                                                            the program; e.g. if for the keyword
                                                            if, and id for any identifier. These
                                                            make up the output of the lexical
                                                            analyser.</li>
                                                        <li>A group of characters having some
                                                            meaning</li>
                                                        <li>Like identifier, constant, keyword..
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Pattern<ul>
                                                        <li>A pattern is a rule that specifies
                                                            when a sequence of characters from
                                                            the input constitutes a token; e.g.
                                                            the sequence i, f for the token if,
                                                            and any sequence of alpha-numeric
                                                            starting with a letter for the token
                                                            id. </li>
                                                        <li>Template or model</li>
                                                        <li>Set of Rules that describe how token
                                                            is formed. </li>
                                                    </ul>
                                                </li>
                                                <li>The token sequence represents almost all the
                                                    important information from the input program
                                                    required by the syntax analyser. Whitespace
                                                    (newlines, spaces and tabs), although often
                                                    important in separating lexemes, is usually
                                                    not returned as a token. Also, when
                                                    outputting an id or literal token, the
                                                    lexical analyser must also return the value
                                                    of the matched lexeme (shown in parentheses)
                                                    or else this information would be lost.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Summary<ul>
                                                <li>The lexical analyzer needs to scan and
                                                    identify only a finite set of valid token
                                                    that belong to the language in hand. </li>
                                                <li>It searches for the pattern defined by the
                                                    language rules.</li>
                                                <li>Regular expression is an important notation
                                                    for specifying patterns. </li>
                                                <li>Each pattern matches a set of strings, so
                                                    regular expressions serve as names for a set
                                                    of strings. </li>
                                                <li>Programming language tokens can be described
                                                    by regular languages.</li>
                                                <li>Regular languages are easy to understand and
                                                    have efficient implementation.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Role of Finite State Automata in Lexical Analysis<ul>
                                        <li>Finite automata is a state machine that takes a
                                            string of symbols as input and changes its state
                                            accordingly.</li>
                                        <li>Finite automata is a recognizer for regular
                                            expressions.</li>
                                        <li>When a regular expression string is fed into finite
                                            automata, it changes its state for each literal.
                                        </li>
                                        <li>If the input string is successfully processed and
                                            the automata reaches its final state, it is
                                            accepted, i.e., the string just fed was said to be a
                                            valid token of the language in hand.</li>
                                    </ul>
                                </li>
                                <li>Design of Lexical analyser<ul>
                                        <li>To design lexical analyzer generator the pattern of
                                            RE are designed first. </li>
                                        <li>These patterns are for recognizing various tokens
                                            from input string.</li>
                                        <li>From this pattern it is very easy to design NFA.
                                        </li>
                                        <li>Then convert NFA to DFA because simulation of DFA is
                                            easier for program.</li>
                                    </ul>
                                </li>
                                <li>Data structures used<ul>
                                        <li>Input Buffering<ul>
                                                <li>The lexical analyzer scans the input string
                                                    from left to right one character at a time.
                                                </li>
                                                <li>Begin_ptr(bp)</li>
                                                <li>Forward_ptr(fp)<ul>
                                                        <li>Forward ptr moves ahead to search
                                                            for end of lexeme. As soon as the
                                                            blank space is encountered it
                                                            indicates end of lexeme. </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>One buffer scheme<ul>
                                                <li>Only one buffer is used to store input
                                                    string</li>
                                                <li>But problem is if lexeme is very long then
                                                    it crosses the buffer boundary .</li>
                                                <li>To scan rest of lexeme the buffer has to be
                                                    refilled that makes overwriting the first
                                                    part of lexeme. </li>
                                            </ul>
                                        </li>
                                        <li>Two buffer scheme <ul>
                                                <li>When end of current buffer is reached the
                                                    other buffer is filled. </li>
                                                <li>Problem – if length of the lexeme is longer
                                                    than length of the buffer then scanning
                                                    input can not be scanned completely. </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Syntax Analysis<ul>
                                <li>Introduction<ul>
                                        <li>A syntax analyser or parser is a program that groups
                                            sequences of tokens from the lexical analysis phase
                                            into phrases each with an associated phrase type.
                                        </li>
                                        <li>Parse Trees and Syntax Trees: The structure of a
                                            phrase is best thought of as a parse tree or a
                                            syntax tree. A parse tree is tree that illustrates
                                            the grouping of tokens into phrases. A syntax tree
                                            is a compacted form of parse tree in which the
                                            operators appear as the interior nodes. The
                                            construction of a parse tree is a basic activity in
                                            compiler-writing.</li>
                                        <li> Syntax analysis is the second phase of the
                                            compiler. It gets the input from the tokens and
                                            generates a syntax tree or parse tree. </li>
                                        <li>The parser or syntax analyserobtains a string of
                                            tokens from the lexical analyser and verifies that
                                            the string can be generated by the grammar for the
                                            source language.</li>
                                        <li>It reports any syntax errors in the program. It also
                                            recovers from commonly occurring errors so that it
                                            can continue processing its input. </li>
                                    </ul>
                                </li>
                                <li>Functions of the parser<ul>
                                        <li>It verifies the structure generated by the tokens
                                            based on the grammar. </li>
                                        <li>It constructs the parse tree. </li>
                                        <li>It reports the errors. </li>
                                        <li>It performs error recovery.</li>
                                    </ul>
                                </li>
                                <li>Syntax error handling<ul>
                                        <li>Programs can contain errors at many different
                                            levels. For example: <ul>
                                                <li>Lexical, such as misspelling a keyword.
                                                </li>
                                                <li>Syntactic, such as an arithmetic expression
                                                    with unbalanced parentheses. </li>
                                                <li>Semantic, such as an operator applied to an
                                                    incompatible operand. </li>
                                                <li>Logical, such as an infinitely recursive
                                                    call. </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Context-Free Grammars<ul>
                                        <li>A Context-Free Grammar is a quadruple that consists
                                            of terminals, non-terminals, start symbol and
                                            productions. </li>
                                    </ul>
                                </li>
                                <li>Role of Context Free Grammar in Syntax analysis<ul>
                                        <li>Derivations<ul>
                                                <li>Two basic requirements for a grammar are to
                                                    generate a valid string and to recognize a
                                                    valid string.</li>
                                                <li>Derivation is a process that generates a
                                                    valid string with the help of grammar by
                                                    replacing the non-terminals on the left with
                                                    the string on the right side of the
                                                    production.</li>
                                                <li>Types of Derivations<ul>
                                                        <li>Left most derivation: In leftmost
                                                            derivations, the leftmost
                                                            non-terminal in each sentinel is
                                                            always chosen first for replacement.
                                                        </li>
                                                        <li>String that appear in leftmost
                                                            derivation are called left
                                                            sentential forms. </li>
                                                        <li>Right most derivation: In rightmost
                                                            derivations, the rightmost
                                                            non-terminal in each sentinel is
                                                            always chosen first for replacement.
                                                        </li>
                                                        <li>String that appear in rightmost
                                                            derivation are called right
                                                            sentential forms. </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Ambiguity<ul>
                                                <li>A grammar that produces more than one parse
                                                    tree for some sentence is said to be
                                                    ambiguous grammar. </li>
                                                <li>Example: Given grammar <ul>
                                                        <li>G: E → E + E | E * E | id </li>
                                                        <li>The sentence id + id * id has the
                                                            following two distinct leftmost
                                                            derivations:</li>
                                                        <li>E → E + E E → E * E</li>
                                                        <li>E → id + E E → E + E * E</li>
                                                        <li>E → id + E * E E → id + E * E</li>
                                                        <li>E → id + id * E E → id + id * E</li>
                                                        <li>E → id + id * id E → id + id * id
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>More than one parse tree for same string.
                                                </li>
                                                <li>Ambiguity in grammar is not good for
                                                    compiler construction. </li>
                                                <li>There is no automatic method to remove or
                                                    detect ambiguity. </li>
                                                <li>To remove ambiguity <ul>
                                                        <li>Rewrite grammar</li>
                                                        <li>Associativity</li>
                                                        <li>Precedence </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Regular Expression vs Context-Free Grammar <ul>
                                                <li>1<ul>
                                                        <li>It is used to describe the tokens of
                                                            programming languages. </li>
                                                        <li>It consists of a quadruple where S →
                                                            start symbol, P → production, T →
                                                            terminal, V → variable or non-
                                                            terminal. </li>
                                                    </ul>
                                                </li>
                                                <li>2<ul>
                                                        <li>It is used to check whether the
                                                            given input is valid or not using
                                                            transition diagram. </li>
                                                        <li>It is used to check whether the
                                                            given input is valid or not using
                                                            derivation. </li>
                                                    </ul>
                                                </li>
                                                <li>3<ul>
                                                        <li>The transition diagram has set of
                                                            states and edges. </li>
                                                        <li>The context-free productions.
                                                            Grammar has set of productions.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>4<ul>
                                                        <li>It has no start symbol. </li>
                                                        <li>It has start symbol. </li>
                                                    </ul>
                                                </li>
                                                <li>5<ul>
                                                        <li>It is useful for describing the
                                                            structure of lexical constructs such
                                                            as identifiers, constants, keywords
                                                            and so forth. </li>
                                                        <li>It is useful in describing nested
                                                            structures such as balanced
                                                            parentheses, matching begin-end’s
                                                            and so on. </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Types of Parsers: <ul>
                                        <li>Top down parser- LL(1)<ul>
                                                <li>Top-down methods build parse trees from the
                                                    top (root) to the bottom (leaves). </li>
                                                <li>A parser can start with the start symbol and
                                                    try to transform it to the input string.
                                                    Example: LL Parsers. </li>
                                            </ul>
                                        </li>
                                        <li>Bottom up parser<ul>
                                                <li>Bottom-up methods start from the leaves and
                                                    work their way up to the root.</li>
                                                <li>A parser can start with input and attempt to
                                                    rewrite it into the start symbol. Example:
                                                    LR Parsers.</li>
                                            </ul>
                                        </li>
                                        <li>Top down parser(LL Parsing) vs Bottom up parser(LR
                                            parsing)<ul>
                                                <li>Strategy<ul>
                                                        <li>Top down approach starts evaluating
                                                            the parse tree from the top and move
                                                            downwards for parsing other nodes.
                                                        </li>
                                                        <li>Bottom up approach starts evaluating
                                                            the parse tree from the lowest level
                                                            of the tree and move upwards for
                                                            parsing the node.</li>
                                                    </ul>
                                                </li>
                                                <li>Attempt<ul>
                                                        <li>Top down parsing attempts to find
                                                            the left most derivation for a given
                                                            string.</li>
                                                        <li>Bottom up parsing attempts to reduce
                                                            the input string to first symbol of
                                                            the grammer.</li>
                                                    </ul>
                                                </li>
                                                <li>Derivation Type<ul>
                                                        <li>Top down parsing uses leftmost
                                                            derivation.</li>
                                                        <li>Bottom up parsing uses the rightmost
                                                            derivation.</li>
                                                    </ul>
                                                </li>
                                                <li>Objective<ul>
                                                        <li>Top down parsing searches for a
                                                            production rule to be used to
                                                            construct a string.</li>
                                                        <li>Bottom up parsing searches for a
                                                            production rule to be used to reduce
                                                            a string to get a starting symbol of
                                                            grammar.</li>
                                                    </ul>
                                                </li>
                                                <li>Actions<ul>
                                                        <li>Actions are POP and Remove</li>
                                                        <li>Actions are shift and reduce</li>
                                                    </ul>
                                                </li>
                                                <li>Example<ul>
                                                        <li>LL(1) Parser</li>
                                                        <li>Operator Precedence parser</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Operator precedence parser, SLR<ul>
                                                <li>An efficient way of constructing
                                                    shift-reduce parser is called
                                                    operator-precedence parsing</li>
                                                <li>Operator precedence parser can be
                                                    constructed from a grammar called
                                                    Operator-Precedence grammar</li>
                                                <li>Rules<ul>
                                                        <li>a &lt;∙ b – a yields precedence to b
                                                        </li>
                                                        <li>a = b – a has the same precedence as
                                                            b </li>
                                                        <li>a ∙&gt; b – a takes precedence over
                                                            b </li>
                                                    </ul>
                                                </li>
                                                <li>Priority Rules<ul>
                                                        <li>Id has top most priority</li>
                                                        <li>↑ is of highest precedence and
                                                            right-associative</li>
                                                        <li>* and / are of next higher
                                                            precedence and left-associative, and
                                                        </li>
                                                        <li>+ and – are of lowest precedence and
                                                            left-associative.</li>
                                                        <li>$ has lowest priority. </li>
                                                    </ul>
                                                </li>
                                                <li>Grammar<ul>
                                                        <li>E-&gt; E + E</li>
                                                        <li>E -&gt; E * E </li>
                                                        <li>E -&gt; id </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Semantic Analysis<ul>
                                <li>Introduction<ul>
                                        <li>Uniqueness of type declaration</li>
                                        <li>Type compatibility while performing arithmetic
                                            expression</li>
                                        <li>Scope of the variable</li>
                                        <li>Simply syntax analysis is not sufficient for the
                                            language to get compiled we need something more than
                                            syntax analysis.</li>
                                        <li>Hence semantic analysis is done to handle such
                                            issue.</li>
                                    </ul>
                                </li>
                                <li>There are two ways to represent the semantic rules/ actions
                                    associated with grammar symbols<ul>
                                        <li>Syntax-Directed Definitions (SDD)<ul>
                                                <li>While doing static analysis of the language
                                                    we use syntax directed definition.</li>
                                                <li>That means augmented context free grammar is
                                                    generated. </li>
                                                <li>Augmented - Set of attributes are associated
                                                    with each terminal and non terminal symbol.
                                                </li>
                                                <li>Attribute can be a string, number, type,
                                                    memory location. </li>
                                                <li>Between the two notations, syntax-directed
                                                    definitions can be more readable and hence
                                                    more useful for specifications.</li>
                                            </ul>
                                        </li>
                                        <li>Syntax-Directed Translation Schemes (SDT) <ul>
                                                <li>Syntax-Directed Translation can be a
                                                    separate phase of a compiler or we can
                                                    augment our conventional grammar with
                                                    information to control the semantic analysis
                                                    and translation. </li>
                                                <li>Such grammars are called attribute grammars.
                                                </li>
                                                <li>We augment a grammar by associating
                                                    attributes with each grammar symbol that
                                                    describes its properties.</li>
                                                <li>With each production in a grammar, we give
                                                    semantic rules/ actions, which describe how
                                                    to compute the attribute values associated
                                                    with each grammar symbol in a production.
                                                </li>
                                                <li>Almost all modern compilers are
                                                    syntax-directed. </li>
                                            </ul>
                                        </li>
                                        <li> However, translation schemes can be more efficient
                                            and hence more useful for implementations. </li>
                                        <li>The most general approach to syntax-directed
                                            translation is to construct a parse tree or a syntax
                                            tree and then to compute the values of attributes at
                                            the nodes of the tree by visiting the nodes of the
                                            tree. </li>
                                    </ul>
                                </li>
                                <li>Inherited and Synthesized Attributes<ul>
                                        <li>A nonterminal A can have both inherited and
                                            synthesized attributes. </li>
                                        <li>The difference is how they are computed by rules
                                            associated with a production at a node N of the
                                            parse tree. </li>
                                        <li>Synthesized attribute<ul>
                                                <li>A synthesized attribute for a nonterminal A
                                                    at a parse-tree node N is defined by a
                                                    semantic rule associated with the production
                                                    at N. </li>
                                                <li>The value of the synthesized attribute at a
                                                    node is computed from the values of
                                                    attributes at the children of that node in
                                                    the parse tree. </li>
                                                <li>SDD Rules<ul>
                                                        <li>L -&gt; E n<ul>
                                                                <li>L.val = E.val </li>
                                                            </ul>
                                                        </li>
                                                        <li>E -&gt; E1 + T <ul>
                                                                <li>E.val = E1.val + T.val </li>
                                                            </ul>
                                                        </li>
                                                        <li>E -&gt; T <ul>
                                                                <li>E.val = T.val </li>
                                                            </ul>
                                                        </li>
                                                        <li>T -&gt; T1 * F <ul>
                                                                <li>T.val = T1.val * F.val </li>
                                                            </ul>
                                                        </li>
                                                        <li>T -&gt; F <ul>
                                                                <li>T.val = F.val </li>
                                                            </ul>
                                                        </li>
                                                        <li>F -&gt; (E) <ul>
                                                                <li>F.val = E.val </li>
                                                            </ul>
                                                        </li>
                                                        <li>F -&gt; digit <ul>
                                                                <li>F.val = digit.lexval</li>
                                                            </ul>
                                                        </li>
                                                        <li>The SDD in above Rules is based on
                                                            grammar for arithmetic expressions
                                                            with operators + and *. </li>
                                                        <li>It evaluates expressions terminated
                                                            by an end marker n.</li>
                                                        <li>In the SDD, each of the non
                                                            terminals has a single synthesized
                                                            attribute, called val.</li>
                                                        <li>We also suppose that the terminal
                                                            digit has a synthesized attribute
                                                            lexval, which is an integer value
                                                            returned by the lexical analyser.
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Inherited attribute<ul>
                                                <li>An inherited attribute for a nonterminal B
                                                    at a parse-tree node N is defined by a
                                                    semantic rule associated with the production
                                                    at the parent of N. </li>
                                                <li>The inherited attributes can be computed
                                                    from the values of the attributes at the
                                                    siblings and parent of that node</li>
                                                <li>SDD Rules<ul>
                                                        <li></li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Chapter 6<ul>
                        <li>Intermediate Code Generation<ul>
                                <li>The front end translates a source program into an
                                    intermediate representation from which the back end
                                    generates target code</li>
                                <li>Types of Intermediate codes<ul>
                                        <li>Graphical Representation <ul>
                                                <li>Syntax tree</li>
                                                <li>DAG<ul>
                                                        <li>Directed Acyclic Graph</li>
                                                        <li>Share common sub tree for given
                                                            expression.</li>
                                                        <li>Save space</li>
                                                        <li>Can have more than one parent</li>
                                                        <li>More compact form. </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Postfix notation<ul>
                                                <li>Any formula can be expressed without
                                                    parenthesis</li>
                                                <li>Convenient to evaluate formula on computers
                                                    with stack</li>
                                                <li>Suitable for direct execution</li>
                                                <li>No need to check formula(BODMAS) </li>
                                            </ul>
                                        </li>
                                        <li>Three address codes<ul>
                                                <li>Linear representation of Syntax tree</li>
                                                <li>Each statement contains three address two
                                                    for operand and one for result.</li>
                                                <li>Triples<ul>
                                                        <li>To avoid entering temporary names
                                                            into the symbol table, we might
                                                            refer to a temporary value by the
                                                            position of the statement that
                                                            computes it. </li>
                                                        <li>If we do so, three-address
                                                            statements can be represented by
                                                            records with only three fields: op,
                                                            arg1 and arg2. </li>
                                                        <li>The fields arg1 and arg2, for the
                                                            arguments of op, are either pointers
                                                            to the symbol table or pointers into
                                                            the triple structure (for temporary
                                                            values). </li>
                                                        <li>Since three fields are used, this
                                                            intermediate code format is known as
                                                            triples. </li>
                                                    </ul>
                                                </li>
                                                <li>Indirect Triple<ul>
                                                        <li>Another implementation of
                                                            three-address code is that of
                                                            listing pointers to triples, rather
                                                            than listing the triples themselves.
                                                            This implementation is called
                                                            indirect triples. </li>
                                                        <li>For example, let us use an array
                                                            statement to list pointers to
                                                            triples in the desired order. </li>
                                                        <li>Then the triples shown above might
                                                            be represented as follows: </li>
                                                    </ul>
                                                </li>
                                                <li>Quadruples<ul>
                                                        <li> A quadruple is a record structure
                                                            with four fields, which are op,
                                                            arg1, arg2 and result. </li>
                                                        <li>The op field contains an internal
                                                            code for the operator. </li>
                                                        <li>The three-address statement x: = y
                                                            op z is represented by placing y in
                                                            arg1, z in arg2 and x in result.
                                                        </li>
                                                        <li>The contents of fields arg1, arg2
                                                            and result are normally pointers to
                                                            the symbol-table entries for the
                                                            names represented by these fields.
                                                        </li>
                                                        <li>If so, temporary names must be
                                                            entered into the symbol table as
                                                            they are created. </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Code Optimization<ul>
                                <li>Need and sources of optimization<ul>
                                        <li>Optimization is a procedure of converting a piece of
                                            code into more efficient code in terms of time and
                                            space complexity</li>
                                        <li>Characteristics<ul>
                                                <li>The output of program remain same without
                                                    any side effects.</li>
                                                <li>Optimized code should execute faster.</li>
                                                <li>Optimized code should consume less memory.
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Code optimization techniques<ul>
                                        <li>Machine Dependent<ul>
                                                <li>Machine-dependent optimization is done after
                                                    the target code has been generated and when
                                                    the code is transformed according to the
                                                    target machine architecture</li>
                                                <li>It involves CPU registers and may have
                                                    absolute memory references rather than
                                                    relative references</li>
                                                <li>Machine-dependent optimizers put efforts to
                                                    take maximum advantage of memory hierarchy
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Machine Independent<ul>
                                                <li>In this optimization, the compiler takes in
                                                    the intermediate code and transforms a part
                                                    of the code that does not involve any CPU
                                                    registers and/or absolute memory locations.
                                                    For example:</li>
                                                <li>do { </li>
                                                <li>item = 10; </li>
                                                <li>value = value + item;</li>
                                                <li>} while(value&lt;100);</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Principle sources of optimization<ul>
                                        <li>Function preserving transformation<ul>
                                                <li>Compile time evaluation<ul>
                                                        <li>In this technique we need to find
                                                            value of expression whose value can
                                                            be pre computed at compilation time.
                                                        </li>
                                                        <li>Constant folding<ul>
                                                                <li>A=( 22.0 / 7.0 ) * r * 2
                                                                </li>
                                                            </ul>
                                                        </li>
                                                        <li>Constant propagation<ul>
                                                                <li>Pi=3.14</li>
                                                                <li>A=pi*r*2</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Common sub expression elimination<ul>
                                                        <li>Common sub expression elimination
                                                        </li>
                                                        <li>A=b*c;</li>
                                                        <li>.</li>
                                                        <li>.</li>
                                                        <li>.</li>
                                                        <li>X=b*c+15</li>
                                                    </ul>
                                                </li>
                                                <li>Dead code elimination<ul>
                                                        <li>//Temp1=temp2+temp3;</li>
                                                    </ul>
                                                </li>
                                                <li>Copy propagation<ul>
                                                        <li>Temp2=temp1</li>
                                                        <li>Temp3=temp2*temp1</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Loop optimization<ul>
                                                <li>Most of the execution time spent in loops so
                                                    optimizing loops will often give most
                                                    benefits.</li>
                                                <li>Loop motion<ul>
                                                        <li>While (i&lt;=limit-2)</li>
                                                    </ul>
                                                </li>
                                                <li>Strength reduction<ul>
                                                        <li>Initial<ul>
                                                                <li>•For i=1 to 10 do</li>
                                                                <li>.</li>
                                                                <li>i=i*5;</li>
                                                                <li>.</li>
                                                                <li>End </li>
                                                            </ul>
                                                        </li>
                                                        <li>Final<ul>
                                                                <li>Temp=5</li>
                                                                <li>For i=1 to 10 do</li>
                                                                <li>.</li>
                                                                <li>X=temp;</li>
                                                                <li>.</li>
                                                                <li>Temp=temp+5</li>
                                                                <li>end</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Loop fission<ul>
                                                        <li>For j= 1 to 50 do</li>
                                                        <li>A[j]=</li>
                                                        <li>B[j]=</li>
                                                        <li>C[j]=</li>
                                                        <li>End loop</li>
                                                    </ul>
                                                </li>
                                                <li>Loop unrolling<ul>
                                                        <li>Int i=1</li>
                                                        <li>While(i&lt;=100)</li>
                                                        <li>{</li>
                                                        <li>a[i]=b[i];</li>
                                                        <li>i++;</li>
                                                        <li>}</li>
                                                    </ul>
                                                </li>
                                                <li>Loop jamming<ul>
                                                        <li>For (i=0;i&lt;5;i++)</li>
                                                        <li>A=i+5;</li>
                                                        <li>For (i=0;i&lt;5;i++)</li>
                                                        <li>B=i+10;</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Optimization for basic block<ul>
                                                <li>Block is a linear piece of a code. Where
                                                    flow of a program moves at the beginning and
                                                    exit at end. </li>
                                                <li>Done in 3 ways.<ul>
                                                        <li>Common sub expression elimination
                                                        </li>
                                                        <li>Dead code elimination</li>
                                                        <li>Algebraic optimization <ul>
                                                                <li>a=b+1</li>
                                                                <li>C=a-1</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Reducible flow graph<ul>
                                                <li>Edges<ul>
                                                        <li>Forward edge – Every node can be
                                                            reached from the initial node</li>
                                                        <li>Backward edge – From leaf to
                                                            previous node </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Code Generation<ul>
                                <li>Issues in the design of code generator<ul>
                                        <li>Input to the code generator<ul>
                                                <li>IR+ Symbol table</li>
                                                <li>IR has several choices<ul>
                                                        <li>Postfix notation</li>
                                                        <li>Syntax tree</li>
                                                        <li>Three address code </li>
                                                    </ul>
                                                </li>
                                                <li>Intermediate code must be such that target
                                                    machine can easily manipulate it and
                                                    generate appropriate target machine code
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Target program<ul>
                                                <li>The, output of code· generator is target
                                                    program</li>
                                                <li>Output may take variety of forms<ul>
                                                        <li>Absolute machine language(executable
                                                            code)</li>
                                                        <li>Relocatable machine language(object
                                                            files for linker)</li>
                                                        <li>Assembly language(facilitates
                                                            debugging) </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Memory management<ul>
                                                <li>Symbol table entries have to be mapped with
                                                    actual address. </li>
                                                <li>Mapping names in source program and address
                                                    of data is done by front end and code
                                                    generator</li>
                                            </ul>
                                        </li>
                                        <li>Instruction selection<ul>
                                                <li>Instruction selection is important to obtain
                                                    efficient code</li>
                                                <li>Suppose we translate three-address code <ul>
                                                        <li>x:= y + z </li>
                                                        <li>to: </li>
                                                        <li>MOV y,RO</li>
                                                        <li>ADD z ,R01 </li>
                                                        <li>MOV R1 0, ,x </li>
                                                        <li></li>
                                                        <li>a : =a+ 1 </li>
                                                        <li>MOV a , R0</li>
                                                        <li>ADD #1, RO </li>
                                                        <li>MOV R01 , a </li>
                                                        <li>Cost = 6 </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Register allocation<ul>
                                                <li>Instructions involving register operands are
                                                    usually shorter and faster than those
                                                    involving operands in memory</li>
                                            </ul>
                                        </li>
                                        <li>Choice of evaluation order<ul>
                                                <li>The order in which computations are
                                                    performed! can affect the efficiency of the
                                                    target code</li>
                                                <li>When instructions are independent, their
                                                    evaluation order can be changed </li>
                                            </ul>
                                        </li>
                                        <li>Approaches to code generation</li>
                                    </ul>
                                </li>
                                <li>code generation algorithm</li>
                                <li>Basic block<ul>
                                        <li>In compiler construction, a basic block is a
                                            straight-line code sequence with no branches in
                                            except to the entry and no branches out except at
                                            the exit.</li>
                                        <li>This restricted form makes a basic block highly
                                            amenable to analysis.</li>
                                        <li>Basic blocks form the vertices or nodes in a control
                                            flow graph.</li>
                                        <li>Basic block is a set of statements that always
                                            executes in a sequence one after the other.</li>
                                        <li>They do not contain any kind of jump statements in
                                            them.</li>
                                        <li>There is no possibility of branching or getting halt
                                            in the middle.</li>
                                        <li>All the statements execute in the same order they
                                            appear.</li>
                                        <li>They do not lose the flow control of the program.
                                        </li>
                                    </ul>
                                </li>
                                <li>Flow graph<ul>
                                        <li>Flow graph is a directed graph. </li>
                                        <li>It contains the flow of control information for the
                                            set of basic block. </li>
                                        <li>A control flow graph is used to depict that how the
                                            program control is being parsed among the blocks.
                                        </li>
                                        <li>It is useful in the loop optimization.</li>
                                    </ul>
                                </li>
                                <li>How to form a basic block<ul>
                                        <li>Following statements of the code are called as
                                            Leaders</li>
                                        <li>First statement of the code.</li>
                                        <li>Statement that is a target of the conditional or
                                            unconditional goto statement.</li>
                                        <li>Statement that appears immediately after a goto
                                            statement.</li>
                                        <li>All the statements that follow the leader (including
                                            the leader) till the next leader appears form one
                                            basic block.</li>
                                        <li>The first statement of the code is called as the
                                            first leader.</li>
                                        <li>The block containing the first leader is called as
                                            Initial block.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>


    <footer>
        <div style="text-align-last: center;">
            <p> © 2021 Vinay Panchal All Rights Reserved.</p>
            <p><a href="http://www.vinaypanchal.com/">vinaypanchal.com</a></p>
        </div>
    </footer>
</body>
<script type="text/javascript" src="CollapsibleLists.src.js"></script>


</html>