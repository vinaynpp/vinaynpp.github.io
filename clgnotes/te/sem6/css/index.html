<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../favicon/favicon-16x16.png">
    <link rel="manifest" href="../../../favicon/site.webmanifest">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat+Alternates:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #333333;
            color: #ffffff;
            font-family: 'Segoe UI', sans-serif;
        }

        main {

            color: #ffffff;
            text-align: center;
            float: right;
            text-transform: uppercase;
            font-family: 'Montserrat Alternates', sans-serif;
            font-size: 450%;
            width: 100%;
        }

        li {
            font-size: 20px;
            color: #ffffff;

        }

        .collapsibleList li {
            list-style-image: url('icons/button.png');
            cursor: auto;
        }

        li.collapsibleListOpen {
            list-style-image: url('icons/button-open.png');
            cursor: pointer;
        }

        li.collapsibleListClosed {
            list-style-image: url('icons/button-closed.png');
            cursor: pointer;
        }

        footer {
            bottom: 0;
            right: 0;
            position: fixed;
            text-align: right;
            float: right;

        }
    </style>
    <title> CSS PATRAVALI</title>
</head>

<body>
    <main> PATRAVALI </main>
    <ul class="collapsibleList">

        <li>CSS<ul>
            <li>Chapter 1<ul>
                    <li>Introduction<ul>
                            <li>Security Goals<ul>
                                    <li>Confidentiality<ul>
                                            <li><b>Let your secret be a secret</b></li>
                                            <li>Stay away from <b>Interception</b> and <b>Sniffing</b></li>
                                            <li>Data is <b>Object</b></li>
                                            <li>Anyone handling object is <b>Subject</b></li>
                                            <li>The way to access object is <b>Access Mode</b></li>
                                            <li>The, way authorization works is <b>Policy</b></li>
                                        </ul>
                                    </li>
                                    <li>Integrity<ul>
                                            <li><b>Don't let anyone change your secret</b></li>
                                            <li>Stay away from <b>Fabrication</b> and <b>Modification</b></li>
                                            <li>Keep your secrets away from people in the first place so they can't
                                                change it</li>
                                        </ul>
                                    </li>
                                    <li>Availability<ul>
                                            <li><b>Keep checking if secret is still accessible</b></li>
                                            <li>Stay away from <b>Interruption</b></li>
                                            <li>Things to check <ul>
                                                    <li>Concurrency control</li>
                                                    <li>Deadlock Management</li>
                                                    <li>Exclusive Access</li>
                                                    <li>Software faults </li>
                                                    <li>Loss of Information</li>
                                                    <li>Does what it is meant to do</li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Services<ul>
                                    <li>Authentication</li>
                                    <li>Access Control</li>
                                    <li>Data Confidentiality</li>
                                    <li>Data Integrity</li>
                                    <li>Non Repudiation</li>
                                    <li>Availability</li>
                                </ul>
                            </li>
                            <li>Mechanisms <ul>
                                    <li>Encipherment</li>
                                    <li>Digital Signature</li>
                                    <li>Access Control</li>
                                    <li>Data Integrity</li>
                                    <li>Authentication Exchange</li>
                                    <li>Traffic Padding</li>
                                    <li>Routing Control</li>
                                    <li>Notarization</li>
                                </ul>
                            </li>
                            <li>Implementation relation<ul>
                                    <li>Mechanism implements Services</li>
                                    <li>Service implements Policies</li>
                                </ul>
                            </li>
                            <li>Definitions<ul>
                                    <li>Security Service<ul>
                                            <li>A service that is provided by a protocol layer of communicating open
                                                systems and that ensures adequate security of systems or data
                                                transfers</li>
                                            <li>A processing or communication service that is provided by a system
                                                to give a specific kind of protection to system resources</li>
                                        </ul>
                                    </li>
                                    <li>Plain text<ul>
                                            <li>Original message created</li>
                                        </ul>
                                    </li>
                                    <li>Cipher text<ul>
                                            <li>Coded form of plain text</li>
                                        </ul>
                                    </li>
                                    <li>Secret key<ul>
                                            <li>An input to encryption which helps in specific transformations and
                                                substitutions</li>
                                        </ul>
                                    </li>
                                    <li>Encryption or Enciphering<ul>
                                            <li>Converting Plain text into Cipher text</li>
                                        </ul>
                                    </li>
                                    <li>Decryption or Deciphering<ul>
                                            <li>Restoring Cipher text into Plain text</li>
                                        </ul>
                                    </li>
                                    <li>Cryptographic System or Cipher<ul>
                                            <li>A scheme used for Encryption</li>
                                        </ul>
                                    </li>
                                    <li>Cryptography<ul>
                                            <li>Study of Cryptographic Systems or Ciphers</li>
                                        </ul>
                                    </li>
                                    <li>Cryptanalysis<ul>
                                            <li>Deciphering without Enciphering details</li>
                                        </ul>
                                    </li>
                                    <li>Breaking the code<ul>
                                            <li>Another name for Cryptanalysis</li>
                                        </ul>
                                    </li>
                                    <li>Cryptology<ul>
                                            <li>Superset of Cryptography and Cryptanalysis</li>
                                        </ul>
                                    </li>
                                    <li>Vulnerability<ul>
                                            <li>Weakness in the system</li>
                                        </ul>
                                    </li>
                                    <li>Threat<ul>
                                            <li>Set of circumstances with potential to harm the computing system
                                            </li>
                                        </ul>
                                    </li>
                                    <li>Control<ul>
                                            <li>Preventing Threat from reaching the Vulnerability</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>The OSI security architecture</li>
                            <li>Network security model<ul>
                                    <li>Major Tasks in creating one<ul>
                                            <li>Purpose of making the algorithm should not be defeated by the
                                                opponent</li>
                                            <li>Generate secret info to be used in algo</li>
                                            <li>Develop methods to distribute and share this secret info</li>
                                            <li>Specify a protocol</li>
                                        </ul>
                                    </li>
                                    <li>Techniques<ul>
                                            <li>Transform the information itself so that unreadable by the
                                                opponent(attacker)</li>
                                            <li>Send some secret which should be unknown to the opponent(attacker)
                                            </li>
                                        </ul>
                                    </li>
                                    <li>Get a trusted Third party for secure transmission concerning the
                                        authenticity of the message</li>
                                </ul>
                            </li>
                            <li>Symmetric cipher model<ul>
                                    <li>Same key is shared by both clients</li>
                                    <li>As same key is required to encipher an decipher</li>
                                </ul>
                            </li>
                            <li>Classical Encryption techniques<ul>
                                    <li>Substitution techniques<ul>
                                            <li>Mono-alphabetic<ul>
                                                    <li>Caesar Cipher<ul>
                                                            <li>Get numerical Equivalent</li>
                                                            <li>Shift the numbers</li>
                                                            <li>C = E(k,p) = (p+k) mod 26</li>
                                                            <li>p = D(k,C) = (C-k) mod 26</li>
                                                        </ul>
                                                    </li>
                                                </ul>
                                            </li>
                                            <li>Poly-alphabetic <ul>
                                                    <li>Vigenere cipher<ul>
                                                            <li>Modified Caesar</li>
                                                            <li>Method 1<ul>
                                                                    <li>getting numerical equivalent of all
                                                                        characters</li>
                                                                    <li>Adding numbers of plain text and the key at
                                                                        the round of 26</li>
                                                                </ul>
                                                            </li>
                                                            <li>Method 2<ul>
                                                                    <li>Using a table with all alphabets in sequence
                                                                        on rows and columns</li>
                                                                </ul>
                                                            </li>
                                                        </ul>
                                                    </li>
                                                    <li>Playfair cipher<ul>
                                                            <li>Get a 5x5 Mattrix</li>
                                                            <li>Arrange alphabets in the mattrix and combine i,j in
                                                                one (because maths)</li>
                                                            <li>Fill repeating Characters with 'X'</li>
                                                            <li>2 Letters in plain text in same column replace with
                                                                the one below it</li>
                                                            <li>Otherwise replace based on rows and columns</li>
                                                        </ul>
                                                    </li>
                                                    <li>Hill cipher<ul>
                                                            <li>Works on matrix multiplication</li>
                                                            <li>Assign numbers to each alphabet</li>
                                                            <li>C = P K mod 26</li>
                                                            <li>Take determinant of each matrix</li>
                                                            <li>Transpose the original matrix</li>
                                                            <li>Determinant of each 2x2 minor matrices</li>
                                                            <li>Create matrix of co-factors</li>
                                                            <li>Divide each adjugate by the determinant</li>
                                                        </ul>
                                                    </li>
                                                    <li>Vernam Cipher<ul>
                                                            <li>Complicated and not in syllabus</li>
                                                        </ul>
                                                    </li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </li>
                                    <li>Transposition techniques<ul>
                                            <li>Keyless <ul>
                                                    <li>Railfence Cipher<ul>
                                                            <li>Write plain text in diagonals to look like railfence
                                                            </li>
                                                            <li>Read just the uppper row and then the lower row</li>
                                                        </ul>
                                                    </li>
                                                </ul>
                                            </li>
                                            <li>Keyed<ul>
                                                    <li>Single Columnar<ul>
                                                            <li>Write plain text row by row in a rectangle depending
                                                                on key size</li>
                                                            <li>Then read column by column</li>
                                                        </ul>
                                                    </li>
                                                    <li>Double Columnar<ul>
                                                            <li>Same as single instead use 2 key</li>
                                                        </ul>
                                                    </li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </li>
                                    <li>Steganography<ul>
                                            <li>Hide secret inside something usual stuff like image or sound </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>Number Theory<ul>
                            <li>Modular Arithmetic and Number Theory<ul>
                                    <li>[(a mod n) + (b mod n)] mod n = (a+b) mod n</li>
                                    <li>[(a mod n) - (b mod n)] mod n = (a-b) mod n</li>
                                    <li>[(a mod n) * (b mod n)] mod n = (a*b) mod n</li>
                                </ul>
                            </li>
                            <li>Euclid‘s algorithm</li>
                            <li>Prime numbers</li>
                            <li>Euclid‘s theorem</li>
                            <li>Proves every a and n that are relatively prime if<ul>
                                    <li>aϕ(n)≡1(mod n)</li>
                                </ul>
                            </li>
                            <li>Fermat‘s theorem<ul>
                                    <li>For any prime number p, 'a' is an integer which is not divisible by the p,
                                        then a^(p-1) = 1(mod p)</li>
                                </ul>
                            </li>
                            <li>Testing for primality<ul>
                                    <li>If a number is prime number or not</li>
                                </ul>
                            </li>
                            <li>The Chinese remainder theorem<ul>
                                    <li>There are certain numbers repeatedly divided by 3 and number is 2,
                                        repeatedly divided by 5 and remainder is 3 and repeatedly divided by 7 and
                                        remainder is 2</li>
                                </ul>
                            </li>
                            <li>Discrete logarithms</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>Chapter 2<ul>
                    <li>Private key cryptography <ul>
                            <li>Block cipher principles</li>
                            <li>Block cipher modes of operation</li>
                            <li>DES</li>
                            <li>Double DES</li>
                            <li>Triple DES</li>
                            <li>Advanced Encryption Standard (AES)</li>
                            <li>Stream Ciphers: RC5 algorithm.</li>
                        </ul>
                    </li>
                    <li>Public key cryptography<ul>
                            <li>Principles of public key cryptosystems</li>
                            <li>The RSA algorithm</li>
                            <li>The knapsack algorithm</li>
                            <li>ElGamal Algorithm</li>
                        </ul>
                    </li>
                    <li>Key management techniques<ul>
                            <li>Using Symmetric algorithms</li>
                            <li>Using Asymmetric algorithms</li>
                            <li>Using Trusted third party algorithms</li>
                            <li>Diffie Hellman Key exchange algorithm</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>Chapter 3<ul>
                    <li>Cryptographic hash functions</li>
                    <li>Properties of secure hash function</li>
                    <li>MD5</li>
                    <li>SHA-1</li>
                    <li>MAC</li>
                    <li>HMAC</li>
                    <li>CMAC</li>
                    <li>Digital Certificate<ul>
                            <li>X.509</li>
                            <li>PKI</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>Chapter 4<ul>
                    <li>User Authentication and Entity Authentication<ul>
                            <li>There are four general means of authenticating a user’s identity, which can be used
                                alone or in combination:</li>
                            <li>Something You Know: <ul>
                                    <li>Examples include a password, a personal identification number (PIN), or
                                        answers to a prearranged set of questions.</li>
                                    <li>Clear Text Password<ul>
                                            <li>Step 1: Prompt for User ID and Password</li>
                                            <li>Step 2: User Enters the User ID and Password</li>
                                            <li>Step 3: Validation</li>
                                            <li>Step 4: Display Result</li>
                                            <li>Drawbacks<ul>
                                                    <li>1. Database Contains Password in Cleartext</li>
                                                    <li>2. Passwords also travel in Cleartext</li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </li>
                                    <li>Derived Password<ul>
                                            <li>Instead of storing the password as it is, or in an encrypted form,
                                                an algorithm is run on the password to derive something out of the
                                                password and store it in the database.</li>
                                            <li>When the user wants to be authenticated, he/she enters the password
                                                , the user's computer performs the same algorithm locally and sends
                                                the password to the server, where it is verified.</li>
                                            <li>For Example: Message Digests of Passwords can be used as derived
                                                passwords.</li>
                                        </ul>
                                    </li>
                                    <li>Encrypted Passwords<ul>
                                            <li>To resolve the problem of transmission of password in cleartext, we
                                                can first encrypt the password and then send it to the server for
                                                authentication.</li>
                                            <li>The server first decrypts the encrypted password using the shared
                                                secret key and then uses the retrieved password for verification.
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Something You Have: <ul>
                                    <li>Examples include cryptographic keys, electronic keycards, smart cards, and
                                        physical keys. This type of authenticator is referred to as a token.</li>
                                    <li>Authentication Token<ul>
                                            <li>An Authentication token is an extremely useful alternative to a
                                                password.</li>
                                            <li>An authentication token is a small device that generates a new
                                                random value every time it is used.</li>
                                            <li>Each authentication token is preprogrammed with a unique number,
                                                called a random seed.</li>
                                            <li>Step 1: Creation of a token<ul>
                                                    <li>Whenever an authentication token is created, the
                                                        corresponding random seed is generated for the token by the
                                                        authentication server.</li>
                                                    <li>This seed is stored or pre-programmed inside the token, as
                                                        well as its entry is made against that user's record in the
                                                        database.</li>
                                                    <li>Also, the user doesn't know about the value of the seed,
                                                        unlike a password.</li>
                                                </ul>
                                            </li>
                                            <li>Step 2: Use of Token<ul>
                                                    <li>1. An authentication token automatically generates
                                                        pseudorandom numbers, called "ONE-TIME PASSWORDS" or
                                                        "ONE-TIME PASSCODES". These are randomly generated by the
                                                        authentication token, based on the seed value that they are
                                                        pre-progammed with.</li>
                                                    <li>2. When a user wants to be authenticated, the user will get
                                                        a screen to enter his user id and this one time password
                                                        obtained from the authentication token. This data is sent to
                                                        the server through the login request.</li>
                                                    <li>3. The server obtains the seed corresponding to the user id
                                                        using a "SEED RETRIEVAL PROGRAM".</li>
                                                    <li>4. It then calls a "PASSWORD VALIDATION PROGRAM" to validate
                                                        the one time password, which checks the relationship between
                                                        the one time password and the seed to verify its
                                                        authenticity.</li>
                                                </ul>
                                            </li>
                                            <li>Step 3: Server returns an appropriate message</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Something You Are: <ul>
                                    <li>Examples include recognition by fingerprint, retina, and face.</li>
                                    <li>Biometric Techniques<ul>
                                            <li>A Typical authentication process involving biometrics firstly
                                                involves the creation of the user's sample and its storage in the
                                                user's database.</li>
                                            <li>During the actual authentication, the user is required to provide a
                                                sample of the same nature to the server (This is usually sent across
                                                an encrypted session)</li>
                                            <li>On the server, the user's current sample is decrypted, and compared
                                                with the one stored in the database.</li>
                                            <li>If the two samples match to the expected degree, the user is
                                                considered as authenticated successfully else rejected.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Something You do: <ul>
                                    <li>Examples include recognition by voice pattern, handwriting characteristics,
                                        and typing rhythm</li>
                                    <li>Behavioral Techniques<ul>
                                            <li>The Idea behind behavioral techniques is to observe a person to
                                                ensure that he/ she is not trying to claim to be someone else. In
                                                other words , here the emphasis is on checking that a person's
                                                behaviour is not unusual or abnormal. Two main techniques are as
                                                follows:</li>
                                            <li>1) Keystroke</li>
                                            <li>2) Signature</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>One-way and mutual authentication schemes<ul>
                            <li>One - Way Authentication<ul>
                                    <li>One Way authentication refers to the authentication of only one end of the
                                        communication.</li>
                                    <li>For example, if there are 2 users A and B who want to communicate with each
                                        other. In this scheme User A is the client and User B is the server. Suppose
                                        User B wants to authenticate user A before the actual communication, but
                                        user A is not able to authenticate the server before the communication
                                        begins. Such a scheme is called a One Way Authentication Scheme or Protocol.
                                    </li>
                                    <li>There could be multiple factored authentication mechanisms used to provide
                                        much better security. for example a 2 Factor authentication, which depends
                                        upon a password and a 4 digit PIN to validate the authentication process.
                                    </li>
                                    <li>But Dont confuse this with mutual authentication. Over here only the client
                                        is getting authenticated to the server using multi factor authentication.
                                    </li>
                                </ul>
                            </li>
                            <li>Mutual Authentication<ul>
                                    <li>Mutual Authentication is a mechanism to authenticate both the entities
                                        involved in the communication process, ie. the sender and the receiver or
                                        client and server.</li>
                                    <li>The sender must prove its identity to the receiver and vice versa before the
                                        actual communication could even begin.</li>
                                    <li>In order to achieve mutual authentication, there must be certain provisions
                                        of some protocols which suppose to verify identity of the sender over an
                                        insecure communication channel.</li>
                                    <li>To achieve this goal , most of the protocols depend upon an authentication
                                        server also called as the Key Distribution Center (KDC).</li>
                                    <li>If the sender A wants to communicate with receiver B, then A can request for
                                        a session key from the Key Distribution Center(KDC) for communicating with
                                        B. These Authentication servers are capable of delivering good quality
                                        random session keys and distribute them securely to the clients who request
                                        it.</li>
                                    <li>These Authentication servers also maintain a table containing the name and
                                        master key or secret key of each client.</li>
                                    <li>The secret keys are used to authenticate the clients to the authentication
                                        servers and then for secure transmission of data between the client and the
                                        authentication servers.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>Needham Schroeder Authentication protocol<ul>
                            <li>Needham and Schroeder protocol uses a secret key known to the sender and also to an
                                authentication server.</li>
                            <li>Sender and Receiver share a secret key and use it for secure communication with the
                                authentication server.</li>
                            <li>Step 1:<ul>
                                    <li>Sender A requests for a session key to the authentication server for
                                        communication with Receiver B.</li>
                                    <li>The message consists of A's Secret key Ka, A's Network Address Na, B's
                                        Network Address Nb and a Nonce.</li>
                                    <li>The request sent by A to the authentication server which is in its encrypted
                                        form is :</li>
                                    <li>E(Ka,[Na,Nb,N]) Ka</li>
                                </ul>
                            </li>
                            <li>Step 2:<ul>
                                    <li>Authentication Server returns a message, containing a newly generated key
                                        Kab, nonce N(same), ticket(Kab+Sender's Name) encrypted with B's secret key
                                        Kb, receiver's name and this whole message is encrypted with the sender's
                                        private key Ka to ensure that no one else can read it.</li>
                                    <li>E(Kab, N, {A,Kab}Kb,B)Ka</li>
                                </ul>
                            </li>
                            <li>Step 3:<ul>
                                    <li>After receiving the reply from the Authentication Server, the sender
                                        decrypts the message and send the {A,Kab} to receiver B. </li>
                                    <li>A sends the ticket to B which is not in encrypted format because it was
                                        previously enrypted by the Authentication server using B's secret key.</li>
                                    <li>(A, Kab)Kb</li>
                                </ul>
                            </li>
                            <li>Step 4:<ul>
                                    <li>B decrypts the ticket received from A using the secret key Kb and compares
                                        the sender's identity.</li>
                                    <li>B again encrypts the message using the shared secret key Kab and generates
                                        nonce N1 and sends it back to the receiver.</li>
                                    <li>E(N1)Kab</li>
                                    <li>In this step B got the session key (Kab) to securely communicate with A.
                                    </li>
                                </ul>
                            </li>
                            <li>Step 5:<ul>
                                    <li>Sender decrypts the Nonce N1 using the shared secret key Kab . This proves
                                        the sender's identity.</li>
                                    <li>The sender sends response N1+1 encrypted using the shared secret key Kab.
                                    </li>
                                    <li>E(N1+1)Kab</li>
                                </ul>
                            </li>
                            <li>Step 6:<ul>
                                    <li>Now the sender A and receiver B can securely communicate with each other
                                        using the session key generated</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>Kerberos Authentication protocol<ul>
                            <li>Introduction<ul>
                                    <li>Kerberos is a mutual authentication protocol which lets workstations to
                                        share network resources and communicate with each other in a secure manner.
                                    </li>
                                    <li>Version 4 of Kerberos is found in most implementations but version 5 is also
                                        in use now.</li>
                                </ul>
                            </li>
                            <li>Working<ul>
                                    <li>There are 4 parties involved in the Kerberos Protocol:</li>
                                    <li>Alice: The Client Workstation</li>
                                    <li>Authentication Server (AS): Authenticates the Client during Login</li>
                                    <li>Ticket Granting Server (TGS): Issues tickets to certify proof of identity
                                    </li>
                                    <li>Bob: The Server offering services</li>
                                </ul>
                            </li>
                            <li>The job of the AS is to authenticate every user at the login time.</li>
                            <li>The AS Shares a unique secret password with every user.</li>
                            <li>The job of the TGS is to certify to the servers in the network that a user is really
                                who he/she claims to be.</li>
                            <li>For proving this, the mechanism of tickets is used.</li>
                            <li>There are 3 primary steps in the Kerberos Protocol :</li>
                            <li>1) Login<ul>
                                    <li>1. Alice uses her workstation and sends her name in plaintext to the AS.
                                    </li>
                                    <li>2. The AS first creates a package of the user name(ALICE) and a randomly
                                        generated session key (KS).</li>
                                    <li>3. It encrypts this package with the symmetric key that the AS shares with
                                        the Ticket Granting Server(TGS)</li>
                                    <li>4. The output of this step is called as Ticket Granting Ticket (TGT).</li>
                                    <li>5. The TGT can be opened only by the TGS.</li>
                                    <li>6. The AS then combines the TGT with the session key(KS) and encrypts the
                                        two together using a symmetric key derived from the password of Alice (KA).
                                    </li>
                                    <li>7. The final output can therefore be only opened by Alice.</li>
                                </ul>
                            </li>
                            <li>2) Obtaining a Service Granting Ticket (SGT)<ul>
                                    <li>1.. Alice would now inform her workstation that she needs to contact the
                                        server (Bob), hence she needs a ticket.</li>
                                    <li>2.. Alice's workstation creates a message intended for the TGS which
                                        contains the following items.<ul>
                                            <li>a) The TGT obtained in Step 1</li>
                                            <li>b) The id of the server (Bob) whose services she is interested in.
                                            </li>
                                            <li>c) The current Timestamp, encrypted with the same session key KS
                                            </li>
                                        </ul>
                                    </li>
                                    <li>3. Once the TGS is satisfied of the credentials of Alice, the TGS creates a
                                        session key KAB, for Alice to have a secure communication with Bob.</li>
                                    <li>4. TGS sends it twice to Alice:<ul>
                                            <li>a) once combined with Bob's id and encrypted with the session key
                                                KS, and second time</li>
                                            <li>b) combined with Alice's id and encrypted with Bob's secret key.
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>3) Communicate (Client contacts server for resources)<ul>
                                    <li>1. Alice can now send KAB to Bob in order to enter into a session with
                                        him/her.</li>
                                    <li>2. Alice simply forwards KAB encrypted with Bob's Secret key (received in
                                        the previous step) to Bob.</li>
                                    <li>3. This will ensure that only Bob can access KAB.</li>
                                    <li>4. Furthermore Alice also attaches a timestamp encrypted with KAB to Bob, to
                                        guard against any Replay Attacks.</li>
                                    <li>5. Since only Bob has his secret key, he uses it to first obtain the
                                        information (Alice's ID + KAB), which he uses to decrypt the encrypted time
                                        stamp value.</li>
                                    <li>6. Now for Alice to know that Bob ha indeed received KAB correctly or not ,
                                        Bob increments the timestamp value by 1, encrypts it with KAB and sends it
                                        back to Alice.</li>
                                    <li>7. Since only Alice and Bob know KAB, Alic can open the packet and verify
                                        the incremented Timestamp value.</li>
                                    <li>8. After successful verification, Alice and Bob can now communicate with
                                        each other securely using the session key , KAB (SGT)</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>Digital Signature Schemes<ul>
                            <li>RSA</li>
                            <li>EIGamal</li>
                            <li>Schnorr<ul>
                                    <li>Introduction<ul>
                                            <li>It is a digital signature scheme known for its simplicity, is
                                                efficient and generates short signatures.</li>
                                            <li>The signature proof is supposed to convince the Verifier that they
                                                are communicating with a user who knows the private key
                                                corresponding to the public key.</li>
                                            <li>In other words, the Verifier should be convinced that they are
                                                communicating with the Prover without knowing the private key.</li>
                                        </ul>
                                    </li>
                                    <li>Theory<ul>
                                            <li>Consider the following parameters: p, q, a, s, v, r, x, y</li>
                                            <li>where,</li>
                                            <li>"p" is any prime number</li>
                                            <li>"q" is factor of p-1</li>
                                            <li>“a” such that a^q = 1 mod p</li>
                                            <li>The above three variables are global and public which means anyone
                                                can see these three variables at a given scenario.</li>
                                            <li>We will have two keys.</li>
                                            <li>"s" is the secret key or the private key (0&lt;s&lt;q)</li>
                                            <li>"v" is the public key = a^-s mod q.</li>
                                            <li>The public key “v” will be global and public knowledge along with p,
                                                q and a. However only the sender will have the knowledge of the
                                                private key "s".</li>
                                        </ul>
                                    </li>
                                    <li>Encryption<ul>
                                            <li>Now the sender wants to send an encrypted message "M". He/She will
                                                follow the steps to use Schnorr's signature:-</li>
                                            <li>1. The sender first chooses a random number “r” such that
                                                0&lt;r&lt;q.</li>
                                            <li>2. She will now compute a value X such that: X= a^r mod p.</li>
                                            <li>3. Now that she has computed the value of X, she is going to
                                                concatenate this with the original message to get M||X and store the
                                                hash of this value in e. e = H(M||X) where H() is the hash function
                                            </li>
                                            <li>4.She is going to get a value “y” such that: y = (r + s*e) mod q
                                            </li>
                                        </ul>
                                    </li>
                                    <li>Transfer<ul>
                                            <li>Now that all the computations are over, the sender is going to send
                                                the following to the receiver.</li>
                                            <li>The message “M”.</li>
                                            <li>The signatures e and y.</li>
                                            <li>Along with this, the receiver has the following public piece of
                                                information:-</li>
                                            <li>The sender's public key “v”.</li>
                                            <li>The prime number that the sender chose “p”.</li>
                                            <li>“q” which is the factor of “p-1” which the sender chose.</li>
                                            <li>“a” such that a^q = 1 mod p, chosen by sender.</li>
                                        </ul>
                                    </li>
                                    <li>Decryption<ul>
                                            <li>Now, the receiver will have to compute X’ such that:</li>
                                            <li>X’ = a^y * v^e mod p</li>
                                            <li>We know that v = a^-s, let’s substitute that in the equation above
                                                and we get:</li>
                                            <li>X’ = a^y * a^-se</li>
                                            <li>= a ^ (y-s*e)</li>
                                            <li>Now we also know that,</li>
                                            <li>y = r + s*e</li>
                                            <li>Which</li>
                                            <li>means: r = y-s*e</li>
                                            <li>Let’s substitute this value in the equation above:</li>
                                            <li>We get: X’ = a^r</li>
                                            <li>As we have already seen above:</li>
                                            <li>X= a^r</li>
                                            <li>So technically:</li>
                                            <li>X = X’</li>
                                            <li>But the receiver doesn’t know the value of “X” because he never
                                                received that value. All that he received are the following: The
                                                message M, the signatures (e and y) and the host of public variables
                                                (public key “v”, p, q, and a).</li>
                                            <li>So he is going to solve for e by doing the following:</li>
                                            <li>e = H ( M||X’)</li>
                                            <li>Note that earlier we solved for e by doing:</li>
                                            <li>H(M||X))</li>
                                            <li>So, by that logic, if the two values of e come up to be the same
                                                then that means</li>
                                            <li>X = X’</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>Chapter 5<ul>
                    <li>Network security basics<ul>
                            <li>TCP/IP vulnerabilities (Layer wise)</li>
                            <li>Packet Sniffing</li>
                            <li>ARP spoofing</li>
                            <li>port scanning</li>
                            <li>IP spoofing</li>
                            <li>TCP syn flood</li>
                            <li>DNS Spoofing</li>
                        </ul>
                    </li>
                    <li>Denial of Service<ul>
                            <li>Classic DOS attacks</li>
                            <li>Source Address spoofing</li>
                            <li>ICMP flood</li>
                            <li>SYN flood</li>
                            <li>UDP flood</li>
                            <li>Distributed Denial of Service</li>
                            <li>Defenses against Denial of Service Attacks</li>
                        </ul>
                    </li>
                    <li>Internet Security Protocols<ul>
                            <li>SSL</li>
                            <li>IPSEC</li>
                        </ul>
                    </li>
                    <li>Secure Email<ul>
                            <li>PGP</li>
                            <li>Firewalls</li>
                            <li>IDS</li>
                            <li>types</li>
                        </ul>
                    </li>
                    <li>Honey pots </li>
                </ul>
            </li>
            <li>Chapter 6<ul>
                    <li>Software Vulnerabilities<ul>
                            <li>Buffer Overflow</li>
                            <li>Format string</li>
                            <li>cross-site scripting</li>
                            <li>SQL injection</li>
                        </ul>
                    </li>
                    <li>Malware<ul>
                            <li>Viruses</li>
                            <li>Worms</li>
                            <li>Trojans</li>
                            <li>Logic Bomb</li>
                            <li>Bots</li>
                            <li>Rootkits</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    </ul>

    <footer>
        <div style="text-align-last: center;">
            <p> © 2021 Vinay Panchal All Rights Reserved.</p>
            <p><a href="http://www.vinaypanchal.com/">vinaypanchal.com</a></p>
        </div>
    </footer>

</body>
<script type="text/javascript" src="CollapsibleLists.src.js"></script>


</html>