<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../favicon/favicon-16x16.png">
    <link rel="manifest" href="../../../favicon/site.webmanifest">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat+Alternates:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #333333;
            color: #ffffff;
            font-family: 'Segoe UI', sans-serif;
        }

        main {

            color: #ffffff;
            text-align: center;
            float: right;
            text-transform: uppercase;
            font-family: 'Montserrat Alternates', sans-serif;
            font-size: 450%;
            width: 100%;
        }

        li {
            font-size: 20px;
            color: #ffffff;

        }

        .collapsibleList li {
            list-style-image: url('icons/button.png');
            cursor: auto;
        }

        li.collapsibleListOpen {
            list-style-image: url('icons/button-open.png');
            cursor: pointer;
        }

        li.collapsibleListClosed {
            list-style-image: url('icons/button-closed.png');
            cursor: pointer;
        }

        footer {
            bottom: 0;
            right: 0;
            position: fixed;
            text-align: right;
            float: right;

        }
    </style>
    <title> SE PATRAVALI</title>
</head>

<body>
    <main> PATRAVALI </main>
    <ul class="collapsibleList">
        <li>SE<ul>
                <li>Chapter 1<ul>
                        <li>Software Engineering<ul>
                                <li>Nature of Software<ul>
                                        <li>Instructions (computer programs) that when executed
                                            provide desired function and performance. </li>
                                        <li>Data structures that enable the programs to
                                            adequately manipulate information. </li>
                                        <li>Documents that describe the operation and use of the
                                            programs. </li>
                                    </ul>
                                </li>
                                <li>Software Engineering<ul>
                                        <li>Software Engineering is the study and application of
                                            engineering to the design, development, and
                                            maintenance of software. Software engineering can be
                                            divided into ten sub disciplines. They are: <ul>
                                                <li>Software Requirements<ul>
                                                        <li>The elicitation, analysis,
                                                            specification, and validation of
                                                            requirements for software. </li>
                                                    </ul>
                                                </li>
                                                <li>Software Design<ul>
                                                        <li>The process of defining the
                                                            architecture, components,
                                                            interfaces, and other
                                                            characteristics of a system or
                                                            component. It is also defined as the
                                                            result of that process. </li>
                                                    </ul>
                                                </li>
                                                <li>Software Construction<ul>
                                                        <li>The detailed creation of working,
                                                            meaningful software through a
                                                            combination of coding, verification,
                                                            unit testing, integration testing,
                                                            and debugging. </li>
                                                    </ul>
                                                </li>
                                                <li>Software Testing<ul>
                                                        <li>The dynamic verification of the
                                                            behavior of a program on a finite
                                                            set of test cases, suitably selected
                                                            from the usually infinite executions
                                                            domain, against the expected
                                                            behavior. </li>
                                                    </ul>
                                                </li>
                                                <li>Software Maintenance<ul>
                                                        <li>The totality of activities required
                                                            to provide cost-effective support to
                                                            software. </li>
                                                    </ul>
                                                </li>
                                                <li>Software Configuration Management<ul>
                                                        <li>The identification of the
                                                            configuration of a system at
                                                            distinct points in time for the
                                                            purpose of systematically
                                                            controlling changes to the
                                                            configuration, and maintaining the
                                                            integrity and traceability of the
                                                            configuration throughout the system
                                                            life cycle. </li>
                                                    </ul>
                                                </li>
                                                <li>Software Engineering Management<ul>
                                                        <li>The application of management
                                                            activities—planning, coordinating,
                                                            measuring, monitoring, controlling,
                                                            and reporting—to ensure that the
                                                            development and maintenance of
                                                            software is systematic, disciplined,
                                                            and quantified. </li>
                                                    </ul>
                                                </li>
                                                <li>Software Engineering process<ul>
                                                        <li>The definition, implementation,
                                                            assessment, measurement, management,
                                                            change, and improvement of the
                                                            software life cycle process itself.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Software Engineering Tools and Methods<ul>
                                                        <li>The computer-based tools that are
                                                            intended to assist the software life
                                                            cycle processes see Computer Aided
                                                            Software Engineering, and the
                                                            methods which impose structure on
                                                            the software engineering activity
                                                            with the goal of making the activity
                                                            systematic and ultimately more
                                                            likely to be successful. </li>
                                                    </ul>
                                                </li>
                                                <li>Software Quality<ul>
                                                        <li>The degree to which a set of
                                                            inherent characteristics fulfills
                                                            requirements. </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Software Process<ul>
                                        <li>A process framework establishes the foundation for a
                                            complete software engineering process by identifying
                                            a small number of framework activities that are
                                            applicable to all software projects, regardless of
                                            their size or complexity. In addition, the process
                                            framework encompasses a set of umbrella activities
                                            that are applicable across the entire software
                                            process. A generic process framework for software
                                            engineering encompasses five activities:<ul>
                                                <li>Communication<ul>
                                                        <li>Before any technical work can
                                                            commence, it is critically important
                                                            to communicate and collaborate with
                                                            the customer (and other
                                                            stakeholders). 3 The intent is to
                                                            understand stakeholders’ objectives
                                                            for the project and to gather
                                                            requirements that help defi ne
                                                            software features and functions.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Planning<ul>
                                                        <li>Any complicated journey can be
                                                            simplified if a map exists. A
                                                            software project is a complicated
                                                            journey, and the planning activity
                                                            creates a “map” that helps guide the
                                                            team as it makes the journey. The
                                                            map—called a software project
                                                            plan—defines the software
                                                            engineering work by describing the
                                                            technical tasks to be conducted, the
                                                            risks that are likely, the resources
                                                            that will be required, the work
                                                            products to be produced, and a work
                                                            schedule.</li>
                                                    </ul>
                                                </li>
                                                <li>Modeling<ul>
                                                        <li>Whether you’re a landscaper, a
                                                            bridge builder, an aeronautical
                                                            engineer, a carpenter, or an
                                                            architect, you work with models
                                                            every day. You create a “sketch” of
                                                            the thing so that you’ll understand
                                                            the big picture—what it will look
                                                            like architecturally, how the
                                                            constituent parts fi t together, and
                                                            many other characteristics. If
                                                            required, you refine the sketch into
                                                            greater and greater detail in an
                                                            effort to better understand the
                                                            problem and how you’re going to
                                                            solve it. A software engineer does
                                                            the same thing by creating models to
                                                            better understand software
                                                            requirements and the design that
                                                            will achieve those requirements.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Construction<ul>
                                                        <li>What you design must be built. This
                                                            activity combines code generation
                                                            (either manual or automated) and the
                                                            testing that is required uncovering
                                                            errors in the code.</li>
                                                    </ul>
                                                </li>
                                                <li>Deployment<ul>
                                                        <li>The software (as a complete entity
                                                            or as a partially completed
                                                            increment) is delivered to the
                                                            customer who evaluates the delivered
                                                            product and provides feedback based
                                                            on the evaluation.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Capability Maturity Model (CMM) <ul>
                                        <li>The generic process framework gives significance
                                            emphasis on “process maturity”. </li>
                                        <li>The Software Engineering Institute (SEI) has
                                            developed predictive set of capabilities that should
                                            be present as organization s reaches different
                                            levels of process maturity. </li>
                                        <li>The grading scheme determines compliance with a
                                            capability maturity model (CMM) that defines key
                                            activities required at different levels of process
                                            maturity.</li>
                                        <li>The five levels of CMMI are described below<ul>
                                                <li><b>Level 0: </b><b>Incomplete</b>. <ul>
                                                        <li>The process area (e.g., requirements
                                                            management) is either not performed
                                                            or does not achieve all goals and
                                                            objectives defined by the CMMI for
                                                            level 1 capability for the process
                                                            area. </li>
                                                    </ul>
                                                </li>
                                                <li><b>Level 1: Initia</b>l. <ul>
                                                        <li>The software process is
                                                            characterized as ad hoc and
                                                            occasionally even chaotic. Few
                                                            processes are defined, and success
                                                            depends on individual effort. </li>
                                                    </ul>
                                                </li>
                                                <li><b>Level 2: Managed</b>. <ul>
                                                        <li>An organization has achieved all the
                                                            specific and generic goals of the
                                                            maturity level 2 process areas. In
                                                            other words, the projects of the
                                                            organization have ensured that
                                                            requirements are managed and that
                                                            processes are planned performed,
                                                            measured, and controlled. </li>
                                                    </ul>
                                                </li>
                                                <li><b>Level 3: Defined</b>. <ul>
                                                        <li>The software process for both
                                                            management and engineering
                                                            activities is documented,
                                                            standardized, and integrated into an
                                                            organization wide software process.
                                                            All projects use a documented and
                                                            approved version of the
                                                            organization's process for
                                                            developing and supporting software.
                                                            This level includes all
                                                            characteristics defined for level 2.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li><b>Level 4: Quantitatively Managed</b>. <ul>
                                                        <li>Quantitative objectives for quality
                                                            and process performance are
                                                            established and used as criteria in
                                                            managing processes. Quantitative
                                                            objectives are based on the needs of
                                                            the customer, end users,
                                                            organization, and process
                                                            implementers. Quality and process
                                                            performance is understood in
                                                            statistical terms and is managed
                                                            throughout the life of the
                                                            processes. </li>
                                                    </ul>
                                                </li>
                                                <li><b>Level 5: Optimizing</b>. <ul>
                                                        <li>Continuous process improvement is
                                                            enabled by quantitative feedback
                                                            from the process and from testing
                                                            innovative ideas and technologies.
                                                            This level includes all
                                                            characteristics defined for level 4.
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Process Models<ul>
                                <li>Generic Process Model<ul>
                                        <li>Process is defined as a collection of work
                                            activities, actions, and tasks that are performed
                                            when some work product is to be created. Each of
                                            these activities, actions, and tasks resides within
                                            a framework or model that defines their relationship
                                            with the process and with one another.</li>
                                        <li>A generic process framework for software engineering
                                            defines five framework activities— <b>communication,
                                                planning, modeling,</b> <b>construction, </b>and
                                            <b>deployment. </b>In addition, a set of umbrella
                                            activities—project tracking and control, risk
                                            management, quality assurance, configuration
                                            management, technical reviews, and others—are
                                            applied throughout the process.
                                        </li>
                                        <li>A linear process flow executes each of the five
                                            framework activities in sequence, beginning with
                                            communication and culminating with deployment. An
                                            iterative process flow repeats one or more of the
                                            activities before proceeding to the next. An
                                            evolutionary process flow executes the activities in
                                            a “circular” manner. Each circuit through the five
                                            activities leads to a more complete version of the
                                            software. A parallel process flow executes one or
                                            more activities in parallel with other activities
                                            (e.g., modeling for one aspect of the software might
                                            be executed in parallel with construction of another
                                            aspect of the software).</li>
                                    </ul>
                                </li>
                                <li>Umbrella Activities of Software Engineering<ul>
                                        <li>Umbrella activities are independent of any one
                                            framework activity and occur throughout the process.
                                        </li>
                                        <li>Software Project Management </li>
                                        <li>Formal Technical Reviews </li>
                                        <li>Software Quality Assurance </li>
                                        <li>Software Configuration Management </li>
                                        <li>Re-usability Management </li>
                                        <li>Risk Management </li>
                                        <li>Measurement and Metrics </li>
                                        <li>Document Preparation and Production </li>
                                    </ul>
                                </li>
                                <li>Prescriptive Process Models: <ul>
                                        <li>The Waterfall Model<ul>
                                                <li>Theory<ul>
                                                        <li>Also known as the classic life cycle
                                                            or the waterfall model, the linear
                                                            sequential model suggests a
                                                            systematic, sequential approach to
                                                            software development that begins at
                                                            the system level and progresses
                                                            through analysis, design, coding,
                                                            testing, and support. </li>
                                                        <li>Modeled after a conventional
                                                            engineering cycle, the linear
                                                            sequential model encompasses
                                                            activities</li>
                                                        <li>System/information engineering and
                                                            modeling. Because software is always
                                                            part of a larger system (or
                                                            business), work begins by
                                                            establishing requirements for all
                                                            system elements and then allocating
                                                            some subset of these requirements to
                                                            software. </li>
                                                        <li>Phases of waterfall model: <ul>
                                                                <li><b>i. Software Requirements
                                                                        Analysis: </b>The
                                                                    requirements gathering
                                                                    process is intensified and
                                                                    focused specifically on
                                                                    software. </li>
                                                                <li><b>ii. Design Software:
                                                                    </b>Design is actually a
                                                                    multistep process that
                                                                    focuses on four distinct
                                                                    attributes of a program:
                                                                    data structure, software
                                                                    architecture, interface
                                                                    representations, and
                                                                    procedural (algorithmic)
                                                                    detail. The design process
                                                                    translates requirements into
                                                                    a representation of the
                                                                    software that can be
                                                                    assessed for quality before
                                                                    coding begins. Like
                                                                    requirements, the design is
                                                                    documented and becomes part
                                                                    of the software
                                                                    configuration. </li>
                                                                <li><b>iii. Code Generation:
                                                                    </b>The design must be
                                                                    translated into a
                                                                    machine-readable form. The
                                                                    code generation step
                                                                    performs this task. If
                                                                    design is performed in a
                                                                    detailed manner, code
                                                                    generation can be
                                                                    accomplished
                                                                    mechanistically. </li>
                                                                <li><b>iv. Testing: </b>Once
                                                                    code has been generated,
                                                                    program testing begins. The
                                                                    testing process focuses on
                                                                    the logical internals of the
                                                                    software, ensuring that all
                                                                    statements have been tested,
                                                                    and on the functional
                                                                    externals; that is,
                                                                    conducting tests to uncover
                                                                    errors and ensure that
                                                                    defined input will produce
                                                                    actual results that agree
                                                                    with required results. </li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Advantages<ul>
                                                        <li>i. Organized approach provides
                                                            robust separation of phases. </li>
                                                        <li>ii. Reflects common engineering
                                                            practice. </li>
                                                        <li>iii. A schedule can be set with
                                                            deadlines for each stage of
                                                            development and a product can
                                                            proceed through the development
                                                            process model phases one by one.
                                                        </li>
                                                        <li>iv. Development moves from concept,
                                                            through design, implementation,
                                                            testing, installation,
                                                            troubleshooting, and ends up at
                                                            operation and maintenance. </li>
                                                        <li>v. Each phase of development
                                                            proceeds in strict order. </li>
                                                    </ul>
                                                </li>
                                                <li>Disadvantages<ul>
                                                        <li>i. Doesn’t cope well with changes
                                                            the client makes in the
                                                            requirements. </li>
                                                        <li>ii. Development required by teams
                                                            might wait for each other. </li>
                                                        <li>iii. A working version of the
                                                            product is available only late.
                                                        </li>
                                                        <li>iv. No working software is produced
                                                            until late during the life cycle.
                                                        </li>
                                                        <li>v. High amounts of risk and
                                                            uncertainty. </li>
                                                        <li>vi. Not a good model for complex and
                                                            object-oriented projects. </li>
                                                        <li>vii. Poor model for long and ongoing
                                                            projects. </li>
                                                        <li>viii. Not suitable for the projects
                                                            where requirements are at a moderate
                                                            to high risk of changing. So risk
                                                            and uncertainty is high with this
                                                            process model. </li>
                                                        <li>ix. It is difficult to measure
                                                            progress within stages. </li>
                                                    </ul>
                                                </li>
                                                <li>Application<ul>
                                                        <li>i. When requirements are well known
                                                            and few changes are likely to be
                                                            needed. </li>
                                                        <li>ii. Can be used also for parts of
                                                            larger software systems. </li>
                                                        <li>iii. This model is used only when
                                                            the requirements are very well
                                                            known, clear and fixed. </li>
                                                        <li>iv. Product definition is stable.
                                                        </li>
                                                        <li>v. Technology is understood. </li>
                                                        <li>vi. There are no ambiguous
                                                            requirements </li>
                                                        <li>vii. Ample resources with required
                                                            expertise are available freely.
                                                        </li>
                                                        <li>viii. The project is short. </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>V-model<ul>
                                                <li>Theory<ul>
                                                        <li>The V - model is SDLC model where
                                                            execution of processes happens in a
                                                            sequential manner in V-shape. </li>
                                                        <li>It is also known as Verification and
                                                            Validation model. </li>
                                                        <li>V - Model is an extension of the
                                                            waterfall model and is based on
                                                            association of a testing phase for
                                                            each corresponding development
                                                            stage. </li>
                                                        <li>This means that for every single
                                                            phase in the development cycle there
                                                            is a directly associated testing
                                                            phase. </li>
                                                        <li>This is a highly disciplined model
                                                            and next phase starts only after
                                                            completion of the previous phase.
                                                        </li>
                                                        <li>Like the waterfall model, the
                                                            V-Shaped life cycle is a sequential
                                                            path of execution of processes.
                                                        </li>
                                                        <li>Each phase must be completed before
                                                            the next phase begins. </li>
                                                        <li>Testing of the product is planned in
                                                            parallel with a corresponding phase
                                                            of development. </li>
                                                    </ul>
                                                </li>
                                                <li>Phases of the V-model <ul>
                                                        <li><b>Requirements </b>like BRS and SRS
                                                            begin the life cycle model just like
                                                            the waterfall model. But, in this
                                                            model before development is started,
                                                            a system test plan is created. The
                                                            test plan focuses on meeting the
                                                            functionality specified in the
                                                            requirements gathering. </li>
                                                        <li><b>High-Level Design (HLD) </b>phase
                                                            focuses on system architecture and
                                                            design. It provide overview of
                                                            solution, platform, system, product
                                                            and service/process. An integration
                                                            test plan is created in this phase
                                                            as well in order to test the pieces
                                                            of the software systems ability to
                                                            work together. </li>
                                                        <li><b>Low-Level Design (LLD) </b>phase
                                                            is where the actual software
                                                            components are designed. It defines
                                                            the actual logic for each and every
                                                            component of the system. Class
                                                            diagram with all the methods and
                                                            relation between classes comes under
                                                            LLD. Component tests are created in
                                                            this phase as well. </li>
                                                        <li><b>Implementation </b>phase is,
                                                            where all coding takes place. Once
                                                            coding is complete, the path of
                                                            execution continues up the right
                                                            side of the V where the test plans
                                                            developed earlier are now put to
                                                            use. </li>
                                                        <li><b>Coding: </b>This is at the bottom
                                                            of the V-Shape model. Module design
                                                            is converted into code by
                                                            developers.</li>
                                                    </ul>
                                                </li>
                                                <li>Verification Phases<ul>
                                                        <li><b>Business Requirement Analysis:
                                                            </b>This is the first phase in the
                                                            development cycle where the product
                                                            requirements are understood from the
                                                            customer perspective. This phase
                                                            involves detailed communication with
                                                            the customer to understand his
                                                            expectations and exact requirement.
                                                            This is a very important activity
                                                            and need to be managed well, as most
                                                            of the customers are not sure about
                                                            what exactly they need. The
                                                            acceptance test design planning is
                                                            done at this stage as business
                                                            requirements can be used as an input
                                                            for acceptance testing. </li>
                                                        <li><b>System Design: </b>Once you have
                                                            the clear and detailed product
                                                            requirements, it’s time to design
                                                            the complete system. System design
                                                            would comprise of understanding and
                                                            detailing the complete hardware and
                                                            communication setup for the product
                                                            under development. System test plan
                                                            is developed based on the system
                                                            design. Doing this at an earlier
                                                            stage leaves more time for actual
                                                            test execution later. </li>
                                                        <li><b>Architectural Design:
                                                            </b>Architectural specifications are
                                                            understood and designed in this
                                                            phase. Usually more than one
                                                            technical approach is proposed and
                                                            based on the technical and financial
                                                            feasibility the final decision is
                                                            taken. System design is broken down
                                                            further into modules taking up
                                                            different functionality. This is
                                                            also referred to as High Level
                                                            Design (HLD).The data transfer and
                                                            communication between the internal
                                                            modules and with the outside world
                                                            (other systems) is clearly
                                                            understood and defined in this
                                                            stage. With this information,
                                                            integration tests can be designed
                                                            and documented during this stage.
                                                        </li>
                                                        <li><b>Module Design: </b>In this phase
                                                            the detailed internal design for all
                                                            the system modules is specified,
                                                            referred to as Low Level Design
                                                            (LLD). It is important that the
                                                            design is compatible with the other
                                                            modules in the system architecture
                                                            and the other external systems. Unit
                                                            tests are an essential part of any
                                                            development process and helps
                                                            eliminate the maximum faults and
                                                            errors at a very early stage. Unit
                                                            tests can be designed at this stage
                                                            based on the internal module
                                                            designs. </li>
                                                    </ul>
                                                </li>
                                                <li>Coding Phase<ul>
                                                        <li>The actual coding of the system
                                                            modules designed in the design phase
                                                            is taken up in the Coding phase.
                                                        </li>
                                                        <li>The best suitable programming
                                                            language is decided based on the
                                                            system and architectural
                                                            requirements. </li>
                                                        <li>The coding is performed based on the
                                                            coding guidelines and standards.
                                                        </li>
                                                        <li>The code goes through numerous code
                                                            reviews and is optimized for best
                                                            performance before the final build
                                                            is checked into the repository.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Validation Phases<ul>
                                                        <li><b>Unit Testing: </b>Unit tests
                                                            designed in the module design phase
                                                            are executed on the code during this
                                                            validation phase. Unit testing is
                                                            the testing at code level and helps
                                                            eliminate bugs at an early stage,
                                                            though all defects cannot be
                                                            uncovered by unit testing. </li>
                                                        <li><b>Integration Testing:
                                                            </b>Integration testing is
                                                            associated with the architectural
                                                            design phase. Integration tests are
                                                            performed to test the coexistence
                                                            and communication of the internal
                                                            modules within the system. </li>
                                                        <li><b>System Testing: </b>System
                                                            testing is directly associated with
                                                            the System design phase. System
                                                            tests check the entire system
                                                            functionality and the communication
                                                            of the system under development with
                                                            external systems. Most of the
                                                            software and hardware compatibility
                                                            issues can be uncovered during
                                                            system test execution. </li>
                                                        <li><b>Acceptance Testing:
                                                            </b>Acceptance testing is associated
                                                            with the business requirement
                                                            analysis phase and involves testing
                                                            the product in user environment.
                                                            Acceptance tests uncover the
                                                            compatibility issues with the other
                                                            systems available in the user
                                                            environment. It also discovers the
                                                            non-functional issues such as load
                                                            and performance defects in the
                                                            actual user environment. </li>
                                                    </ul>
                                                </li>
                                                <li>Advantages<ul>
                                                        <li>i. Simple and easy to use. </li>
                                                        <li>ii. Testing activities like
                                                            planning, test designing happens
                                                            well before coding. This saves a lot
                                                            of time. Hence higher chance of
                                                            success over the waterfall model.
                                                        </li>
                                                        <li>iii. Proactive defect tracking –
                                                            that is defects are found at early
                                                            stage. </li>
                                                        <li>iv. Avoids the downward flow of the
                                                            defects. </li>
                                                        <li>v. Works well for small projects
                                                            where requirements are easily
                                                            understood. </li>
                                                        <li>vi. This is a highly disciplined
                                                            model and Phases are completed one
                                                            at a time. </li>
                                                        <li>vii. Works well for smaller projects
                                                            where requirements are very well
                                                            understood. </li>
                                                        <li>viii. Easy to manage due to the
                                                            rigidity of the model. Each phase
                                                            has specific deliverables and a
                                                            review process. </li>
                                                    </ul>
                                                </li>
                                                <li>Disadvantages<ul>
                                                        <li>i. Very rigid and least flexible.
                                                        </li>
                                                        <li>ii. Software is developed during the
                                                            implementation phase, so no early
                                                            prototypes of the software are
                                                            produced. </li>
                                                        <li>iii. If any changes happen in
                                                            midway, then the test documents
                                                            along with requirement documents has
                                                            to be updated. </li>
                                                        <li>iv. High risk and uncertainty. </li>
                                                        <li>v. Not a good model for complex and
                                                            object-oriented projects. </li>
                                                        <li>vi. Poor model for long and ongoing
                                                            projects. </li>
                                                        <li>vii. Not suitable for the projects
                                                            where requirements are at a moderate
                                                            to high risk of changing. </li>
                                                        <li>viii. Once an application is in the
                                                            testing stage, it is difficult to go
                                                            back and change functionality </li>
                                                        <li>ix. No working software is produced
                                                            until late during the life cycle.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Application<ul>
                                                        <li>i. The V-shaped model should be used
                                                            for small to medium sized projects
                                                            where requirements are clearly
                                                            defined and fixed. </li>
                                                        <li>ii. The V-Shaped model should be
                                                            chosen when ample technical
                                                            resources are available with needed
                                                            technical expertise. </li>
                                                        <li>iii. High confidence of customer is
                                                            required for choosing the V-Shaped
                                                            model approach. Since, no prototypes
                                                            are produced, there is a very high
                                                            risk involved in meeting customer
                                                            expectations. </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Incremental Process Models<ul>
                                                <li>Theory<ul>
                                                        <li>The incremental model combines
                                                            elements of the linear sequential
                                                            model with the iterative philosophy
                                                            of prototyping. </li>
                                                        <li>In incremental model the whole
                                                            requirement is divided into various
                                                            builds. During each iteration, the
                                                            development module goes through the
                                                            requirements, design, implementation
                                                            and testing phases. </li>
                                                        <li>Each subsequent release of the
                                                            module adds function to the previous
                                                            release. The process continues till
                                                            the complete system is ready as per
                                                            the requirement. </li>
                                                        <li>The incremental model applies linear
                                                            sequences in a staggered fashion as
                                                            calendar time progresses. </li>
                                                        <li>Each linear sequence produces a
                                                            deliverable “increment” of the
                                                            software. </li>
                                                        <li>For example, word-processing
                                                            software developed using the
                                                            incremental paradigm might deliver
                                                            basic file management, editing, and
                                                            document production functions in the
                                                            first increment; more sophisticated
                                                            editing and document production
                                                            capabilities in the second
                                                            increment; spelling and grammar
                                                            checking in the third increment; and
                                                            advanced page layout capability in
                                                            the fourth increment. </li>
                                                        <li>It should be noted that the process
                                                            flow for any increment can
                                                            incorporate the prototyping
                                                            paradigm. </li>
                                                        <li>The incremental process model, like
                                                            prototyping and other evolutionary
                                                            approaches, is iterative in nature.
                                                        </li>
                                                        <li>But unlike prototyping, the
                                                            incremental model focuses on the
                                                            delivery of an operational product
                                                            with each increment. </li>
                                                        <li>Early increments are stripped down
                                                            versions of the final product, but
                                                            they do provide capability that
                                                            serves the user and also provide a
                                                            platform for evaluation by the user.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Advantages <ul>
                                                        <li>Provides better support for process
                                                            iteration. </li>
                                                        <li>Reduces rework in the software
                                                            construction process. </li>
                                                        <li>Some decisions on requirements may
                                                            be delayed. </li>
                                                        <li>Allows early delivery of parts of
                                                            the system. </li>
                                                        <li>Supports easier integration of
                                                            sub-systems. </li>
                                                        <li>Lower risk of project failure. </li>
                                                        <li>Delivery priorities can be more
                                                            easily set. </li>
                                                    </ul>
                                                </li>
                                                <li>Disadvantages <ul>
                                                        <li>Increments need be relatively small
                                                        </li>
                                                        <li>Mapping requirements to increments
                                                            may not be easy. </li>
                                                        <li>Common software facilities may be
                                                            difficult to identify. </li>
                                                        <li>More resources may be required.
                                                        </li>
                                                        <li>Although cost of change is lesser
                                                            but it is not very suitable for
                                                            changing requirements. </li>
                                                        <li>System architecture or design issues
                                                            may arise because not all
                                                            requirements are gathered in the
                                                            beginning of the entire life cycle.
                                                        </li>
                                                        <li>Defining increments may require
                                                            definition of the complete system.
                                                        </li>
                                                        <li>Management complexity is more. </li>
                                                        <li>Highly skilled resources are
                                                            required for risk analysis. </li>
                                                        <li>Project’s progress is highly
                                                            dependent upon the risk analysis
                                                            phase.</li>
                                                    </ul>
                                                </li>
                                                <li>Application <ul>
                                                        <li>When it is possible to deliver the
                                                            system “part-by-part”. </li>
                                                        <li>This model can be used when the
                                                            requirements of the complete system
                                                            are clearly defined and understood.
                                                        </li>
                                                        <li>Major requirements must be defined;
                                                            however, some details can evolve
                                                            with time. </li>
                                                        <li>There is a need to get a product to
                                                            the market early. </li>
                                                        <li>A new technology is being used </li>
                                                        <li>Resources with needed skill set are
                                                            not available </li>
                                                        <li>There are some high risk features
                                                            and goals. </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Evolutionary Process Models<ul>
                                                <li>Evolutionary models are iterative. They are
                                                    characterized in a manner that enables you
                                                    to develop increasingly more complete
                                                    versions of the software. In the paragraphs
                                                    that follow, we present two common
                                                    evolutionary process models.</li>
                                                <li>Prototyping Model <ul>
                                                        <li>Theory<ul>
                                                                <li>1. The prototyping paradigm
                                                                    begins with requirements
                                                                    gathering. </li>
                                                                <li>2. Developer and customer
                                                                    meet and define the overall
                                                                    objectives for the software,
                                                                    identify whatever
                                                                    requirements are known, and
                                                                    outline areas where further
                                                                    definition is mandatory.
                                                                </li>
                                                                <li>3. A "quick design" then
                                                                    occurs. The quick design
                                                                    focuses on a representation
                                                                    of those aspects of the
                                                                    software that will be
                                                                    visible to the customer/user
                                                                    (e.g., input approaches and
                                                                    output formats). </li>
                                                                <li>4. The quick design leads to
                                                                    the construction of a
                                                                    prototype. </li>
                                                                <li>5. The prototype is
                                                                    evaluated by the
                                                                    customer/user and used to
                                                                    refine requirements for the
                                                                    software to be developed.
                                                                    Iteration occurs as the
                                                                    prototype is tuned to
                                                                    satisfy the needs of the
                                                                    customer, while at the same
                                                                    time enabling the developer
                                                                    to better understand what
                                                                    needs to be done. </li>
                                                            </ul>
                                                        </li>
                                                        <li>Prototyping can also be problematic
                                                            for the following reasons: <ul>
                                                                <li>1. The customer sees what
                                                                    appears to be a working
                                                                    version of the software,
                                                                    unaware that the prototype
                                                                    is held together “with
                                                                    chewing gum and baling
                                                                    wire,” unaware that in the
                                                                    rush to get it working no
                                                                    one has considered overall
                                                                    software quality or
                                                                    long-term maintainability.
                                                                </li>
                                                                <li>2. When informed that the
                                                                    product must be rebuilt so
                                                                    that high levels of quality
                                                                    can be maintained, the
                                                                    customer cries foul and
                                                                    demands that "a few fixes"
                                                                    be applied to make the
                                                                    prototype a working product.
                                                                </li>
                                                                <li>3. Too often, software
                                                                    development management
                                                                    relents. </li>
                                                                <li>4. The developer often makes
                                                                    implementation compromises
                                                                    in order to get a prototype
                                                                    working quickly. </li>
                                                                <li>5. An inappropriate
                                                                    operating system or
                                                                    programming language may be
                                                                    used simply because it is
                                                                    available and known; an
                                                                    inefficient algorithm may be
                                                                    implemented simply to
                                                                    demonstrate capability.
                                                                </li>
                                                                <li>6. After a time, the
                                                                    developer may become
                                                                    familiar with these choices
                                                                    and forget all the reasons
                                                                    why they were inappropriate.
                                                                </li>
                                                                <li>7. The less-than-ideal
                                                                    choice has now become an
                                                                    integral part of the system.
                                                                </li>
                                                            </ul>
                                                        </li>
                                                        <li>Advantages <ul>
                                                                <li>i. Increased user
                                                                    involvement in the product
                                                                    even before implementation
                                                                </li>
                                                                <li>ii. Since a working model of
                                                                    the system is displayed, the
                                                                    users get a better
                                                                    understanding of the system
                                                                    being developed. </li>
                                                                <li>iii. Reduces time and cost
                                                                    as the defects can be
                                                                    detected much earlier. </li>
                                                                <li>iv. Quicker user feedback is
                                                                    available leading to better
                                                                    solutions. </li>
                                                                <li>v. Missing functionality can
                                                                    be identified easily </li>
                                                                <li>vi. Confusing or difficult
                                                                    functions can be identified
                                                                </li>
                                                            </ul>
                                                        </li>
                                                        <li>Disadvantages <ul>
                                                                <li>i. Risk of insufficient
                                                                    requirement analysis owing
                                                                    to too much dependency on
                                                                    prototype </li>
                                                                <li>ii. Users may get confused
                                                                    in the prototypes and actual
                                                                    systems. </li>
                                                                <li>iii. Practically, this
                                                                    methodology may increase the
                                                                    complexity of the system as
                                                                    scope of the system may
                                                                    expand beyond original
                                                                    plans. </li>
                                                                <li>iv. Developers may try to
                                                                    reuse the existing
                                                                    prototypes to build the
                                                                    actual system, even when
                                                                    it’s not technically
                                                                    feasible </li>
                                                                <li>v. The effort invested in
                                                                    building prototypes may be
                                                                    too much if not monitored
                                                                    properly. </li>
                                                            </ul>
                                                        </li>
                                                        <li>Application <ul>
                                                                <li>i. Prototype model should be
                                                                    used when the desired system
                                                                    needs to have a lot of
                                                                    interaction with the end
                                                                    users. </li>
                                                                <li>ii. Typically, online
                                                                    systems, web interfaces have
                                                                    a very high amount of
                                                                    interaction with end users,
                                                                    are best suited for
                                                                    Prototype model. It might
                                                                    take a while for a system to
                                                                    be built that allows ease of
                                                                    use and needs minimal
                                                                    training for the end user.
                                                                </li>
                                                                <li>iii. Prototyping ensures
                                                                    that the end users
                                                                    constantly work with the
                                                                    system and provide a
                                                                    feedback which is
                                                                    incorporated in the
                                                                    prototype to result in a
                                                                    useable system. They are
                                                                    excellent for designing good
                                                                    human computer interface
                                                                    systems. </li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Spiral Model <ul>
                                                        <li>Theory<ul>
                                                                <li>A spiral model is divided
                                                                    into a number of framework
                                                                    activities, also called task
                                                                    regions. Typically, there
                                                                    are between three and six
                                                                    task regions. spiral model
                                                                    that contains six task
                                                                    regions: </li>
                                                                <li>1. Customer
                                                                    Communication—tasks required
                                                                    to establish effective
                                                                    communication between
                                                                    developer and customer.
                                                                </li>
                                                                <li>2. Planning—tasks required
                                                                    to define resources,
                                                                    timelines, and other project
                                                                    related information. </li>
                                                                <li>3. Risk Analysis—tasks
                                                                    required to assess both
                                                                    technical and management
                                                                    risks. </li>
                                                                <li>4. Engineering—tasks
                                                                    required to build one or
                                                                    more representations of the
                                                                    application. </li>
                                                                <li>5. Construction and
                                                                    Release—tasks required to
                                                                    construct, test, install,
                                                                    and provide user support
                                                                    (e.g., documentation and
                                                                    training). </li>
                                                            </ul>
                                                        </li>
                                                        <li>Phases<ul>
                                                                <li>Phase Name <ul>
                                                                        <li>Activities performed
                                                                        </li>
                                                                        <li>Deliverables /
                                                                            Output </li>
                                                                    </ul>
                                                                </li>
                                                                <li>Planning <ul>
                                                                        <li>Requirements are
                                                                            studied and
                                                                            gathered.
                                                                            Feasibility study
                                                                            Reviews and
                                                                            walkthroughs to
                                                                            streamline the
                                                                            requirements </li>
                                                                        <li>Requirements
                                                                            understanding
                                                                            document Finalized
                                                                            list of
                                                                            requirements. </li>
                                                                    </ul>
                                                                </li>
                                                                <li>Risk Analysis <ul>
                                                                        <li>Requirements are
                                                                            studied and brain
                                                                            storming sessions
                                                                            are done to identify
                                                                            the potential risks.
                                                                            Once the risks are
                                                                            identified , risk
                                                                            mitigation strategy
                                                                            is planned and
                                                                            finalized </li>
                                                                        <li>Document which
                                                                            highlights all the
                                                                            risks and its
                                                                            mitigation plans.
                                                                        </li>
                                                                    </ul>
                                                                </li>
                                                                <li>Engineering <ul>
                                                                        <li>Actual development
                                                                            and testing if the
                                                                            software takes place
                                                                            in this phase </li>
                                                                        <li>Code Test cases and
                                                                            test result. Test
                                                                            summary report and
                                                                            defect report. </li>
                                                                    </ul>
                                                                </li>
                                                                <li>Evaluation <ul>
                                                                        <li>Customers evaluate
                                                                            the software and
                                                                            provide their
                                                                            feedback and
                                                                            approval </li>
                                                                        <li>Features implemented
                                                                            document </li>
                                                                    </ul>
                                                                </li>
                                                            </ul>
                                                        </li>
                                                        <li>Advantages <ul>
                                                                <li>i. Risk reduction mechanisms
                                                                    are in place. </li>
                                                                <li>ii. Spiral Life Cycle Model
                                                                    is one of the most flexible
                                                                    SDLC models in place. </li>
                                                                <li>iii. Development phases can
                                                                    be determined by the project
                                                                    manager, according to the
                                                                    complexity of the project.
                                                                </li>
                                                                <li>iv. Project monitoring is
                                                                    very easy and effective.
                                                                    Each phase, as well as each
                                                                    loop, requires a review from
                                                                    concerned people. This makes
                                                                    the model more transparent.
                                                                </li>
                                                                <li>v. Risk management is one of
                                                                    the in-built features of the
                                                                    model, which makes it extra
                                                                    attractive compared to other
                                                                    models. </li>
                                                                <li>vi. Changes can be
                                                                    introduced later in the life
                                                                    cycle as well. And coping
                                                                    with these changes isn’t a
                                                                    very big headache for the
                                                                    project manager. </li>
                                                                <li>vii. Project estimates in
                                                                    terms of schedule, cost etc.
                                                                    become more and more
                                                                    realistic as the project
                                                                    moves forward and loops in
                                                                    spiral get completed. </li>
                                                                <li>viii. It is suitable for
                                                                    high risk projects, where
                                                                    business needs may be
                                                                    unstable. </li>
                                                                <li>ix. A highly customized
                                                                    product can be developed
                                                                    using this. </li>
                                                                <li>x. Systematic approach.
                                                                </li>
                                                            </ul>
                                                        </li>
                                                        <li>Disadvantages <ul>
                                                                <li>i. Requires expertise in
                                                                    risk evaluation and
                                                                    reduction. </li>
                                                                <li>ii. Complex, relatively
                                                                    difficult to follow
                                                                    strictly. </li>
                                                                <li>iii. Cost involved in this
                                                                    model is usually high. </li>
                                                                <li>iv. It is a complicated
                                                                    approach especially for
                                                                    projects with a clear SRS.
                                                                </li>
                                                                <li>v. Skills required,
                                                                    evaluating and reviewing
                                                                    project from time to time,
                                                                    need expertise. </li>
                                                                <li>vi. Rules and protocols
                                                                    should be followed properly
                                                                    to effectively implement
                                                                    this model. Doing so,
                                                                    through-out the span of
                                                                    project is tough. </li>
                                                                <li>vii. Due to various
                                                                    customizations allowed from
                                                                    the client, using the same
                                                                    prototype in other projects,
                                                                    in future, is difficult.
                                                                </li>
                                                                <li>viii. It is not suitable for
                                                                    low risk projects. </li>
                                                                <li>ix. Meeting budgetary and
                                                                    scheduling requirements is
                                                                    tough if this development
                                                                    process is followed. </li>
                                                                <li>x. Amount of documentation
                                                                    required in intermediate
                                                                    stages makes management of
                                                                    project very complex affair.
                                                                </li>
                                                                <li>xi. Applicable only to large
                                                                    systems. </li>
                                                            </ul>
                                                        </li>
                                                        <li>Application <ul>
                                                                <li>i. Internal development of
                                                                    large systems. </li>
                                                                <li>ii. This model can be used
                                                                    when the requirements of the
                                                                    complete system are clearly
                                                                    defined and understood.
                                                                </li>
                                                                <li>iii. Major requirements must
                                                                    be defined; however, some
                                                                    details can evolve with
                                                                    time. </li>
                                                                <li>iv. There is a need to get a
                                                                    product to the market early.
                                                                </li>
                                                                <li>v. A new technology is being
                                                                    used. </li>
                                                                <li>vi. Resources with needed
                                                                    skill set are not available.
                                                                </li>
                                                                <li>vii. There are some high
                                                                    risk features and goals.
                                                                </li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Concurrent Models<ul>
                                                <li>The <i>concurrent development model,
                                                    </i>sometimes called <i>concurrent
                                                        engineering, </i>allows a software team
                                                    to represent iterative and concurrent
                                                    elements of any of<i> </i>the process models
                                                    described in this chapter. For example, the
                                                    modeling activity defined for the spiral
                                                    model is accomplished by invoking one or
                                                    more of the following software engineering
                                                    actions: prototyping, analysis, and design.
                                                    An activity— modeling —may be in any one of
                                                    the states 7 noted at any given time.
                                                    Similarly, other activities, actions, or
                                                    tasks (e.g., communication or construction)
                                                    can be represented in an analogous manner.
                                                    All software engineering activities exist
                                                    concurrently but reside in different states.
                                                    For example, early in a project the
                                                    communication activity (not shown in the
                                                    figure) has completed its first iteration
                                                    and exists in the awaiting changes state.
                                                    The modeling activity (which existed in the
                                                    none state while initial communication was
                                                    completed) now makes a transition into the
                                                    under development state. If, however, the
                                                    customer indicates that changes in
                                                    requirements must be made, the modeling
                                                    activity moves from the under development
                                                    state into the awaiting changes state.
                                                    Concurrent modeling defines a series of
                                                    events that will trigger transitions from
                                                    state to state for each of the software
                                                    engineering activities, actions, or tasks.
                                                    For example, during early stages of design
                                                    (a major software engineering action that
                                                    occurs during the modeling activity), an
                                                    inconsistency in the requirements model is
                                                    uncovered. This generates the event
                                                    <i>analysis model correction,</i> which will
                                                    trigger the requirements analysis action
                                                    from the done state into the awaiting
                                                    changes state.
                                                </li>
                                                <li>Concurrent modeling is applicable to all
                                                    types of software development and provides
                                                    an accurate picture of the current state of
                                                    a project. Rather than confining software
                                                    engineering activities, actions, and tasks
                                                    to a sequence of events, it defines a
                                                    process network. Each activity, action, or
                                                    task on the network exists simultaneously
                                                    with other activities, actions, or tasks.
                                                    Events generated at one point in the process
                                                    network trigger transitions among the states
                                                    associated with each activity.</li>
                                            </ul>
                                        </li>
                                        <li>Agile process<ul>
                                                <li>Theory<ul>
                                                        <li>1. The Agile movement proposes
                                                            alternatives to traditional project
                                                            management. </li>
                                                        <li>2. Agile approaches are typically
                                                            used in software development to help
                                                            businesses respond to
                                                            unpredictability. </li>
                                                        <li>3. It’s easy to the problems with
                                                            “waterfall” methodology. </li>
                                                        <li>4. It assumes that every requirement
                                                            of the project can be identified
                                                            before any design or coding occurs.
                                                        </li>
                                                        <li>5. At the end of a project, a team
                                                            might have built the software it was
                                                            asked to build, but, in the time it
                                                            took to create, business realities
                                                            have changed so dramatically that
                                                            the product is irrelevant. </li>
                                                        <li>6. Today very view organizations
                                                            openly admit to doing waterfall or
                                                            traditional command and control. But
                                                            those habits persist.</li>
                                                    </ul>
                                                </li>
                                                <li>Advantages <ul>
                                                        <li>i. Customer satisfaction by rapid,
                                                            continuous delivery of useful
                                                            software. </li>
                                                        <li>ii. People and interactions are
                                                            emphasized rather than process and
                                                            tools. Customers, developers and
                                                            testers constantly interact with
                                                            each other. </li>
                                                        <li>iii. Working software is delivered
                                                            frequently (weeks rather than
                                                            months). </li>
                                                        <li>iv. Face-to-face conversation is the
                                                            best form of communication. </li>
                                                        <li>v. Close, daily cooperation between
                                                            business people and developers.
                                                        </li>
                                                        <li>vi. Continuous attention to
                                                            technical excellence and good
                                                            design. </li>
                                                        <li>vii. Regular adaptation to changing
                                                            circumstances. </li>
                                                        <li>viii. Even late changes in
                                                            requirements are welcomed. </li>
                                                    </ul>
                                                </li>
                                                <li>Disadvantages <ul>
                                                        <li>i. In case of some software
                                                            deliverables, especially the large
                                                            ones, it is difficult to assess the
                                                            effort required at the beginning of
                                                            the software development life cycle.
                                                        </li>
                                                        <li>ii. There is lack of emphasis on
                                                            necessary designing and
                                                            documentation. </li>
                                                        <li>iii. The project can easily get
                                                            taken off track if the customer
                                                            representative is not clear what
                                                            final outcome that they want. </li>
                                                        <li>iv. Only senior programmers are
                                                            capable of taking the kind of
                                                            decisions required during the
                                                            development process. Hence it has no
                                                            place for newbie programmers, unless
                                                            combined with experienced resources.
                                                        </li>
                                                        <li>v. It can be difficult to keep the
                                                            interest of customers who are
                                                            involved in the process. </li>
                                                        <li>vi. Team members may be unsuited to
                                                            the intense involvement that
                                                            characterizes agile method. </li>
                                                        <li>vii. Prioritizing changes can be
                                                            difficult where there are multiple
                                                            stakeholders. </li>
                                                        <li>viii. Maintaining simplicity
                                                            requires extra work. </li>
                                                        <li>ix. Contracts may be a problem as
                                                            with other approaches to iterative
                                                            development. </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Agility Principles<ul>
                                                <li>12 agility principles for those who want to
                                                    achieve agility:</li>
                                                <li>1. Our highest priority is to satisfy the
                                                    customer through early and continuous
                                                    delivery of valuable software.</li>
                                                <li>2. Welcome changing requirements, even late
                                                    in development. Agile processes harness
                                                    change for the customer's competitive
                                                    advantage.</li>
                                                <li>3. Deliver working software frequently, from
                                                    a couple of weeks to a couple of months,
                                                    with a preference to the shorter timescale.
                                                </li>
                                                <li>4. Business people and developers must work
                                                    together daily throughout the project.</li>
                                                <li>5. Build projects around motivated
                                                    individuals. Give them the environment and
                                                    support they need, and trust them to get the
                                                    job done.</li>
                                                <li>6. The most efficient and effective method
                                                    of conveying information to and within a
                                                    development team is face-to-face
                                                    conversation.</li>
                                                <li>7. Working software is the primary measure
                                                    of progress.</li>
                                                <li>8. Agile processes promote sustainable
                                                    development. The sponsors, developers, and
                                                    users should be able to maintain a constant
                                                    pace indefinitely.</li>
                                                <li>9. Continuous attention to technical
                                                    excellence and good design enhances agility.
                                                </li>
                                                <li>10. Simplicity—the art of maximizing the
                                                    amount of work not done—is essential.</li>
                                                <li>11. The best architectures, requirements,
                                                    and designs emerge from self-organizing
                                                    teams.</li>
                                                <li>12. At regular intervals, the team reflects
                                                    on how to become more effective, then tunes
                                                    and adjusts its behavior accordingly.</li>
                                            </ul>
                                        </li>
                                        <li>Extreme Programming (XP)<ul>
                                                <li>Extreme Programming (XP) takes an ‘extreme’
                                                    approach to iterative development. </li>
                                                <li>1. New versions may be built several times
                                                    per day; </li>
                                                <li>2. Increments are delivered to customers
                                                    every 2 weeks; </li>
                                                <li>3. All tests must be run for every build and
                                                    the build is only accepted if tests run
                                                    successfully. </li>
                                                <li>4. The extreme programming release cycle
                                                </li>
                                                <li>CPMCD</li>
                                                <li>5. Extreme programming practices <ul>
                                                        <li>Incremental planning <ul>
                                                                <li>Requirements are recorded on
                                                                    story cards and the stories
                                                                    to be included in a release
                                                                    are determined by the time
                                                                    available and their relative
                                                                    priority. The developers
                                                                    break these stories into
                                                                    development ‘Tasks’. </li>
                                                            </ul>
                                                        </li>
                                                        <li>Small releases <ul>
                                                                <li>The minimal useful set of
                                                                    functionality that provides
                                                                    business value is developed
                                                                    first. Releases of the
                                                                    system are frequent and
                                                                    incrementally add
                                                                    functionality to the first
                                                                    release. </li>
                                                            </ul>
                                                        </li>
                                                        <li>Simple design <ul>
                                                                <li>Enough design is carried out
                                                                    to meet the current
                                                                    requirements and no more.
                                                                </li>
                                                            </ul>
                                                        </li>
                                                        <li>Test-first development <ul>
                                                                <li>An automated unit test
                                                                    framework is used to write
                                                                    tests for a new piece of
                                                                    functionality before that
                                                                    functionality itself is
                                                                    implemented. </li>
                                                            </ul>
                                                        </li>
                                                        <li>Refactoring <ul>
                                                                <li>All developers are expected
                                                                    to refactor the code
                                                                    continuously as soon as
                                                                    possible code improvements
                                                                    are found. This keeps the
                                                                    code simple and
                                                                    maintainable. </li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Scrum<ul>
                                                <li>Scrum is one of the most popular frameworks
                                                    for implementing agile.</li>
                                                <li>With scrum, the product is built in a series
                                                    of fixed-length iterations called sprints
                                                    that give teams a framework for shipping
                                                    software on a regular cadence.
                                                    Milestones–i.e., the end of a sprint–come
                                                    frequently, bringing with them a feeling of
                                                    tangible progress with each cycle that
                                                    focuses and energizes everyone. Short
                                                    iterations also reinforce the importance of
                                                    good estimation and fast feedback from
                                                    tests–both recurring struggles in waterfall
                                                    projects.</li>
                                                <li>During a sprint, visual artifacts like task
                                                    boards and burn down charts, visible to the
                                                    team and spectators alike, are powerful
                                                    motivators. They drive a spirit of "we're
                                                    doing this!" Having the opportunity to show
                                                    off new work at the sprint demo is equally
                                                    motivating, and the consistent, incremental
                                                    feedback the team gets from stakeholders at
                                                    each demo creates a powerful way to develop
                                                    products.<ul>
                                                        <li>Backlog<ul>
                                                                <li>A prioritized list of
                                                                    project requirements or
                                                                    features that provide
                                                                    business value for the
                                                                    customer. Items can be added
                                                                    to the backlog at any time
                                                                    (this is how changes are
                                                                    introduced). The product
                                                                    manager assesses the backlog
                                                                    and updates priorities as
                                                                    required.</li>
                                                            </ul>
                                                        </li>
                                                        <li>Sprint<ul>
                                                                <li>Consist of work units that
                                                                    are required to achieve a
                                                                    requirement defined in the
                                                                    backlog that must be fi t
                                                                    into a predefined time-box
                                                                    10 (typically 30 days).
                                                                    Changes (e.g., backlog work
                                                                    items) are not introduced
                                                                    during the sprint. Hence,
                                                                    the sprint allows team
                                                                    members to work in a
                                                                    short-term, but stable
                                                                    environment.</li>
                                                            </ul>
                                                        </li>
                                                        <li>Scrum meeting<ul>
                                                                <li>Are short (typically
                                                                    15-minute) meetings held
                                                                    daily by the Scrum team.
                                                                    Three key questions are
                                                                    asked and answered by all
                                                                    team members:<ul>
                                                                        <li>• What did you do
                                                                            since the last team
                                                                            meeting?</li>
                                                                        <li>• What obstacles are
                                                                            you encountering?
                                                                        </li>
                                                                        <li>• What do you plan
                                                                            to accomplish by the
                                                                            next team meeting?
                                                                        </li>
                                                                    </ul>
                                                                </li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Scrum done well–which is to say, not
                                                    "waterfall with stand-ups"–can be a massive
                                                    catalyst for improving team productivity and
                                                    morale, and the product development process
                                                    as a whole.</li>
                                                <li>Three essential roles for scrum success- A
                                                    scrum team has a slightly different
                                                    composition than a traditional waterfall
                                                    project, with three specific roles: product
                                                    owner, scrum master, and the development
                                                    team. And because scrum teams are
                                                    cross-functional, "the development team"
                                                    includes testers, designers, and ops
                                                    engineers in addition to developers.<ul>
                                                        <li>The Product Owner<ul>
                                                                <li>Product owners are the
                                                                    champions for their product.
                                                                    They are focused on
                                                                    understanding business and
                                                                    market requirements, then
                                                                    prioritizing the work to be
                                                                    done by the engineering team
                                                                    accordingly. Effective
                                                                    product owners:</li>
                                                                <li>Build and manage the product
                                                                    backlog</li>
                                                                <li>Closely partner with the
                                                                    business and the team to
                                                                    ensure everyone understands
                                                                    the work items in the
                                                                    product backlog</li>
                                                                <li>Give the team clears
                                                                    guidance on which features
                                                                    to deliver next</li>
                                                                <li>Decide when to ship the
                                                                    product with the
                                                                    predisposition towards more
                                                                    frequent delivery.</li>
                                                            </ul>
                                                        </li>
                                                        <li>The Scrum Master<ul>
                                                                <li>Scrum masters are the
                                                                    champion for scrum within
                                                                    their team. They coach the
                                                                    team, the product owner, and
                                                                    the business on the scrum
                                                                    process and look for ways to
                                                                    fine-tune their practice of
                                                                    it. An effective scrum
                                                                    master deeply understands
                                                                    the work being done by the
                                                                    team and can help the team
                                                                    optimize their delivery
                                                                    flow. As the
                                                                    facilitator-in-chief, they
                                                                    schedule the needed
                                                                    resources (both human and
                                                                    logistical) for sprint
                                                                    planning, stand-up, sprint
                                                                    review, and the sprint
                                                                    retrospective.</li>
                                                            </ul>
                                                        </li>
                                                        <li>The Scrum Team<ul>
                                                                <li>Scrum teams are the
                                                                    champions for sustainable
                                                                    development practices. The
                                                                    most effective scrum teams
                                                                    are tight-knit, co-located,
                                                                    and usually 5 to 7 members.
                                                                    Team members have differing
                                                                    skill sets, and cross-train
                                                                    each other so no one person
                                                                    becomes a bottleneck in the
                                                                    delivery of work. Strong
                                                                    scrum teams approach their
                                                                    project with a clear "we"
                                                                    attitude. All members of the
                                                                    team help one another to
                                                                    ensure a successful sprint
                                                                    completion.</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Kanban model <ul>
                                                <li>Kanban board is used to depict the flow of
                                                    tasks across the value stream. The Kanban
                                                    board −<ul>
                                                        <li>Provides easy access to everyone
                                                            involved in the project.</li>
                                                        <li>Facilitates communication as and
                                                            when necessary.</li>
                                                        <li>Progress of the tasks is visually
                                                            displayed.</li>
                                                        <li>Bottlenecks are visible as soon as
                                                            they occur.</li>
                                                    </ul>
                                                </li>
                                                <li>Advantages of Kanban board<ul>
                                                        <li>Empowerment of Team&nbsp;− This
                                                            means −<ul>
                                                                <li>Team is allowed to take
                                                                    decisions as and when
                                                                    required.</li>
                                                                <li>Team collaboratively
                                                                    resolves the bottlenecks.
                                                                </li>
                                                                <li>Team has access to the
                                                                    relevant information.</li>
                                                                <li>Team continually
                                                                    communicates with customer.
                                                                </li>
                                                            </ul>
                                                        </li>
                                                        <li>Continuous Delivery&nbsp;− This
                                                            means −<ul>
                                                                <li>Focus on work completion.
                                                                </li>
                                                                <li>Limited requirements at any
                                                                    point of time.</li>
                                                                <li>Focus on delivering value to
                                                                    the customer.</li>
                                                                <li>Emphasis on whole project.
                                                                </li>
                                                            </ul>
                                                        </li>
                                                        <li>The tasks and stories are
                                                            represented by Kanban cards. The
                                                            current status of each task is known
                                                            by displaying the cards in separate
                                                            columns on the board. The columns
                                                            are labeled as&nbsp;To Do, Doing,
                                                            and&nbsp;Done. Each task moves
                                                            from&nbsp;To
                                                            Do&nbsp;to&nbsp;Doing&nbsp;and then
                                                            to&nbsp;Done.</li>
                                                        <li>Kanban Board is updated on a daily
                                                            basis as the team progresses through
                                                            the development.</li>
                                                    </ul>
                                                </li>
                                                <li>WIP Limit<ul>
                                                        <li>The label in the Doing column also
                                                            contains a number, which represents
                                                            the maximum number of tasks that can
                                                            be in that column at any point of
                                                            time. i.e., the number associated
                                                            with the&nbsp;Doing&nbsp;column is
                                                            the WIP (Work-In-Progress) Limit.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Pull Approach<ul>
                                                        <li>Pull approach is used as and when a
                                                            task is completed in the Doing
                                                            column. Another card is pulled from
                                                            the To Do column.</li>
                                                    </ul>
                                                </li>
                                                <li>Self-directing<ul>
                                                        <li>In Agile Development, the team is
                                                            responsible for planning, tracking,
                                                            reporting and communicating in the
                                                            project. Team is allowed to make
                                                            decisions and is accountable for the
                                                            completion of the development and
                                                            product quality. This is aligned to
                                                            the characteristic of empowerment of
                                                            the team in Kanban.</li>
                                                    </ul>
                                                </li>
                                                <li>Continuous Flow<ul>
                                                        <li>In Agile development, there is no
                                                            gate approach and the work flows
                                                            across the different functions
                                                            without wait-time. This contributes
                                                            in minimizing the cycle time
                                                            characteristic of Kanban.</li>
                                                    </ul>
                                                </li>
                                                <li>Visual Metrics<ul>
                                                        <li>In Agile Kanban, the metrics are
                                                            tracked visually using −<ul>
                                                                <li>Kanban Board </li>
                                                                <li>Burndown Chart</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Uses of Kanban board<ul>
                                                        <li>Kanban Board is used to −<ul>
                                                                <li>Measure the cycle times that
                                                                    can be used to optimize
                                                                    average cycle time. </li>
                                                                <li>Track WIP limit to eliminate
                                                                    waste. </li>
                                                                <li>Track resource utilization
                                                                    to eliminate waste.</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Uses of Burndown chart<ul>
                                                        <li>Burndown chart is used to capture −
                                                            <ul>
                                                                <li>The current status of the
                                                                    tasks and stories.</li>
                                                                <li>The rate of progress of
                                                                    completing the remaining
                                                                    tasks.</li>
                                                            </ul>
                                                        </li>
                                                        <li>As Kanban Board is updated daily, it
                                                            contains all the information that is
                                                            required by the Burndown charts.
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Chapter 2<ul>
                        <li>Requirements Analysis<ul>
                                <li>Requirement Elicitation<ul>
                                        <li>Introduction<ul>
                                                <li>Requirements elicitation (also called
                                                    <i>requirements gathering)</i> combines
                                                    elements of problem solving, elaboration,
                                                    negotiation, and specification. In order to
                                                    encourage a collaborative, team-oriented
                                                    approach to requirements gathering,
                                                    stakeholders work together to identify the
                                                    problem, propose elements of the solution,
                                                    negotiate different approaches, and specify
                                                    a preliminary set of solution requirements.
                                                </li>
                                                <li>Requirements elicitation and analysis may
                                                    involve a variety of different kinds of
                                                    people in an organization. A system
                                                    stakeholder is anyone who should have some
                                                    direct or indirect influence on the system
                                                    requirements. Stakeholders include end users
                                                    who will interact with the system and anyone
                                                    else in an organization who will be affected
                                                    by it. Other system stakeholders might be
                                                    engineers who are developing or maintaining
                                                    other related systems, business managers,
                                                    domain experts, and trade union
                                                    representatives.</li>
                                                <li>A process model of the elicitation and
                                                    analysis process is shown in Figure. Each
                                                    organization will have its own version or
                                                    instantiation of this general model
                                                    depending on local factors such as the
                                                    expertise of the staff, the type of system
                                                    being developed, the standards used, etc.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Process activities<ul>
                                                <li>Requirements discovery<ul>
                                                        <li>This is the process of interacting
                                                            with stakeholders of the system to
                                                            discover their requirements. Domain
                                                            requirements from stakeholders and
                                                            documentation are also discovered
                                                            during this activity. There are
                                                            several complementary techniques
                                                            that can be used for requirements
                                                            discovery, which I discuss later in
                                                            this section.</li>
                                                    </ul>
                                                </li>
                                                <li>Requirements classification and organization
                                                    <ul>
                                                        <li>This activity takes the unstructured
                                                            collection of requirements, groups
                                                            related requirements, and organizes
                                                            them into coherent clusters. The
                                                            most common way of grouping
                                                            requirements is to use a model of
                                                            the system architecture to identify
                                                            sub-systems and to associate
                                                            requirements with each sub-system.
                                                            In practice, requirements
                                                            engineering and architectural design
                                                            cannot be completely separate
                                                            activities.</li>
                                                    </ul>
                                                </li>
                                                <li>Requirements prioritization and negotiation
                                                    <ul>
                                                        <li>Inevitably, when multiple
                                                            stakeholders are involved,
                                                            requirements will conflict. This
                                                            activity is concerned with
                                                            prioritizing requirements and
                                                            finding and resolving requirements
                                                            conflicts through negotiation.
                                                            Usually, stakeholders have to meet
                                                            to resolve differences and agree on
                                                            compromise requirements.</li>
                                                    </ul>
                                                </li>
                                                <li>Requirements specification<ul>
                                                        <li>The requirements are documented and
                                                            input into the next round of the
                                                            spiral. Formal or informal
                                                            requirements documents may be
                                                            produced.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Requirement Elicitation Techniques<ul>
                                                <li>Introduction<ul>
                                                        <li>Requirements Elicitation is the
                                                            process to find out the requirements
                                                            for an intended software system by
                                                            communicating with client, end
                                                            users, system users and others who
                                                            have a stake in the software system
                                                            development.</li>
                                                    </ul>
                                                </li>
                                                <li>Ways to discover requirements<ul>
                                                        <li>Interviews<ul>
                                                                <li>Interviews are strong medium
                                                                    to collect requirements.
                                                                    Organization may conduct
                                                                    several types of interviews
                                                                    such as:</li>
                                                                <li>Structured (closed)
                                                                    interviews, where every
                                                                    single information to gather
                                                                    is decided in advance, they
                                                                    follow pattern and matter of
                                                                    discussion firmly.</li>
                                                                <li>Non-structured (open)
                                                                    interviews, where
                                                                    information to gather is not
                                                                    decided in advance, more
                                                                    flexible and less biased.
                                                                </li>
                                                                <li>Oral interviews</li>
                                                                <li>Written interviews</li>
                                                                <li>One-to-one interviews which
                                                                    are held between two persons
                                                                    across the table.</li>
                                                                <li>Group interviews which are
                                                                    held between groups of
                                                                    participants. They help to
                                                                    uncover any missing
                                                                    requirement as numerous
                                                                    people are involved.</li>
                                                            </ul>
                                                        </li>
                                                        <li>Surveys<ul>
                                                                <li>Organization may conduct
                                                                    surveys among various
                                                                    stakeholders by querying
                                                                    about their expectation and
                                                                    requirements from the
                                                                    upcoming system.</li>
                                                            </ul>
                                                        </li>
                                                        <li>Questionnaires<ul>
                                                                <li>A document with pre-defined
                                                                    set of objective questions
                                                                    and respective options is
                                                                    handed over to all
                                                                    stakeholders to answer,
                                                                    which are collected and
                                                                    compiled.</li>
                                                                <li>A shortcoming of this
                                                                    technique is, if an option
                                                                    for some issue is not
                                                                    mentioned in the
                                                                    questionnaire, the issue
                                                                    might be left unattended.
                                                                </li>
                                                            </ul>
                                                        </li>
                                                        <li>Task analysis<ul>
                                                                <li>Team of engineers and
                                                                    developers may analyze the
                                                                    operation for which the new
                                                                    system is required. If the
                                                                    client already has some
                                                                    software to perform certain
                                                                    operation, it is studied and
                                                                    requirements of proposed
                                                                    system are collected.</li>
                                                            </ul>
                                                        </li>
                                                        <li>Domain Analysis<ul>
                                                                <li>Every software falls into
                                                                    some domain category. The
                                                                    expert people in the domain
                                                                    can be a great help to
                                                                    analyze general and specific
                                                                    requirements.</li>
                                                            </ul>
                                                        </li>
                                                        <li>Brainstorming<ul>
                                                                <li>An informal debate is held
                                                                    among various stakeholders
                                                                    and all their inputs are
                                                                    recorded for further
                                                                    requirements analysis.</li>
                                                            </ul>
                                                        </li>
                                                        <li>Prototyping<ul>
                                                                <li>Prototyping is building user
                                                                    interface without adding
                                                                    detail functionality for
                                                                    user to interpret the
                                                                    features of intended
                                                                    software product. It helps
                                                                    giving better idea of
                                                                    requirements. If there is no
                                                                    software installed at
                                                                    client’s end for developer’s
                                                                    reference and the client is
                                                                    not aware of its own
                                                                    requirements, the developer
                                                                    creates a prototype based on
                                                                    initially mentioned
                                                                    requirements. The prototype
                                                                    is shown to the client and
                                                                    the feedback is noted. The
                                                                    client feedback serves as an
                                                                    input for requirement
                                                                    gathering.</li>
                                                            </ul>
                                                        </li>
                                                        <li>Observation<ul>
                                                                <li>Team of experts visits the
                                                                    client’s organization or
                                                                    workplace. They observe the
                                                                    actual working of the
                                                                    existing installed systems.
                                                                    They observe the workflow at
                                                                    client’s end and how
                                                                    execution problems are
                                                                    dealt. The team itself draws
                                                                    some conclusions which aid
                                                                    to form requirements
                                                                    expected from the software.
                                                                </li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Software requirement specification (SRS)<ul>
                                        <li>Introduction<ul>
                                                <li>Software Requirements Specification (SRS) is
                                                    a perfect detailed description of the
                                                    behavior of the system to be developed.</li>
                                                <li>That is SRS document is an agreement between
                                                    the developer and the customer covering the
                                                    functional and non-functional requirements
                                                    of the software to be developed.</li>
                                                <li>SRS is considered as a contract between the
                                                    customer and the developer.</li>
                                                <li>This SRS document will be used for verifying
                                                    whether all the functional and
                                                    non-functional requirements specified in the
                                                    SRS are implemented in the product.</li>
                                                <li>The complete description of the functions to
                                                    be performed by the software specified in
                                                    the SRS will assist the potential users to
                                                    determine if the software specified meets
                                                    their needs or how the software must be
                                                    modified to meet their needs.</li>
                                            </ul>
                                        </li>
                                        <li>Qualities<ul>
                                                <li>Correct</li>
                                                <li>Unambiguous</li>
                                                <li>Complete</li>
                                                <li>Consistent</li>
                                                <li>Ranked for importance and/or stability</li>
                                                <li>Verifiable</li>
                                                <li>Modifiable</li>
                                                <li>Traceable</li>
                                            </ul>
                                        </li>
                                        <li>Template for documentation<ul>
                                                <li>&lt;Project Name&gt; </li>
                                                <li>&lt;Version&gt; </li>
                                                <li>&lt;Date&gt; </li>
                                                <li>&lt;Name&gt; </li>
                                                <li>Lead Software Engineer </li>
                                                <li>1. Introduction<ul>
                                                        <li>1.1 Purpose</li>
                                                        <li>1.2 Intended Audience</li>
                                                        <li>1.3 Intended Use</li>
                                                        <li>1.4 Scope</li>
                                                        <li>1.5 Definitions </li>
                                                    </ul>
                                                </li>
                                                <li>2. Overall Description<ul>
                                                        <li>2.1 User Needs</li>
                                                        <li>2.2 Assumptions and Dependencies
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>3. System Features and Requirements<ul>
                                                        <li>3.1 Functional Requirements</li>
                                                        <li>3.2 External Interface Requirements
                                                        </li>
                                                        <li>3.3 System Features</li>
                                                        <li>3.4 Nonfunctional Requirements</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Developing Use Cases (UML)<ul>
                                        <li>Introduction<ul>
                                                <li>To model a system, the most important aspect
                                                    is to capture the dynamic behavior. Dynamic
                                                    behavior means the behavior of the system
                                                    when it is running/operating. </li>
                                                <li>Only static behavior is not sufficient to
                                                    model a system rather dynamic behavior is
                                                    more important than static behavior. In UML,
                                                    there are five diagrams available to model
                                                    the dynamic nature and use case diagram is
                                                    one of them. Now as we have to discuss that
                                                    the use case diagram is dynamic in nature,
                                                    there should be some internal or external
                                                    factors for making the interaction. </li>
                                                <li>These internal and external agents are known
                                                    as actors. Use case diagrams consists of
                                                    actors, use cases and their relationships.
                                                    The diagram is used to model the
                                                    system/subsystem of an application. A single
                                                    use case diagram captures a particular
                                                    functionality of a system. </li>
                                                <li>Hence to model the entire system, a number
                                                    of use case diagrams are used.</li>
                                            </ul>
                                        </li>
                                        <li>Purpose of Use Case Diagrams<ul>
                                                <li>The purpose of use case diagram is to
                                                    capture the dynamic aspect of a system.
                                                    However, this definition is too generic to
                                                    describe the purpose, as other four diagrams
                                                    (activity, sequence, collaboration, and
                                                    State chart) also have the same purpose. We
                                                    will look into some specific purpose, which
                                                    will distinguish it from other four
                                                    diagrams.</li>
                                                <li>Use case diagrams are used to gather the
                                                    requirements of a system including internal
                                                    and external influences. These requirements
                                                    are mostly design requirements. Hence, when
                                                    a system is analyzed to gather its
                                                    functionalities, use cases are prepared and
                                                    actors are identified.</li>
                                                <li>When the initial task is complete, use case
                                                    diagrams are modelled to present the outside
                                                    view.</li>
                                                <li>In brief, the purposes of use case diagrams
                                                    can be said to be as follows −<ul>
                                                        <li>Used to gather the requirements of a
                                                            system.</li>
                                                        <li>Used to get an outside view of a
                                                            system.</li>
                                                        <li>Identify the external and internal
                                                            factors influencing the system.</li>
                                                        <li>Show the interaction among the
                                                            requirements are actors.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>How to Draw a Use Case Diagram?<ul>
                                                <li>Use case diagrams are considered for high
                                                    level requirement analysis of a system. When
                                                    the requirements of a system are analyzed,
                                                    the functionalities are captured in use
                                                    cases.</li>
                                                <li>We can say that use cases are nothing but
                                                    the system functionalities written in an
                                                    organized manner. The second thing which is
                                                    relevant to use cases are the actors. Actors
                                                    can be defined as something that interacts
                                                    with the system.</li>
                                                <li>Actors can be a human user, some internal
                                                    applications, or may be some external
                                                    applications. When we are planning to draw a
                                                    use case diagram, we should have the
                                                    following items identified.<ul>
                                                        <li>Functionalities to be represented as
                                                            use case</li>
                                                        <li>Actors</li>
                                                        <li>Relationships among the use cases
                                                            and actors.</li>
                                                    </ul>
                                                </li>
                                                <li>Use case diagrams are drawn to capture the
                                                    functional requirements of a system. After
                                                    identifying the above items, we have to use
                                                    the following guidelines to draw an
                                                    efficient use case diagram<ul>
                                                        <li>The name of a use case is very
                                                            important. The name should be chosen
                                                            in such a way so that it can
                                                            identify the functionalities
                                                            performed.</li>
                                                        <li>Give a suitable name for actors.
                                                        </li>
                                                        <li>Show relationships and dependencies
                                                            clearly in the diagram.</li>
                                                        <li>Do not try to include all types of
                                                            relationships, as the main purpose
                                                            of the diagram is to identify the
                                                            requirements.</li>
                                                        <li>Use notes whenever required to
                                                            clarify some important points.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Requirements Modelling<ul>
                                <li>Introduction<ul>
                                        <li>Requirements modeling are essentially the planning
                                            stage of a software system or application. The path
                                            by which such a system or application comes to life
                                            will generally begin with a business or entity
                                            identifying a problem they're facing that requires a
                                            software solution, and they approach a software
                                            development team to come up with this solution.</li>
                                        <li>Requirements modeling is the process of identifying
                                            the requirements this software solution must meet in
                                            order to be successful. Requirements modeling
                                            contain several sub-stages, typically:
                                            scenario-based modeling, flow-oriented modeling,
                                            data modeling, class-based modeling, and behavioral
                                            modeling. Also, as the term ''modeling'' implies,
                                            all of these stages typically result in producing
                                            diagrams that visually convey the concepts they
                                            identify. The most common method for creating these
                                            diagrams is Unified Modeling Language (UML).</li>
                                    </ul>
                                </li>
                                <li>Scenario-based model<ul>
                                        <li>Theory<ul>
                                                <li>While technically there is no right way to
                                                    go through the stages of requirements
                                                    modeling, it typically begins with
                                                    <b>scenario-based modeling</b>, and that's
                                                    because it identifies the possible use cases
                                                    for the system and produces the <b>use case
                                                        diagram</b>, to which all the other
                                                    stages of requirements modeling refer.
                                                </li>
                                                <li>The <b>use case</b> is essentially a primary
                                                    example of how the proposed software
                                                    application or system is meant to be used,
                                                    from the user's point of view. A use case
                                                    diagram will typically show system actors,
                                                    humans or other entities external to the
                                                    system and how they interact with the
                                                    system. Technically, each action such a
                                                    system actor can perform with the
                                                    application or system is considered to be a
                                                    separate use case.</li>
                                            </ul>
                                        </li>
                                        <li>Creating a Preliminary Use Case<ul>
                                                <li>A use case describes a specific usage
                                                    scenario in straightforward language from
                                                    the point of view of a defined actor. But
                                                    how do you know (1) what to write about, (2)
                                                    how much to write about it, (3) how detailed
                                                    to make your description, and (4) how to
                                                    organize the description?</li>
                                                <li>The first two requirements engineering
                                                    tasks—inception and elicitation— provide you
                                                    with the information you’ll need to begin
                                                    writing use cases. Requirements gathering
                                                    meetings, QFD, and other requirements
                                                    engineering mechanisms are used to identify
                                                    stakeholders, define the scope of the
                                                    problem, specify overall operational goals,
                                                    establish priorities, outline all known
                                                    functional requirements, and describe the
                                                    things (objects) that will be manipulated by
                                                    the system. To begin developing a set of use
                                                    cases, list the functions or activities
                                                    performed by a specific actor. You can
                                                    obtain these from a list of required system
                                                    functions, through conversations with
                                                    stakeholders, or by an evaluation of
                                                    activity diagrams developed as part of
                                                    requirements modeling.</li>
                                            </ul>
                                        </li>
                                        <li>Refining a Preliminary Use Case<ul>
                                                <li>A description of alternative interactions is
                                                    essential for a complete understanding of
                                                    the function that is being described by a
                                                    use case. Therefore, each step in the
                                                    primary scenario is evaluated by asking the
                                                    following questions.</li>
                                                <li>Can the actor take some other action at this
                                                    point? </li>
                                                <li>Is it possible that the actor will encounter
                                                    some error condition at this point? If so,
                                                    what it be? </li>
                                                <li>Is it possible that the actor will encounter
                                                    some other behavior at this point.</li>
                                                <li>If so, what it be? Answers to these
                                                    questions result in the creation of a set of
                                                    secondary scenarios that are part of the
                                                    original use case but represent alternative
                                                    behavior. </li>
                                                <li>Can the actor take some other action at this
                                                    point? The answer is “yes.”</li>
                                                <li>Is it possible that the actor will encounter
                                                    some error condition at this point? Any
                                                    number of error conditions can occur as a
                                                    computer-based system operates. </li>
                                                <li>Is it possible that the actor will encounter
                                                    some other behavior at this point? Again the
                                                    answer to the question is “yes.”</li>
                                            </ul>
                                        </li>
                                        <li>Writing a Formal Use Case<ul>
                                                <li>The informal use cases presented are
                                                    sometimes sufficient for requirements
                                                    modeling. However, when a use case involves
                                                    a critical activity or describes a complex
                                                    set of steps with a significant number of
                                                    exceptions, a more formal approach may be
                                                    desirable.</li>
                                            </ul>
                                        </li>
                                        <li>Developing an Activity Diagram<ul>
                                                <li>The UML activity diagram supplements the use
                                                    case by providing a graphical representation
                                                    of the flow of interaction within a specific
                                                    scenario. Similar to the flowchart, an
                                                    activity diagram uses rounded rectangles to
                                                    imply a specific system function, arrows to
                                                    represent flow through the system, decision
                                                    diamonds to depict a branching decision
                                                    (each arrow emanating from the diamond is
                                                    labeled), and solid horizontal lines to
                                                    indicate that parallel activities are
                                                    occurring. </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Class-based model<ul>
                                        <li>Theory<ul>
                                                <li>Class-based modeling represents the objects
                                                    that the system will manipulate, the
                                                    operations (also called methods or services)
                                                    that will be applied to the objects to
                                                    effect the manipulation, relationships (some
                                                    hierarchical) between the objects, and the
                                                    collaborations that occur between the
                                                    classes that are defined. The elements of a
                                                    class-based model include classes and
                                                    objects, attributes, operations,
                                                    class-responsibility-collaborator (CRC)
                                                    models, collaboration diagrams, and
                                                    packages. The sections that follow present a
                                                    series of informal guidelines that will
                                                    assist in their identification and
                                                    representation.</li>
                                            </ul>
                                        </li>
                                        <li>IDENTIFYING ANALYSIS CLASSES<ul>
                                                <li>External entities (e.g., other systems,
                                                    devices, people) that produce or consume
                                                    information to be used by a computer-based
                                                    system.</li>
                                                <li>Things (e.g., reports, displays, letters,
                                                    signals) that are part of the information
                                                    domain for the problem. </li>
                                                <li>Occurrences or events (e.g., a property
                                                    transfer or the completion of a series of
                                                    robot movements) that occur within the
                                                    context of system operation. </li>
                                                <li>Roles (e.g., manager, engineer, salesperson)
                                                    played by people who interact with the
                                                    system. </li>
                                                <li>Organizational units (e.g., division, group
                                                    and team) that is relevant to an
                                                    application. </li>
                                                <li>Places (e.g., manufacturing floor or loading
                                                    dock) that establish the context of the
                                                    problem and the overall function of the
                                                    system. </li>
                                                <li>Structures (e.g., sensors, four-wheeled
                                                    vehicles, or computers) that define a class
                                                    of objects or related classes of objects.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Six selection characteristics that should be used as
                                            you consider each potential class for inclusion in
                                            the analysis model<ul>
                                                <li>1. Retained information. The potential class
                                                    will be useful during analysis only if
                                                    information about it must be remembered so
                                                    that the system can function.</li>
                                                <li>2. Needed services. The potential class must
                                                    have a set of identifiable operations that
                                                    can change the value of its attributes in
                                                    some way.</li>
                                                <li>3. Multiple attributes. During requirement
                                                    analysis, the focus should be on “major”
                                                    information; a class with a single attribute
                                                    may, in fact, be useful during design, but
                                                    is probably better represented as an
                                                    attribute of another class during the
                                                    analysis activity. </li>
                                                <li>4. Common attributes. A set of attributes
                                                    can be defined for the potential class and
                                                    these attributes apply to all instances of
                                                    the class. </li>
                                                <li>5. Common operations. A set of operations
                                                    can be defined for the potential class and
                                                    these operations apply to all instances of
                                                    the class. </li>
                                                <li>6. Essential requirements. External entities
                                                    that appear in the problem space and produce
                                                    or consume information essential to the
                                                    operation of any solution for the system
                                                    will almost always be defined as classes in
                                                    the requirements model.</li>
                                            </ul>
                                        </li>
                                        <li>SPECIFYING ATTRIBUTES<ul>
                                                <li>Attributes describe a class that has been
                                                    selected for inclusion in the analysis
                                                    model. In essence, it is the attributes that
                                                    define the class—that clarify what is meant
                                                    by the class in the context of the problem
                                                    space. For example, if we were to build a
                                                    system that tracks baseball statistics for
                                                    professional baseball players, the
                                                    attributes of the class Player would be
                                                    quite different than the attributes of the
                                                    same class when it is used in the context of
                                                    the professional baseball pension system. In
                                                    the former, attributes such as name,
                                                    position, batting average, fielding
                                                    percentage, years played, and games played
                                                    might be relevant. For the latter, some of
                                                    these attributes would be meaningful, but
                                                    others would be replaced (or augmented) by
                                                    attributes like average salary, credit
                                                    toward full vesting, pension plan options
                                                    chosen, mailing address, and the like.</li>
                                            </ul>
                                        </li>
                                        <li>DEFINING OPERATIONS<ul>
                                                <li>Operations define the behavior of an object.
                                                    Although many different types of operations
                                                    exist, they can generally be divided into
                                                    four broad categories: <ul>
                                                        <li>(1) Operations that manipulate data
                                                            in some way (e.g., adding, deleting,
                                                            reformatting, selecting)</li>
                                                        <li>(2) Operations that perform a
                                                            computation (addition division</li>
                                                        <li>(3) Operations that inquire about
                                                            the state of an object</li>
                                                        <li>(4) Operations that monitor an
                                                            object for the occurrence of a
                                                            controlling event. </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Behavioural model<ul>
                                        <li>The behavioral model indicates how software will
                                            respond to external events or stimuli. To create the
                                            model, you should perform the following steps: <ul>
                                                <li>(1) evaluate all use cases to fully
                                                    understand the sequence of interaction
                                                    within the system, </li>
                                                <li>(2) identify events that drive the
                                                    interaction sequence and understand how
                                                    these events relate to specific objects</li>
                                                <li>(3) create a sequence for each use case</li>
                                                <li>(4) build a state diagram for the system,
                                                    and (5) review the behavioral model to
                                                    verify accuracy and consistency.</li>
                                            </ul>
                                        </li>
                                        <li>State Diagrams for Analysis Classes.<ul>
                                                <li>One component of a behavioral model is a UML
                                                    state diagram 2 that represents active
                                                    states for each class and the events
                                                    (triggers) that cause changes between these
                                                    active states. Figure illustrates a state
                                                    diagram for the ControlPanel object in the
                                                    SafeHome security function. Each arrow shown
                                                    in Figure represents a transition from one
                                                    active state of an object to another. The
                                                    labels shown for each arrow represent the
                                                    event that triggers the transition. Although
                                                    the active state model provides useful
                                                    insight into the “life history” of an
                                                    object, it is possible to specify additional
                                                    information to provide more depth in
                                                    understanding the behavior of an object.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Sequence Diagrams<ul>
                                                <li>The second type of behavioral
                                                    representation, called a sequence diagram in
                                                    UML, indicates how events cause transitions
                                                    from object to object. Once events have been
                                                    identified by examining a use case, the
                                                    modeler creates a sequence diagram—a
                                                    representation of how events cause flow from
                                                    one object to another as a function of time.
                                                    In essence, the sequence diagram is a
                                                    shorthand version of the use case. It
                                                    represents key classes and the events that
                                                    cause behavior to flow from class to class.
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Chapter 3<ul>
                        <li>Project Scheduling <ul>
                                <li>Concept of Project Scheduling<ul>
                                        <li>i. Changing customer requirements that are not
                                            reflected in schedule changes.</li>
                                        <li>ii. An honest underestimate of the amount of effort
                                            and/or the number of resources that will be required
                                            to do the job.</li>
                                        <li>iii. Predictable and/or unpredictable risks that
                                            were not considered when the project commenced.</li>
                                        <li>iv. Technical difficulties that could not have been
                                            foreseen in advance. </li>
                                    </ul>
                                </li>
                                <li>Factors that delay Project Schedule although there are many
                                    reasons why software is delivered late, most can be traced
                                    to one or more of the following root causes:<ul>
                                        <li>i. An unrealistic deadline established by someone
                                            outside the software development group and forced on
                                            managers and practitioners within the group. </li>
                                        <li>ii. Changing customer requirements that are not
                                            reflected in schedule changes. </li>
                                        <li>iii. An honest underestimate of the amount of effort
                                            and/or the number of resources that will be required
                                            to do the job.</li>
                                        <li>iv. Predictable and/or unpredictable risks that were
                                            not considered when the project commenced. </li>
                                        <li>v. Technical difficulties that could not have been
                                            foreseen in advance. </li>
                                        <li>vi. Human difficulties that could not have been
                                            foreseen in advance. </li>
                                        <li>vii. Miscommunication among project staff that
                                            results in delays. </li>
                                        <li>viii. A failure by project management to recognize
                                            that the project is falling behind schedule and a
                                            lack of action to correct the problem. </li>
                                    </ul>
                                </li>
                                <li>Principles of Project Scheduling<ul>
                                        <li>i. Compartmentalization: The project must be
                                            compartmentalized into a number of manageable
                                            activities and tasks. </li>
                                        <li>ii. Interdependency: The interdependency of each
                                            compartmentalized activity or task must be
                                            determined. </li>
                                        <li>iii. Time Allocation: Each task to be scheduled must
                                            be allocated some number of work units (e.g.,
                                            person‐days of effort).</li>
                                        <li>iv. Effort Validation: the project manager must
                                            ensure that no more than the allocated number of
                                            people has been scheduled at any given time.</li>
                                        <li>v. Defined Responsibilities: Every task that is
                                            scheduled should be assigned to a specific team
                                            member</li>
                                        <li>vi. Defined Outcomes: Every task that is scheduled
                                            should have a defined outcome.</li>
                                        <li>vii. Defined Milestones: Every task or group of
                                            tasks should be associated with a project milestone.
                                        </li>
                                        <li>viii. A milestone is accomplished when one or more
                                            work products has been reviewed for quality and has
                                            been approved.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Management Spectrum, 3Ps (people, product and process) <ul>
                                <li>Effective software project management focuses on these items
                                    (in this order) </li>
                                <li>1. The People<ul>
                                        <li>i. Deals with the cultivation of motivated, highly
                                            skilled people</li>
                                        <li>ii. Consists of the stakeholders, the team leaders,
                                            and the software team </li>
                                    </ul>
                                </li>
                                <li>2. The Product<ul>
                                        <li>i. Product objectives and scope should be
                                            established before a project can be planned 3. The
                                            Process</li>
                                        <li>i. The software process provides the framework from
                                            which a comprehensive plan for software development
                                            can be established </li>
                                    </ul>
                                </li>
                                <li>4. The Project<ul>
                                        <li>i. Planning and controlling a software project is
                                            done for one primary reason it is the only known way
                                            to manage complexity</li>
                                        <li>ii. In a 1998 survey, 26% of software projects
                                            failed outright, 46% experienced cost and schedule
                                            overruns</li>
                                    </ul>
                                </li>
                                <li>![](file:///C:/Users/vyd/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)
                                </li>
                            </ul>
                        </li>
                        <li>Process and Project metrics<ul>
                                <li>1. Software process and project metrics are quantitative
                                    measures that enable software engineers to gain insight into
                                    the efficiency of the software process and the projects
                                    conducted using the process framework. </li>
                                <li>2. In software project management, we are primarily
                                    concerned with productivity and quality metrics. </li>
                                <li>3. There are four reasons for measuring software processes,
                                    products, and resources (to characterize, to evaluate, to
                                    predict, and to improve). </li>
                                <li>Process Indicators <ul>
                                        <li>1. Metrics should be collected so that process and
                                            product indicators can be ascertained. </li>
                                        <li>2. Process indicators enable software project
                                            managers to: assess project status, track potential
                                            risks, detect problem area early, adjust workflow or
                                            tasks, and evaluate team ability to control product
                                            quality </li>
                                    </ul>
                                </li>
                                <li>Process Metrics <ul>
                                        <li>1. Private process metrics (e.g., defect rates by
                                            individual or module) are only known to by the
                                            individual or team concerned. </li>
                                        <li>2. Public process metrics enable organizations to
                                            make strategic changes to improve the software
                                            process. </li>
                                        <li>3. Metrics should not be used to evaluate the
                                            performance of individuals.</li>
                                        <li>4. Statistical software process improvement helps
                                            and organization to discover where they are strong
                                            and where they are weak. </li>
                                        <li>5. Provide regular feedback to the individuals and
                                            teams who collect measures and metrics. </li>
                                        <li>6. Don’t use metrics to appraise individuals. </li>
                                        <li>7. Work with practitioners and teams to set clear
                                            goals and metrics that will be used to achieve them.
                                        </li>
                                        <li>8. Never use metrics to threaten individuals or
                                            teams. </li>
                                        <li>9. Metrics data that indicate a problem area should
                                            not be considered “negative.” These data are merely
                                            an indicator for process improvement. </li>
                                        <li>10. Don’t obsess on a single metric to the exclusion
                                            of other important metrics. </li>
                                    </ul>
                                </li>
                                <li>Project Metrics <ul>
                                        <li>1. A software team can use software project metrics
                                            to adapt project workflow and technical activities.
                                        </li>
                                        <li>2. Project metrics are used to avoid development
                                            schedule delays, to mitigate potential risks, and to
                                            assess product quality on an on-going basis.</li>
                                        <li>3. Every project should measure its inputs
                                            (resources), outputs (deliverables), and results
                                            (effectiveness of deliverables). </li>
                                        <li>4. Every project should measure <ul>
                                                <li>Inputs—Measures of the resources (e.g.,
                                                    people, environment) required to do the
                                                    work. </li>
                                                <li>Outputs—Measures of the deliverables or work
                                                    products created during the software
                                                    engineering process. </li>
                                                <li>Results—Measures that indicate the
                                                    effectiveness of the deliverables.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>![](file:///C:/Users/vyd/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)
                                </li>
                            </ul>
                        </li>
                        <li>Software Project Estimation: <ul>
                                <li>Introduction<ul>
                                        <li>Software cost and effort estimation will never be an
                                            exact science. Too many variables—human, technical,
                                            environmental, political—can affect the ultimate
                                            cost of software and effort applied to develop it.
                                            However, software project estimation can be
                                            transformed from a black art to a series of
                                            systematic steps that provide estimates with
                                            acceptable risk. To achieve reliable cost and effort
                                            estimates, a number of options arise:<ul>
                                                <li>1. Delay estimation until late in the
                                                    project (obviously, we can achieve 100
                                                    percent accurate estimates after the project
                                                    is complete!). </li>
                                                <li>2. Base estimates on similar projects that
                                                    have already been completed. </li>
                                                <li>3. Use relatively simple decomposition
                                                    techniques to generate project cost and
                                                    effort estimates. </li>
                                                <li>4. Use one or more empirical models for
                                                    software cost and effort estimation.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>LOC<ul>
                                        <li>Theory<ul>
                                                <li>i. It is defined as the software metric that
                                                    is used to count the number of line of text
                                                    of the source code. </li>
                                                <li>ii. The basis of the Measure LOC is that
                                                    program length can be used as a predictor of
                                                    program characteristics such as effort and
                                                    ease of maintenance.</li>
                                                <li>iii. The LOC measure is used to measure size
                                                    of the software. </li>
                                                <li>iv. The LOC are divide as Physical LOC,
                                                    Logical LOC and Comment Statement.</li>
                                            </ul>
                                        </li>
                                        <li>Advantages <ul>
                                                <li>i. Simple to measure. </li>
                                                <li>ii. Scope for Automation of Counting, as the
                                                    Line of Code is a physical entity; manual
                                                    counting effort can be easily eliminated by
                                                    automating the counting process. </li>
                                                <li>iii. Line of Code serves as an intuitive
                                                    metric for measuring the size of software
                                                    because it can be seen and the effect of it
                                                    can be visualized </li>
                                            </ul>
                                        </li>
                                        <li>Drawbacks <ul>
                                                <li>i. It is defined on code. For example it
                                                    cannot measure the size of specification.
                                                </li>
                                                <li>ii. It characterize only one specific view
                                                    of size, namely length, it takes no account
                                                    of functionality or complexity. </li>
                                                <li>iii. Bad software design may cause excessive
                                                    line of code.</li>
                                                <li>iv. It is language dependent. </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>FP<ul>
                                        <li>Theory<ul>
                                                <li>Allan J. Albrecht initially developed
                                                    function Point Analysis in 1979 at IBM and
                                                    it has been further modified by the
                                                    International Function Point Users Group
                                                    (IFPUG). FPA is used to make estimate of the
                                                    software project, including its testing in
                                                    terms of functionality or function size of
                                                    the software product. However, functional
                                                    point analysis may be used for the test
                                                    estimation of the product. The functional
                                                    size of the product is measured in terms of
                                                    the function point, which is a standard of
                                                    measurement to measure the software
                                                    application.</li>
                                            </ul>
                                        </li>
                                        <li>Objectives of FPA<ul>
                                                <li>The basic and primary purpose of the
                                                    functional point analysis is to measure and
                                                    provide the software application functional
                                                    size to the client, customer, and the
                                                    stakeholder on their request. Further, it is
                                                    used to measure the software project
                                                    development along with its maintenance,
                                                    consistently throughout the project
                                                    irrespective of the tools and the
                                                    technologies.</li>
                                            </ul>
                                        </li>
                                        <li>Following are the points regarding FPs<ul>
                                                <li>1. FPs of an application is found out by
                                                    counting the number and types of functions
                                                    used in the applications. Various functions
                                                    used in an application can be put under five
                                                    types, as shown in Table:</li>
                                                <li>2. FP characterizes the complexity of the
                                                    software system and hence can be used to
                                                    depict the project time and the manpower
                                                    requirement.</li>
                                                <li>3. The effort required to develop the
                                                    project depends on what the software does.
                                                </li>
                                                <li>4. FP is programming language independent.
                                                </li>
                                                <li>5. FP method is used for data processing
                                                    systems, business systems like information
                                                    systems.</li>
                                                <li>6. The five parameters mentioned above are
                                                    also known as information domain
                                                    characteristics.<ul>
                                                        <li>Number of User Inputs. Each user
                                                            input that provides distinct
                                                            application oriented data to the
                                                            software is counted. Inputs should
                                                            be distinguished from inquiries,
                                                            which are counted separately.</li>
                                                        <li>Number of User Outputs. Each user
                                                            output that provides application
                                                            oriented information to the user is
                                                            counted. In this context output
                                                            refers to reports, screens, error
                                                            messages, etc. Individual data items
                                                            within a report are not counted
                                                            separately.</li>
                                                        <li>Number of User Inquiries. An inquiry
                                                            is defined as an on-line input that
                                                            results in the generation of some
                                                            immediate software response in the
                                                            form of an on-line output. Each
                                                            distinct inquiry is counted.</li>
                                                        <li>Number of Files. Each logical master
                                                            file (i.e., a logical grouping of
                                                            data that may be one part of a large
                                                            database or a separate file) is
                                                            counted.</li>
                                                        <li>Number of External Interfaces. All
                                                            machine readable interfaces (e.g.,
                                                            data files on storage media) that
                                                            are used to transmit information to
                                                            another system are counted.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>To compute functional point following formulae are
                                            used</li>
                                        <li>FP = Count Total * [0.65 + 0.01 * Σ (Fi)]</li>
                                        <li>Where FP= Functional Point</li>
                                        <li>Count Total = Total of all the entries obtained from
                                            the table 2.</li>
                                        <li>Fi = i varies from 1 to 14 depending on the answers
                                            to the questions below.<ul>
                                                <li>1. Does the system require reliable backup
                                                    and recovery?</li>
                                                <li>2. Are data communications required?</li>
                                                <li>3. Are there distributed processing
                                                    functions?</li>
                                                <li>4. Is performance critical?</li>
                                                <li>5. Will the system run in an existing,
                                                    heavily utilized operational environment?
                                                </li>
                                                <li>6. Does the system require on-line data
                                                    entry?</li>
                                                <li>7. Does the on-line data entry require the
                                                    input transaction to be built over multiple
                                                    screens or operations?</li>
                                                <li>8. Are the master files updated on-line?
                                                </li>
                                                <li>9. Are the inputs, outputs, files, or
                                                    inquiries complex?</li>
                                                <li>10. Is the internal processing complex?</li>
                                                <li>11. Is the code designed to be reusable?
                                                </li>
                                                <li>12. Are conversion and installation included
                                                    in the design?</li>
                                                <li>13. Is the system designed for multiple
                                                    installations in different organizations?
                                                </li>
                                                <li>14. Is the application designed to
                                                    facilitate change and ease of use by the
                                                    user?</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>FP vs LOC<ul>
                                        <li>1. FP is specification based. 1. LOC is an analogy
                                            based. </li>
                                        <li>2. FP is language independent. 2. LOC is language
                                            dependent. </li>
                                        <li>3. FP is user-oriented. 3. LOC is design-oriented.
                                        </li>
                                        <li>4. It is extendible to LOC. 4. It is convertible to
                                            FP (backfiring) </li>
                                    </ul>
                                </li>
                                <li>Empirical Estimation Models - COCOMO II Model<ul>
                                        <li>Boehm proposed COCOMO (Constructive Cost Estimation
                                            Model) in 1981.COCOMO is one of the most generally
                                            used software estimation models in the world. COCOMO
                                            predicts the efforts and schedule of a software
                                            product based on the size of the software.</li>
                                        <li>The necessary steps in this model are:<ul>
                                                <li>Get an initial estimate of the development
                                                    effort from evaluation of thousands of
                                                    delivered lines of source code (KDLOC).
                                                </li>
                                                <li>Determine a set of 15 multiplying factors
                                                    from various attributes of the project.
                                                </li>
                                                <li>Calculate the effort estimate by multiplying
                                                    the initial estimate with all the
                                                    multiplying factors i.e., multiply the
                                                    values in step1 and step2.</li>
                                            </ul>
                                        </li>
                                        <li>The initial estimate (also called nominal estimate)
                                            is determined by an equation of the form used in the
                                            static single variable models, using KDLOC as the
                                            measure of the size. To determine the initial effort
                                            Ei&nbsp;in person-months the equation used is of the
                                            type is shown below</li>
                                        <li>Ei=a*(KDLOC)b</li>
                                        <li>The value of the constant a and b are depends on the
                                            project type.</li>
                                        <li>In COCOMO, projects are categorized into three
                                            types:<ul>
                                                <li>Organic<ul>
                                                        <li>A development project can be treated
                                                            of the organic type, if the project
                                                            deals with developing a
                                                            well-understood application program,
                                                            the size of the development team is
                                                            reasonably small, and the team
                                                            members are experienced in
                                                            developing similar methods of
                                                            projects.&nbsp;Examples of this type
                                                            of projects are simple business
                                                            systems, simple inventory management
                                                            systems, and data processing
                                                            systems.</li>
                                                    </ul>
                                                </li>
                                                <li>Semidetached<ul>
                                                        <li>A development project can be treated
                                                            with semidetached type if the
                                                            development consists of a mixture of
                                                            experienced and inexperienced staff.
                                                            Team members may have finite
                                                            experience in related systems but
                                                            may be unfamiliar with some aspects
                                                            of the order being
                                                            developed.&nbsp;Example of
                                                            Semidetached system includes
                                                            developing a new operating system
                                                            (OS), a Database Management System
                                                            (DBMS), and complex inventory
                                                            management system.</li>
                                                    </ul>
                                                </li>
                                                <li>Embedded<ul>
                                                        <li>A development project is treated to
                                                            be of an embedded type, if the
                                                            software being developed is strongly
                                                            coupled to complex hardware, or if
                                                            the stringent regulations on the
                                                            operational method exist.&nbsp;For
                                                            Example:&nbsp;ATM, Air Traffic
                                                            control.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Specialized Estimation Techniques<ul>
                                        <li>Theory<ul>
                                                <li>However, when a software team encounters an
                                                    extremely short project duration (weeks
                                                    rather than months) that is likely to have a
                                                    continuing stream of changes, project
                                                    planning in general, and estimation in
                                                    particular should be abbreviated. </li>
                                            </ul>
                                        </li>
                                        <li>Estimation for Agile Development<ul>
                                                <li>Because the requirements for an agile
                                                    project are deﬁned by a set of user
                                                    scenarios (e.g., “stories” in Extreme
                                                    Programming), it is possible to develop an
                                                    estimation approach that is informal,
                                                    reasonably disciplined, and meaningful
                                                    within the context of project planning for
                                                    each software increment. Estimation for
                                                    agile projects uses a decomposition approach
                                                    that encompasses the following steps:<ul>
                                                        <li>1. Each user scenario (the
                                                            equivalent of a mini use case
                                                            created at the very start of a
                                                            project by end users or other
                                                            stakeholders) is considered
                                                            separately for estimation purposes.
                                                        </li>
                                                        <li>2. The scenario is decomposed into
                                                            the set of software engineering
                                                            tasks that will be required to
                                                            develop it. </li>
                                                        <li>3a. Each task is estimated
                                                            separately. Note: Estimation can be
                                                            based on historical data, an
                                                            empirical model, or “experience.”
                                                        </li>
                                                        <li>3b. Alternatively, the “volume” of
                                                            the scenario can be estimated in
                                                            LOC, FP, or some other
                                                            volume-oriented measure (e.g., use
                                                            case count). </li>
                                                        <li>4a. Estimates for each task are
                                                            summed to create an estimate for the
                                                            scenario. </li>
                                                        <li>4b. Alternatively, the volume
                                                            estimate for the scenario is
                                                            translated into effort using
                                                            historical data. </li>
                                                        <li>5. The effort estimates for all
                                                            scenarios that are to be implemented
                                                            for a given software increment are
                                                            summed to develop the effort
                                                            estimate for the increment. </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Estimation for Web App Projects <ul>
                                                <li>Web App projects often adopt the agile
                                                    process model. A modiﬁed function point
                                                    measure, can be used to develop an estimate
                                                    for the Web App. Roetzheim suggests the
                                                    following approach when adapting function
                                                    points for Web App estimation:<ul>
                                                        <li>Inputs are each input screen or form
                                                            (for example, CGI or Java), each
                                                            maintenance screen, and if you use a
                                                            tab notebook metaphor anywhere, each
                                                            tab. </li>
                                                        <li>Queries are each externally
                                                            published or use a message-oriented
                                                            interface. A typical example is DCOM
                                                            or COM external references.</li>
                                                        <li>Outputs are each static Web page,
                                                            each dynamic Web page script (for
                                                            example, ASP, ISAPI, or other DHTML
                                                            script), and each report (whether
                                                            Web based or administrative in
                                                            nature). </li>
                                                        <li>Tables are each logical table in the
                                                            database plus, if you are using XML
                                                            to store data in a ﬁle, each XML
                                                            object (or collection of XML
                                                            attributes). </li>
                                                        <li>Interfaces retain their deﬁnition as
                                                            logical ﬁles (for example, unique
                                                            record formats) into our
                                                            out-of-the-system boundaries. </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Project scheduling<ul>
                                <li>Introduction<ul>
                                        <li>Software project scheduling is an activity that
                                            distributes estimated effort across the planned
                                            project duration by allocating the effort to speciﬁc
                                            software engineering tasks. It is important to note,
                                            however, that the schedule evolves over time. During
                                            early stages of project planning, a macroscopic
                                            schedule is developed. This types of schedule
                                            identiﬁes all major process framework activities and
                                            the product functions to which they are applied. As
                                            the project gets under way, each entry on the
                                            macroscopic schedule is reﬁned into a detailed
                                            schedule. Here, speciﬁc software actions and tasks
                                            (required to accomplish an activity) are identiﬁed
                                            and scheduled. </li>
                                        <li>Scheduling for software engineering projects can be
                                            viewed from two rather different perspectives. In
                                            the ﬁrst, an end date for release of a
                                            computer-based system has already (and irrevocably)
                                            been established. The software organization is
                                            constrained to distribute effort within the
                                            prescribed time frame. The second view of software
                                            scheduling assumes that rough chronological bounds
                                            have been discussed but that the end date is set by
                                            the software engineering organization. Effort is
                                            distributed to make best use of resources, and an
                                            end date is deﬁned after careful analysis of the
                                            software. Unfortunately, the ﬁrst situation is
                                            encountered far more frequently than the second.
                                        </li>
                                    </ul>
                                </li>
                                <li>Defining a Task Set for the Software Project<ul>
                                        <li>A task set is a collection of software engineering
                                            work tasks, milestones, and deliverables that must
                                            be accomplished to complete a particular project.
                                            The task set to be chosen must provide enough
                                            discipline to achieve high software quality. But, at
                                            the same time, it must not burden the project team
                                            with unnecessary work.</li>
                                        <li>Task sets are designed to accommodate different
                                            types of projects and different degrees of rigor.
                                            Although it is difficult to develop a comprehensive
                                            taxonomy of software project types, most software
                                            organizations encounter the following projects:<ul>
                                                <li>Concept development projects that are
                                                    initiated to explore some new business
                                                    concept or application of some new
                                                    technology.</li>
                                                <li>New application development projects that
                                                    are undertaken as a consequence of a
                                                    specific customer request.</li>
                                                <li>Application enhancement projects that occur
                                                    when existing software undergoes major
                                                    modifications to function, performance, or
                                                    interfaces that are observable by the
                                                    end-user.</li>
                                                <li>Application maintenance projects that
                                                    correct, adapt, or extend existing software
                                                    in ways that may not be immediately obvious
                                                    to the end-user.</li>
                                                <li>Reengineering projects that are undertaken
                                                    with the intent of rebuilding an existing
                                                    (legacy) system in whole or in part.</li>
                                            </ul>
                                        </li>
                                        <li>Even within a single project type, many factors
                                            influence the task set to be chosen. When taken in
                                            combination, these factors provide an indication of
                                            the degree of rigor with which the software process
                                            should be applied.</li>
                                    </ul>
                                </li>
                                <li>Timeline charts<ul>
                                        <li>When creating a software project schedule, you begin
                                            with a set of tasks (the work breakdown structure).
                                            If automated tools are used, the work breakdown is
                                            input as a task network or task outline. Effort,
                                            duration, and start date are then input for each
                                            task. In addition, tasks may be assigned to speciﬁc
                                            individuals. </li>
                                        <li>As a consequence of this input, a time-line chart,
                                            also called a Gantt chart, </li>
                                        <li>is generated. A time-line chart can be developed for
                                            the entire project. Alternatively, separate charts
                                            can be developed for each project function or for
                                            each individual working on the project. </li>
                                        <li>Illustrates the format of a time-line chart. It
                                            depicts a part of a software project schedule that
                                            emphasizes the concept scoping task for a
                                            word-processing (WP) software product. All project
                                            tasks (for concept scoping) are listed in the
                                            left-hand column. The horizontal bars indicate the
                                            duration of each task. When multiple bars occur at
                                            the same time on the calendar, task concurrency is
                                            implied. The diamonds indicate milestones. </li>
                                        <li>Once the information necessary for the generation of
                                            a time-line chart has been input, the majority of
                                            software project scheduling tools produce project
                                        </li>
                                    </ul>
                                </li>
                                <li>Tracking the Schedule<ul>
                                        <li>If it has been properly developed, the project
                                            schedule becomes a road map that deﬁnes the tasks
                                            and milestones to be tracked and controlled as the
                                            project proceeds. Tracking can be accomplished in a
                                            number of different ways:<ul>
                                                <li>Conducting periodic project status meetings
                                                    in which each team member reports progress
                                                    and problems. </li>
                                                <li>Evaluating the results of all reviews
                                                    conducted throughout the software
                                                    engineering process. </li>
                                                <li>Determining whether formal project
                                                    milestones have been accomplished by the
                                                    scheduled date. </li>
                                                <li>Comparing the actual start date to the
                                                    planned start date for each project task
                                                    listed in the resource table. </li>
                                                <li>Meeting informally with practitioners to
                                                    obtain their subjective assessment of
                                                    progress to date and problems on the
                                                    horizon. </li>
                                                <li>Using earned value analysis to assess
                                                    progress quantitatively.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Earned Value Analysis<ul>
                                        <li>Earned Value Analysis (EVA) is an industry standard
                                            method of measuring a project's progress at any
                                            given point in time, forecasting its completion date
                                            and final cost, and analyzing variances in the
                                            schedule and budget as the project proceeds. It
                                            compares the planned amount of work with what has
                                            actually been completed, to determine if the cost,
                                            schedule, and work accomplished are progressing in
                                            accordance with the plan. As work is completed, it
                                            is considered "earned".</li>
                                        <li>"Agencies must use a performance-based acquisition
                                            management system, based on ANSI/EIA Standard 748,
                                            to measure achievement of the cost, schedule and
                                            performance goals."</li>
                                        <li>EVA is a snapshot in time, which can be used as a
                                            management tool as an early warning system to detect
                                            deficient or endangered progress. It ensures a clear
                                            definition of work prior to beginning that work. It
                                            provides an objective measure of accomplishments,
                                            and an early and accurate picture of the contract
                                            status. It can be as simple as tracking an elemental
                                            cost estimate breakdown as a design progresses from
                                            concept through to 100% construction documents, or
                                            it can be calculated and tracked using a series of
                                            mathematical formulae (see below). In either case,
                                            it provides a basis for course correction. It
                                            answers two key questions:<ul>
                                                <li>At the end of the project, is it likely that
                                                    the cost will be less than, equal to or
                                                    greater than the original estimate? </li>
                                                <li>Will the project likely be completed on
                                                    time?</li>
                                            </ul>
                                        </li>
                                        <li>Work Breakdown Structure (WBS)<ul>
                                                <li>EVA works most effectively when it is
                                                    compartmentalized, i.e. when the project is
                                                    broken down into an organized Work Breakdown
                                                    Structure, or WBS. The WBS is used as the
                                                    basic building block for the planning of the
                                                    project. It is a product-oriented division
                                                    of project tasks that ensures the entire
                                                    Scope of Work is captured and allows for the
                                                    integration of technical, schedule, and cost
                                                    information. It breaks down all the work
                                                    scope into appropriate elements for
                                                    planning, budgeting, scheduling, cost
                                                    accounting, work authorization, progress
                                                    measuring, and management control. The two
                                                    most common WBS systems are the Construction
                                                    Specifications Institute (CSI) format, and
                                                    the Uniform at. Often at the preliminary
                                                    stages of design the Uniform at lends a
                                                    better understanding of the cost centers,
                                                    and at final bid level of documents often
                                                    the CSI format is used. The indirect costs
                                                    of design, oversight, and management must be
                                                    included in the WBS to reflect the full
                                                    budget.</li>
                                            </ul>
                                        </li>
                                        <li>Calculating Earned Value<ul>
                                                <li>Earned Value Management measures progress
                                                    against a baseline. It involves calculating
                                                    three key values for each activity in the
                                                    WBS:<ul>
                                                        <li>The Planned Value (PV), (formerly
                                                            known as the&nbsp;budgeted cost of
                                                            work
                                                            scheduled&nbsp;or&nbsp;BCWS)—that
                                                            portion of the approved cost
                                                            estimate planned to be spent on the
                                                            given activity during a given
                                                            period.</li>
                                                        <li>The Actual Cost (AC), (formerly
                                                            known as the&nbsp;actual cost of
                                                            work
                                                            performed&nbsp;or&nbsp;ACWP)—the
                                                            total of the costs incurred in
                                                            accomplishing work on the activity
                                                            in a given period. This Actual Cost
                                                            must correspond to whatever was
                                                            budgeted for the Planned Value and
                                                            the Earned Value (e.g. all labor,
                                                            material, equipment, and indirect
                                                            costs).</li>
                                                        <li>The Earned Value (EV), (formerly
                                                            known as the&nbsp;budget cost of
                                                            work
                                                            performed&nbsp;or&nbsp;BCWP)—the
                                                            value of the work actually
                                                            completed.</li>
                                                    </ul>
                                                </li>
                                                <li>These three values are combined to
                                                    determine&nbsp;at that point in
                                                    time&nbsp;whether or not work is being
                                                    accomplished as planned. The most commonly
                                                    used measures are the cost variance:</li>
                                                <li>Cost Variance (CV) = EV - AC</li>
                                                <li>and the schedule variance:</li>
                                                <li>Schedule Variance (SV) = EV - PV</li>
                                                <li>These two values can be converted to
                                                    efficiency indicators to reflect the cost
                                                    and schedule performance of the project. The
                                                    most commonly used cost-efficiency indicator
                                                    is the cost performance index (CPI). It is
                                                    calculated thus:</li>
                                                <li>CPI = EV / AC</li>
                                                <li>The sum of all individual EV budgets divided
                                                    by the sum of all individual AC's is known
                                                    as the cumulative CPI, and is generally used
                                                    to forecast the cost to complete a project.
                                                </li>
                                                <li>The schedule performance index (SPI),
                                                    calculated thus:</li>
                                                <li>SPI = EV / PV</li>
                                                <li>is often used with the CPI to forecast
                                                    overall project completion estimates.</li>
                                                <li>A negative schedule variance (SV) calculated
                                                    at a given point in time means the project
                                                    is behind schedule, while a negative cost
                                                    variance (CV) means the project is over
                                                    budget.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Chapter 4<ul>
                        <li>Introduction<ul>
                                <li>Software Design<ul>
                                        <li>Software design is a mechanism to transform user
                                            requirements into some suitable form, which helps
                                            the programmer in software coding and
                                            implementation. It deals with representing the
                                            client's requirement, as described in SRS (Software
                                            Requirement Specification) document, into a form,
                                            i.e., easily implementable using programming
                                            language.</li>
                                        <li>The software design phase is the first step
                                            in&nbsp;SDLC (Software Design Life Cycle), which
                                            moves the concentration from the problem domain to
                                            the solution domain. In software design, we consider
                                            the system to be a set of components or modules with
                                            clearly defined behaviors &amp; boundaries.</li>
                                    </ul>
                                </li>
                                <li>Objectives of Software Design<ul>
                                        <li><b>Correctness: </b>Software design should be
                                            correct as per requirement. </li>
                                        <li><b>Completeness: </b>The design should have all
                                            components like data structures, modules, and
                                            external interfaces, etc. </li>
                                        <li><b>Efficiency: </b>Resources should be used
                                            efficiently by the program. </li>
                                        <li><b>Flexibility: </b>Able to modify on changing
                                            needs. </li>
                                        <li><b>Consistency: </b>There should not be any
                                            inconsistency in the design. </li>
                                        <li><b>Maintainability:</b> The design should be so
                                            simple so that it can be easily maintainable by
                                            other designers.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Design Principles<ul>
                                <li>i. <b>The design process should not suffer from “tunnel
                                        vision.” </b>A good designer should consider alternative
                                    approaches, judging each based on the requirements of the
                                    problem, the resources available to do the job. </li>
                                <li>ii. <b>The design should be traceable to the analysis
                                        model</b>. Because a single element of the design model
                                    often traces to multiple requirements, it is necessary to
                                    have a means for tracking how requirements have been
                                    satisfied by the design model. </li>
                                <li>iii. <b>The design should not reinvent the wheel</b>.
                                    Systems are constructed using a set of design patterns, many
                                    of which have likely been encountered before. These patterns
                                    should always be chosen as an alternative to reinvention.
                                    Time is short and resources are limited! Design time should
                                    be invested in representing truly new ideas and integrating
                                    those patterns that already exist. </li>
                                <li>iv. <b>The design should “minimize the intellectual
                                        distance” </b>between the software and the problem as it
                                    exists in the real world. That is, the structure of the
                                    software design should (whenever possible) mimic the
                                    structure of the problem domain. </li>
                                <li>v. <b>The design should exhibit uniformity and
                                        integration</b>. A design is uniform if it appears that
                                    one person developed the entire thing. Rules of style and
                                    format should be defined for a design team before design
                                    work begins. A design is integrated if care is taken in
                                    defining interfaces between design components. </li>
                                <li>vi. <b>The design should be structured to accommodate
                                        change</b>. The design concepts discussed in the next
                                    section enable a design to achieve this principle. </li>
                                <li>vii. <b>The design should be structured to degrade gently,
                                        even when aberrant data, events, or operating conditions
                                        are encountered</b>. Well-designed software should never
                                    “bomb.” It should be designed to accommodate unusual
                                    circumstances, and if it must terminate processing, so in a
                                    graceful manner. </li>
                                <li>viii. <b>Design is not coding, coding is not design.
                                    </b>Even when detailed procedural designs are created for
                                    program components, the level of abstraction of the design
                                    model is higher than source code. The only design decisions
                                    made at the coding level address the small implementation
                                    details that enable the procedural design to be coded. </li>
                                <li>ix. <b>The design should be assessed for quality as it is
                                        being created, not after the fact. </b>A variety of
                                    design concepts and design measures are available to assist
                                    the designer in assessing quality. </li>
                                <li>x. <b>The design should be reviewed to minimize conceptual
                                        (semantic) errors. </b>There is sometimes a tendency to
                                    focus on minutiae when the design is reviewed, missing the
                                    forest for the trees. A design team should ensure that major
                                    conceptual elements of the design (omissions, ambiguity, and
                                    inconsistency) have been addressed before worrying about the
                                    syntax of the design model. </li>
                            </ul>
                        </li>
                        <li>Design Concepts<ul>
                                <li><b>1. Abstraction </b>
                                    <ul>
                                        <li>i. The abstraction principle is used to reduce
                                            complexity and allow efficient design and
                                            implementation of complex software systems. </li>
                                        <li>ii. Many levels of abstraction are integrated
                                            depending on the software system. </li>
                                        <li>iii. At the highest level of abstraction, a solution
                                            is stated in broad terms using the language of the
                                            problem environment. </li>
                                        <li>iv. At lower levels of abstraction, a more
                                            procedural orientation is taken. Problem-oriented
                                            terminology is coupled with implementation-oriented
                                            terminology in an effort to state a solution. </li>
                                        <li>v. At the lowest level of abstraction, the solution
                                            is stated in a manner that can be directly
                                            implemented. </li>
                                        <li>vi. Abstraction is done using data abstraction,
                                            procedural abstraction and control abstraction.
                                        </li>
                                    </ul>
                                </li>
                                <li><b>2. Refinement </b>
                                    <ul>
                                        <li>i. The Refinement phase proceeds with greater focus
                                            on task coherence, using key path (walkthrough) and
                                            validation scenarios focused on story-boarding paths
                                            through the interface in high detail. </li>
                                        <li>ii. The culmination of the Refinement phase is the
                                            detailed documentation of the design, a form and
                                            behavior specification, delivered in either paper or
                                            interactive media as context dictates. </li>
                                        <li>iii. A program is developed by successively refining
                                            levels of procedural detail. </li>
                                        <li>iv. A hierarchy is developed by decomposing a
                                            macroscopic statement of function (a procedural
                                            abstraction) in a stepwise fashion until programming
                                            language statements are reached. </li>
                                        <li>v. Refinement helps the designer to reveal low-level
                                            details as design progresses. </li>
                                    </ul>
                                </li>
                                <li><b>3. Modularity </b>
                                    <ul>
                                        <li>i. Modularity refers to the extent to which a
                                            software/Web application may be divided into smaller
                                            modules. Software modularity indicates that the
                                            number of application modules are capable of serving
                                            a specified business domain. </li>
                                        <li>ii. Modularity is successful because developers use
                                            prewritten code, which saves resources. Overall,
                                            modularity provides greater software development
                                            manageability. </li>
                                        <li>The various methods used to define modularity of a
                                            system are: <ul>
                                                <li>i. <b>Modular Decomposability</b>. If a
                                                    design method provides a systematic
                                                    mechanism for decomposing the problem into
                                                    sub problems, it will reduce the complexity
                                                    of the overall problem, thereby achieving an
                                                    effective modular solution. </li>
                                                <li>ii. <b>Modular Composability</b>. If a
                                                    design method enables existing (reusable)
                                                    design components to be assembled into a new
                                                    system, it will yield a modular solution
                                                    that does not reinvent the wheel. </li>
                                                <li>iii. <b>Modular Understandability</b>. If a
                                                    module can be understood as a standalone
                                                    unit (without reference to other modules),
                                                    it will be easier to build and easier to
                                                    change. </li>
                                                <li>iv. <b>Modular Continuity</b>. If small
                                                    changes to the system requirements result in
                                                    changes to individual modules, rather than
                                                    system wide changes, the impact of
                                                    change-induced side effects will be
                                                    minimized. </li>
                                                <li>v. <b>Modular Protection</b>. If an aberrant
                                                    condition occurs within a module and its
                                                    effects are constrained within that module,
                                                    the impact of error-induced side effects
                                                    will be minimized. </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li><b>4. Architecture- design a structure of something </b>
                                    <ul>
                                        <li>Architecture simply means a technique to design a
                                            structure of something. Architecture in designing
                                            software is a concept that focuses on various
                                            elements and the data of the structure. These
                                            components interact with each other and use the data
                                            of the structure in architecture.</li>
                                    </ul>
                                </li>
                                <li><b>5. Pattern- a repeated form</b>
                                    <ul>
                                        <li>The pattern simply means a repeated form or design
                                            in which the same shape is repeated several times to
                                            form a pattern. The pattern in the design process
                                            means the repetition of a solution to a common
                                            recurring problem within a certain context.</li>
                                    </ul>
                                </li>
                                <li><b>6. Information Hiding- hide the information</b>
                                    <ul>
                                        <li>Information hiding simply means to hide the
                                            information so that it cannot be accessed by an
                                            unwanted party. In software design, information
                                            hiding is achieved by designing the modules in a
                                            manner that the information gathered or contained in
                                            one module is hidden and it can’t be accessed by any
                                            other modules.</li>
                                    </ul>
                                </li>
                                <li><b>7. Refactoring- reconstruct something </b>
                                    <ul>
                                        <li>Refactoring simply means to reconstruct something in
                                            such a way that it does not affect the behavior or
                                            any other features. Refactoring in software design
                                            means to reconstruct the design to reduce complexity
                                            and simplify it without affecting the behavior or
                                            its functions. Fowler has defined refactoring as
                                            “the process of changing a software system in a way
                                            that it won’t affect the behavior of the design and
                                            improves the internal structure”.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Effective Modular Design<ul>
                                <li>Introduction<ul>
                                        <li>Effective Modular Design<ul>
                                                <li>All the fundamental design concepts
                                                    described in the preceding section serve to
                                                    precipitate modular designs.</li>
                                                <li>In fact, modularity has become an accepted
                                                    approach in all engineering disciplines.
                                                </li>
                                                <li>A modular design reduces complexity
                                                    facilitates change (a critical aspect of
                                                    software maintainability), and results in
                                                    easier implementation by encouraging
                                                    parallel development of different parts of a
                                                    system.</li>
                                            </ul>
                                        </li>
                                        <li>Functional Independence<ul>
                                                <li>The concept of functional independence is a
                                                    direct outgrowth of modularity and the
                                                    concepts of abstraction and information
                                                    hiding.</li>
                                                <li>Functional independence is achieved by
                                                    developing modules with "singleminded"
                                                    function and an "aversion" to excessive
                                                    interaction with other modules.</li>
                                                <li>Stated another way, we want to design
                                                    software so that each module addresses a
                                                    specific sub function of requirements and
                                                    has a simple interface when viewed from
                                                    other parts of the program structure. It is
                                                    fair to ask why independence is important.
                                                </li>
                                                <li>Software with effective modularity, that is,
                                                    independent modules, is easier to develop
                                                    because function may be compartmentalized
                                                    and interfaces are simplified (consider the
                                                    ramifications when development is conducted
                                                    by a team).</li>
                                                <li>Independent modules are easier to maintain
                                                    (and test) because secondary effects caused
                                                    by design or code modification are limited,
                                                    error propagation is reduced, and reusable
                                                    modules are possible.</li>
                                                <li>To summarize, functional independence is a
                                                    key to good design, and design is the key to
                                                    software quality.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Cohesion<ul>
                                        <li>Cohesion is a measure of the degree to which the
                                            elements of the module are functionally related. It
                                            is the degree to which all elements directed towards
                                            performing a single task are contained in the
                                            component. Basically, cohesion is the internal glue
                                            that keeps the module together. A good software
                                            design will have high cohesion.</li>
                                        <li>Types of Cohesion:<ul>
                                                <li>Functional Cohesion:&nbsp;<ul>
                                                        <li>Every essential element for a single
                                                            computation is contained in the
                                                            component. A functional cohesion
                                                            performs the task and functions. It
                                                            is an ideal situation.</li>
                                                    </ul>
                                                </li>
                                                <li>Sequential Cohesion:&nbsp;<ul>
                                                        <li>An element outputs some data that
                                                            becomes the input for other element,
                                                            i.e., data flow between the parts.
                                                            It occurs naturally in functional
                                                            programming languages.</li>
                                                    </ul>
                                                </li>
                                                <li>Communicational Cohesion:&nbsp;<ul>
                                                        <li>Two elements operate on the same
                                                            input data or contribute towards the
                                                            same output data. Example- update
                                                            record into the database and send it
                                                            to the printer.</li>
                                                    </ul>
                                                </li>
                                                <li>Procedural Cohesion:&nbsp;<ul>
                                                        <li>Elements of procedural cohesion
                                                            ensure the order of execution.
                                                            Actions are still weakly connected
                                                            and unlikely to be reusable. Ex-
                                                            calculate student GPA, print student
                                                            record, calculate cumulative GPA,
                                                            print cumulative GPA.</li>
                                                    </ul>
                                                </li>
                                                <li>Temporal Cohesion:&nbsp;<ul>
                                                        <li>The elements are related by their
                                                            timing involved. A module connected
                                                            with temporal cohesion all the tasks
                                                            must be executed in the same
                                                            time-span. This cohesion contains
                                                            the code for initializing all the
                                                            parts of the system. Lots of
                                                            different activities occur, all at
                                                            init time.</li>
                                                    </ul>
                                                </li>
                                                <li>Logical Cohesion:&nbsp;<ul>
                                                        <li>The elements are logically related
                                                            and not functionally. Ex- A
                                                            component reads inputs from tape,
                                                            disk, and network. All the code for
                                                            these functions is in the same
                                                            component. Operations are related,
                                                            but the functions are significantly
                                                            different.</li>
                                                    </ul>
                                                </li>
                                                <li>Coincidental Cohesion:&nbsp;<ul>
                                                        <li>The elements are not related
                                                            (unrelated). The elements have no
                                                            conceptual relationship other than
                                                            location in source code. It is
                                                            accidental and the worst form of
                                                            cohesion. Ex- print next line and
                                                            reverse the characters of a string
                                                            in a single component.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Coupling <ul>
                                        <li>In software engineering, the coupling can be defined
                                            as the measurement to which the components of the
                                            software depend upon each other. Normally, the
                                            coupling is contrasted with the cohesion. If the
                                            system has a low coupling, it is a sign of a
                                            well-structured computer system and a great design.
                                        </li>
                                        <li>A low coupling combined with the high cohesion, it
                                            supports the mission of high readability and
                                            maintainability. The coupling term generally occurs
                                            together with the cohesion very frequently. The
                                            coupling is an indication of the strength of the
                                            interconnection between all the components in a
                                            system. The highly coupled systems have
                                            interconnections, in which the program units depend
                                            upon each other, whereas in the loosely coupled
                                            systems made up of components that are independent
                                            of each other and have no dependence on each other.
                                        </li>
                                        <li>Types of coupling<ul>
                                                <li> Data Coupling: <ul>
                                                        <li>The modules are connected by the
                                                            data coupling, if only data can be
                                                            passed between them.</li>
                                                    </ul>
                                                </li>
                                                <li>Stamp Coupling:<ul>
                                                        <li>In this type of coupling, the data
                                                            structure is used to transfer
                                                            information from one component to
                                                            another.</li>
                                                    </ul>
                                                </li>
                                                <li>Control Coupling:<ul>
                                                        <li>In this type of coupling, one module
                                                            controls the flow of another and
                                                            passes information from one to
                                                            another.</li>
                                                    </ul>
                                                </li>
                                                <li>External Coupling:<ul>
                                                        <li>This type of coupling occurs when an
                                                            external imposed data format and
                                                            communication protocol are shared by
                                                            two modules. External Coupling is
                                                            generally related to the
                                                            communication to external devices.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Common Coupling:<ul>
                                                        <li>It is the second highest type of
                                                            coupling also known as Global
                                                            Coupling. It occurs when the same
                                                            global data are shared by the two
                                                            modules. In this, the modules will
                                                            undergo changes if there are changes
                                                            in the shared resource.</li>
                                                    </ul>
                                                </li>
                                                <li>Content Coupling:<ul>
                                                        <li>Content Coupling is the highest type
                                                            of coupling which occurs when one of
                                                            the module relies on the other
                                                            module’s internal working. It means
                                                            a change in the second module will
                                                            lead to the changes in the dependent
                                                            module.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Architectural Design<ul>
                                <li>Introduction<ul>
                                        <li>Requirements of the software should be transformed
                                            into an architecture that describes the software’s
                                            top-level structure and identifies its components.
                                            This is accomplished through architectural design
                                            (also called <b>system design), </b>which acts as a
                                            preliminary ‘blueprint’ from which software can be
                                            developed. <b>IEEE </b>defines architectural design
                                            as ‘the process of defining a collection of hardware
                                            and software components and their interfaces to
                                            establish the framework for the development of a <a
                                                href="https://ecomputernotes.com/fundamental/introduction-to-computer/what-is-computer">computer</a>
                                            system.’<i> </i>This framework is established by
                                            examining the software requirements document and
                                            designing a model for providing implementation
                                            details. These details are used to specify the
                                            components of the system along with their inputs,
                                            outputs, functions, and the interaction between
                                            them. An architectural design performs the following
                                            functions.</li>
                                        <li>Architectural design is of crucial importance in
                                            software engineering during which the essential
                                            requirements like reliability, cost, and performance
                                            are dealt with. This task is cumbersome as the
                                            software engineering paradigm is shifting from
                                            monolithic, stand-alone, built-from-scratch systems
                                            to componentized, evolvable, standards-based, and
                                            product line-oriented systems. Also, a key challenge
                                            for designers is to know precisely how to proceed
                                            from requirements to architectural design. To avoid
                                            these problems, designers adopt strategies such as
                                            reusability, componentization, platform-based,
                                            standards-based, and so on.</li>
                                        <li>Though the architectural design is the
                                            responsibility of developers, some other people like
                                            user representatives, systems engineers, hardware
                                            engineers, and operations personnel are also
                                            involved. All these stakeholders must also be
                                            consulted while reviewing the architectural design
                                            in order to minimize the risks and errors.</li>
                                    </ul>
                                </li>
                                <li>Architectural Design Representation<ul>
                                        <li>Architectural design can be represented using the
                                            following models.</li>
                                        <li>Structural model:&nbsp;<ul>
                                                <li>Illustrates architecture as an ordered
                                                    collection of program components.</li>
                                            </ul>
                                        </li>
                                        <li>Dynamic model:<ul>
                                                <li>&nbsp;Specifies the behavioral aspect of the
                                                    software architecture and indicates how the
                                                    structure or system configuration changes as
                                                    the function changes due to change in the
                                                    external environment</li>
                                            </ul>
                                        </li>
                                        <li>Process model:&nbsp;<ul>
                                                <li>Focuses on the design of the business or
                                                    technical process, which must be implemented
                                                    in the system.</li>
                                            </ul>
                                        </li>
                                        <li>Functional model:&nbsp;<ul>
                                                <li>Represents the functional hierarchy of a
                                                    system..</li>
                                            </ul>
                                        </li>
                                        <li>Framework model:<ul>
                                                <li>&nbsp;Attempts to identify repeatable
                                                    architectural design patterns encountered in
                                                    similar types of application. This leads to
                                                    an increase in the level of abstraction.
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Architectural Design Document<ul>
                                        <li>The architectural design process results in
                                            an&nbsp;Architectural Design Document
                                            (ADD).&nbsp;This document consists of a number of
                                            graphical representations that comprises software
                                            models along with associated descriptive text. The
                                            software models include static model, interface
                                            model, relationship model, and dynamic process
                                            model.&nbsp;They show how the system is organized
                                            into a process at run-time.</li>
                                        <li>Architectural design document gives the developers a
                                            solution to the problem stated in the Software
                                            Requirements Specification (SRS). Note that it
                                            considers only those requirements in detail that
                                            affect the program structure. In addition to ADD,
                                            other outputs of the architectural design are listed
                                            below.<ul>
                                                <li>Various reports including audit report,
                                                    progress report, and configuration status
                                                    accounts report.</li>
                                                <li>Various plans for detailed design phase,
                                                    which include the following</li>
                                                <li>Software verification and validation plan
                                                </li>
                                                <li>Software configuration management plan</li>
                                                <li>Software quality assurance plan</li>
                                                <li>Software project management plan.</li>
                                                <li>RMMM</li>
                                                <li>Test Cases</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Architectural Styles<ul>
                                        <li>Introduction<ul>
                                                <li>Architectural styles define a group of
                                                    interlinked systems that share structural
                                                    and semantic properties. In short, the
                                                    objective of using architectural styles is
                                                    to establish a structure for all the
                                                    components present in a system. If an
                                                    existing architecture is to be
                                                    re-engineered, then imposition of an
                                                    architectural style results in fundamental
                                                    changes in the structure of the system. This
                                                    change also includes re-assignment of the
                                                    functionality performed by the components.
                                                </li>
                                                <li>By applying certain constraints on the
                                                    design space, we can make different
                                                    style-specific analysis from an
                                                    architectural style. In addition, if
                                                    conventional structures are used for an
                                                    architectural style, the other stakeholders
                                                    can easily understand the organization of
                                                    the system.</li>
                                                <li>A&nbsp;computer-based system (software is
                                                    part of this system) exhibits one of the
                                                    many available architectural styles. Every
                                                    architectural style describes a system
                                                    category that includes the following.<ul>
                                                        <li>Computational components&nbsp;such
                                                            as clients, server, filter,
                                                            and&nbsp;database&nbsp;to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                                                            execute the desired system function.
                                                        </li>
                                                        <li>A set of&nbsp;connectors&nbsp;such
                                                            as procedure call,
                                                            events&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                                                            broadcast,&nbsp;database&nbsp;protocols,
                                                            and pipes to provide communication
                                                            among
                                                            the&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                                                            computational components.</li>
                                                        <li>Constraints&nbsp;to define
                                                            integration of components to form a
                                                            system</li>
                                                        <li>A&nbsp;semantic&nbsp;model, which
                                                            enable the software designer to
                                                            identify the characteristics of the
                                                            system as a whole by studying the
                                                            characteristics of its components.
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Data-Flow architecture<ul>
                                                <li>Data-flow architecture is mainly used in the
                                                    systems that accept some inputs and
                                                    transform it into the desired outputs by
                                                    applying a series of transformations. Each
                                                    component, known
                                                    as&nbsp;filter,&nbsp;transforms the data and
                                                    sends this transformed data to other filters
                                                    for further processing using the connector,
                                                    known as&nbsp;pipe. Each filter works as an
                                                    independent entity, that is, it is not
                                                    concerned with the filter which is producing
                                                    or consuming the data. A pipe is a
                                                    unidirectional channel which transports the
                                                    data received on one end to the other end.
                                                    It does not change the data in anyway; it
                                                    merely supplies the data to the filter on
                                                    the receiver end.</li>
                                                <li>Most of the times, the data-flow
                                                    architecture degenerates a batch sequential
                                                    system. In this system, a batch of data is
                                                    accepted as input and&nbsp;then a series of
                                                    sequential filters are applied to transform
                                                    this data. One common&nbsp;example of this
                                                    architecture is UNIX shell programs. In
                                                    these programs, UNIX&nbsp;processes act as
                                                    filters and the file system through which
                                                    UNIX processes interact,&nbsp;act as pipes.
                                                    Other well-known examples of this
                                                    architecture are compilers, signal
                                                    processing&nbsp;systems, parallel
                                                    programming, functional programming, and
                                                    distributed&nbsp;systems.</li>
                                                <li>Some advantages associated with the
                                                    data-flow architecture are
                                                    listed&nbsp;below.<ul>
                                                        <li>It supports reusability.</li>
                                                        <li>It is maintainable and modifiable.
                                                        </li>
                                                        <li>It supports concurrent execution.
                                                        </li>
                                                        <li>Some disadvantages associated with
                                                            the data-flow architecture are
                                                            listed&nbsp;&nbsp;&nbsp;&nbsp;
                                                            below.</li>
                                                        <li>It often degenerates to batch
                                                            sequential system.</li>
                                                        <li>It does not provide enough support
                                                            for applications requires user
                                                            interaction.</li>
                                                        <li>It is difficult to synchronize two
                                                            different but related streams.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Object oriented architecture<ul>
                                                <li>In object-oriented architectural style,
                                                    components of a system encapsulate data and
                                                    operations, which are applied to manipulate
                                                    the data. In this style, components are
                                                    represented as&nbsp;objects&nbsp;and they
                                                    interact with each other through methods
                                                    (connectors). </li>
                                                <li>This architectural style has some important
                                                    characteristics, which are listed below.<ul>
                                                        <li>Objects maintain the integrity of
                                                            the system.</li>
                                                        <li>An object is not aware of the
                                                            representation of other objects.
                                                        </li>
                                                        <li>Some of the advantages associated
                                                            with the object-oriented
                                                            architecture are listed below.</li>
                                                        <li>It allows designers to decompose a
                                                            problem into a collection of
                                                            independent objects.</li>
                                                        <li>The implementation detail of objects
                                                            is hidden from each other and hence,
                                                            they can be changed without
                                                            affecting other objects.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Layered system architecture<ul>
                                                <li>In layered architecture, several layers
                                                    (components) are defined with each layer
                                                    performing a well-defined set of operations.
                                                    These layers are arranged in a hierarchical
                                                    manner, each one built upon the one below
                                                    it. Each layer provides a set of services to
                                                    the layer above it and acts as a client to
                                                    the layer below it. The interaction between
                                                    layers is provided through protocols
                                                    (connectors) that define a set of rules to
                                                    be followed during interaction. One common
                                                    example of this architectural style is
                                                    OSI-ISO (Open Systems
                                                    Interconnection-International Organization
                                                    for Standardization) communication system.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Data-centered architecture<ul>
                                                <li>A data-centered architecture has two
                                                    distinct components: a&nbsp;central data
                                                    structure&nbsp;or data store (central
                                                    repository) and a&nbsp;collection of client
                                                    software.&nbsp;The data store (for example,
                                                    a database or a file) represents the current
                                                    state of the data and the client software
                                                    performs several operations like add,
                                                    delete, update, etc., on the data stored in
                                                    the data store. In some cases, the data
                                                    store allows the client software to access
                                                    the data independent of any changes or the
                                                    actions of other client software.</li>
                                                <li>In this architectural style, new components
                                                    corresponding to clients can be added and
                                                    existing components can be modified easily
                                                    without taking into account other clients.
                                                    This is because client components operate
                                                    independently of one another.</li>
                                                <li>A variation of this architectural style is
                                                    blackboard system in which the data store is
                                                    transformed into a blackboard&nbsp;that
                                                    notifies the client software when the data
                                                    (of their interest) changes. In addition,
                                                    the&nbsp;information&nbsp;can be transferred
                                                    among the clients through the
                                                    blackboard&nbsp;component.</li>
                                                <li>Some advantages of the data-centered
                                                    architecture are listed below.<ul>
                                                        <li>Clients operate independently of one
                                                            another.</li>
                                                        <li>Data repository is independent of
                                                            the clients.</li>
                                                        <li>It adds scalability (that is, new
                                                            clients can be added easily).</li>
                                                        <li>It supports modifiability.</li>
                                                        <li>It achieves data integration in
                                                            component-based development using
                                                            blackboard.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li> Call and return architecture<ul>
                                                <li>A call and return architecture enables
                                                    software designers to achieve a program
                                                    structure, which can be easily modified.
                                                    This style consists of the following two
                                                    substyles.</li>
                                                <li>Main program/subprogram architecture:<ul>
                                                        <li>&nbsp;In this, function is
                                                            decomposed into a control hierarchy
                                                            where the main program invokes a
                                                            number of program components, which
                                                            in turn may invoke other components.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Remote procedure call architecture:&nbsp;
                                                    <ul>
                                                        <li>In this, components of the main or
                                                            subprogram architecture are
                                                            distributed over a network across
                                                            multiple computers.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Component-level design<ul>
                                <li>Component-Level Design Definition<ul>
                                        <li>In software engineering, after the planning stage of
                                            an application or system, called requirements
                                            modeling, the architectural design of the software
                                            follows. At this point it's designed on a higher
                                            level. After that, the process of taking the
                                            components identified in the architectural design
                                            and getting down to a nuts-and-bolts level of
                                            designing the proposed software is
                                            called&nbsp;component-level design. This level of
                                            design defines the interface, algorithms, data
                                            structure, and communication methods of each
                                            component.</li>
                                        <li>But first, we should ask: what exactly is a
                                            component? Simply put, a&nbsp;component, sometimes
                                            also called a module, is the basic building block
                                            for the software application or system being
                                            designed. A more technical description of a
                                            component is that it's a portable, replaceable, and
                                            reusable set of functions which is part of a system
                                            and incorporates implementation and exposes a set of
                                            interfaces.</li>
                                        <li>There are three main views of component-level
                                            design:<ul>
                                                <li>1. Object-Oriented View<ul>
                                                        <li>In the&nbsp;object-oriented view, a
                                                            component contains a set of
                                                            collaborating classes. As a quick
                                                            reminder,&nbsp;classes&nbsp;are
                                                            groups of objects with common
                                                            properties, operations, and
                                                            relationships to other objects and
                                                            meanings.&nbsp;Analysis
                                                            classes&nbsp;can be thought of as
                                                            classes that have to do with the
                                                            real world. These include, for
                                                            example, people, physical things, or
                                                            locations.&nbsp;Design
                                                            classes&nbsp;are classes within the
                                                            context of the software itself.
                                                            Analysis and design classes are
                                                            mentioned here because the
                                                            object-oriented view explains both
                                                            types of class to identify all their
                                                            operations and attributes, as well
                                                            as the interfaces that enable
                                                            classes to communicate and
                                                            collaborate.</li>
                                                    </ul>
                                                </li>
                                                <li>2. Conventional View<ul>
                                                        <li>In the&nbsp;conventional
                                                            view&nbsp;of component-level design,
                                                            the component is considered a
                                                            functional element of the software
                                                            that integrates the processing logic
                                                            and necessary internal data
                                                            structures to perform its task, as
                                                            well as the interface that allows
                                                            for calling the component and
                                                            passing data to it.</li>
                                                    </ul>
                                                </li>
                                                <li>3. Process-Related View<ul>
                                                        <li>The&nbsp;process-related
                                                            view&nbsp;emphasizes building
                                                            software from existing components
                                                            maintained in a library rather than
                                                            creating them from scratch.
                                                            Designing components to be reusable
                                                            in this manner requires that each
                                                            component contains:</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Basic Design Principles<ul>
                                        <li>The Open-Closed Principle (OCP)-<ul>
                                                <li>“A module [component] should be open for
                                                    extension but closed for modiﬁ cation”. This
                                                    statement seems to be a contradiction, but
                                                    it represents one of the most important
                                                    characteristics of a good component-level
                                                    design. Stated simply, you should specify
                                                    the component in a way that allows it to be
                                                    extended (within the functional domain that
                                                    it addresses) without the need to make
                                                    internal (code or logic-level) modiﬁcations
                                                    to the component itself.</li>
                                            </ul>
                                        </li>
                                        <li>The Liskov Substitution Principle (LSP)-<ul>
                                                <li>“Subclasses should be substitutable for
                                                    their base classes”. This design principle,
                                                    originally proposed that a component that
                                                    uses a base class should continue to
                                                    function properly if a class derived from
                                                    the base class is passed to the component
                                                    instead. LSP demands that any class derived
                                                    from a base class must honor any implied
                                                    contract between the base class and the
                                                    components that use it.</li>
                                            </ul>
                                        </li>
                                        <li>Dependency Inversion Principle (DIP)-<ul>
                                                <li>“Depend on abstractions. Do not depend on
                                                    concretions”. As we have seen in the
                                                    discussion of the OCP, abstractions are the
                                                    place where a design can be extended without
                                                    great complication. The more a component
                                                    depends on other concrete components (rather
                                                    than on abstractions such as an interface),
                                                    the more difficult it will be to extend.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>The Interface Segregation Principle (ISP)- <ul>
                                                <li>“Many client-speciﬁc interfaces are better
                                                    than one general purpose interface”. There
                                                    are many instances in which multiple client
                                                    components use the operations provided by a
                                                    server class. ISP suggests that you should
                                                    create a specialized interface to serve each
                                                    major category of clients. Only those
                                                    operations that are relevant to a particular
                                                    category of clients should be speciﬁed in
                                                    the interface for that client. If multiple
                                                    clients require the same operations, it
                                                    should be speciﬁed in each of the
                                                    specialized interfaces. </li>
                                            </ul>
                                        </li>
                                        <li>The Release Reuse Equivalency Principle (REP)-<ul>
                                                <li>“The granule of reuse is the granule of
                                                    release”. When classes or components are
                                                    designed for reuse, an implicit contract is
                                                    established between the developer of the
                                                    reusable entity and the people who will use
                                                    it. The developer commits to establish a
                                                    release control system that supports and
                                                    maintains older versions of the entity while
                                                    the users slowly upgrade to the most current
                                                    version. Rather than addressing each class
                                                    individually, it is often advisable to group
                                                    reusable classes into packages that can be
                                                    managed and controlled as newer versions
                                                    evolve.</li>
                                            </ul>
                                        </li>
                                        <li>The Common Closure Principle (CCP)- <ul>
                                                <li>“Classes that change together belong
                                                    together.” Classes should be packaged
                                                    cohesively. That is, when classes are
                                                    packaged as part of a design, they should
                                                    address the same functional or behavioural
                                                    area. When some characteristic of that area
                                                    must change, it is likely that only those
                                                    classes within the package will require
                                                    modiﬁcation. This leads to more effective
                                                    change control and release management. </li>
                                            </ul>
                                        </li>
                                        <li>The Common Reuse Principle (CRP)-<ul>
                                                <li>“Classes that aren’t reused together should
                                                    not be grouped together”. When one or more
                                                    classes with a package changes, the release
                                                    number of the package changes. All other
                                                    classes or packages that rely on the package
                                                    that has been changed must now update to the
                                                    most recent release of the package and be
                                                    tested to ensure that the new release
                                                    operated without incident. If classes are
                                                    not grouped cohesively, it is possible that
                                                    a class with no relationship to other
                                                    classes within a package is changed. This
                                                    will precipitate unnecessary integration and
                                                    testing. For this reason, only classes that
                                                    are reused together should be included
                                                    within a package.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Component-Level Design Guidelines<ul>
                                        <li>Introduction :<ul>
                                                <li>In addition to the principles, a set of
                                                    Practical design guidelines can be applied
                                                    as component-level design proceeds.</li>
                                            </ul>
                                        </li>
                                        <li>These guidelines apply to</li>
                                        <li>Components<ul>
                                                <li>Naming conventions should be established for
                                                    components that are specified as part of the
                                                    architectural model and then refined and
                                                    elaborated as part of the component-level
                                                    model.</li>
                                            </ul>
                                        </li>
                                        <li>Interfaces<ul>
                                                <li>Interfaces provide important information
                                                    about communication and collaboration.</li>
                                            </ul>
                                        </li>
                                        <li>Dependencies and Inheritance<ul>
                                                <li>It is a good idea to model dependencies from
                                                    left to right and inheritance from bottom
                                                    (derived classes) to top (base classes).
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Cohesion<ul>
                                        <li>Introduction: <ul>
                                                <li>As per context of component-level design for
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Conventional view:<ul>
                                                <li>the “single-mindedness” of a module</li>
                                            </ul>
                                        </li>
                                        <li>OO view (Object Oriented View):<ul>
                                                <li>cohesion implies that a component or class
                                                    encapsulates only attributes and operations
                                                    that are closely related to one another and
                                                    to the class or component itself</li>
                                            </ul>
                                        </li>
                                        <li>Levels of cohesion OR different types of cohesion
                                            <ul>
                                                <li>Functional<ul>
                                                        <li>Exhibited primarily by operations,
                                                            this level of cohesion occurs when a
                                                            component performs a targeted
                                                            computation and then returns a
                                                            result.</li>
                                                    </ul>
                                                </li>
                                                <li>Layer<ul>
                                                        <li>Exhibited by packages, components,
                                                            and classes, this type of cohesion
                                                            occurs when a higher layer accesses
                                                            the services of a lower layer, but
                                                            lower layers do not access higher
                                                            layers.</li>
                                                        <li>For example, the SafeHome security
                                                            function requirement to make an
                                                            outgoing phone call if an alarm is
                                                            sensed. It might be possible to
                                                            define a set of layered packages.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Communicational<ul>
                                                        <li>-All operations that access the same
                                                            data are defined within one class.
                                                            In general, such classes focus only
                                                            on the data for accessing and
                                                            storing it.</li>
                                                        <li>-Classes and components that exhibit
                                                            functional, layer, and
                                                            communicational cohesion are
                                                            relatively easy to implement, test,
                                                            and maintain.</li>
                                                        <li>-It is important to note, however,
                                                            that pragmatic Practical design and
                                                            implementation issues sometimes
                                                            force you to opt for lower levels of
                                                            cohesion.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Coupling<ul>
                                        <li>Conventional view coupling is : <ul>
                                                <li>The degree to which a component is connected
                                                    to other components and to the external
                                                    world </li>
                                            </ul>
                                        </li>
                                        <li>OO view coupling is :<ul>
                                                <li>A qualitative measure of the degree to which
                                                    classes are connected to one another </li>
                                            </ul>
                                        </li>
                                        <li>As classes (and components) become more
                                            interdependent, coupling increases. An important
                                            objective in component-level design is to keep
                                            coupling as low as is possible. </li>
                                        <li>Coupling categories OR Level of coupling <ul>
                                                <li>Content Coupling <ul>
                                                        <li>It occurs when one component
                                                            “secretly modifies data that is
                                                            internal to another component” </li>
                                                        <li>This violates information hiding—a
                                                            basic design concept.</li>
                                                    </ul>
                                                </li>
                                                <li>Common coupling<ul>
                                                        <li>It occurs when a number of
                                                            components all make use of a global
                                                            variable. </li>
                                                        <li>Although this is sometimes necessary
                                                            (e.g., for establishing default
                                                            values that are applicable
                                                            throughout an application)</li>
                                                    </ul>
                                                </li>
                                                <li>Control coupling <ul>
                                                        <li>It Occurs when operation A() invokes
                                                            operation B() and passes a control
                                                            flag to B. The control flag then
                                                            “directs” logical flow within B.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Stamp coupling<ul>
                                                        <li>It occurs when Class B is declared
                                                            as a type for an argument of an
                                                            operation of Class A. Because Class
                                                            B is now a part of the definition of
                                                            Class A, modifying the system
                                                            becomes more complex.</li>
                                                    </ul>
                                                </li>
                                                <li>Data coupling<ul>
                                                        <li>It occurs when operations pass long
                                                            strings of data arguments.</li>
                                                        <li>The “bandwidth” of communication
                                                            between classes and components grows
                                                            and the complexity of the interface
                                                            increases. </li>
                                                    </ul>
                                                </li>
                                                <li>Routine call coupling <ul>
                                                        <li>It occurs when one operation invokes
                                                            another.</li>
                                                        <li>This level of coupling is common and
                                                            is often quite necessary. </li>
                                                        <li>However, it does increase the
                                                            connectedness of a system.</li>
                                                    </ul>
                                                </li>
                                                <li>Type use coupling <ul>
                                                        <li>It Occurs, when component A uses a
                                                            data type defined in component B
                                                            (e.g., this occurs whenever “a class
                                                            declares an instance variable or a
                                                            local variable as having another
                                                            class for its type”.</li>
                                                        <li>If the type definition changes,
                                                            every component that uses the
                                                            definition must also change.</li>
                                                    </ul>
                                                </li>
                                                <li>Inclusion or import coupling<ul>
                                                        <li>It occurs when component A imports
                                                            or includes a package or the content
                                                            of component B. </li>
                                                    </ul>
                                                </li>
                                                <li>External coupling <ul>
                                                        <li>It occurs when a component
                                                            communicates or collaborates with
                                                            infrastructure components (e.g.,
                                                            operating system functions, database
                                                            capability, and telecommunication
                                                            functions).</li>
                                                        <li>Although this type of coupling is
                                                            necessary, it should be limited to a
                                                            small number of components or
                                                            classes within a system.,
                                                            &lt;&lt;infrastructure&gt;&gt; might
                                                            be used to identify an
                                                            infrastructure component,
                                                            &lt;&lt;database&gt;&gt; could be
                                                            used to identify a database that
                                                            services one or more design classes
                                                            or the entire system;
                                                            &lt;&lt;table&gt;&gt; can be used to
                                                            identify a table within a database.
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>CONDUCTING COMPONENT-LEVEL DESIGN<ul>
                                        <li>The following steps represent a typical task set for
                                            component-level design, when it is applied for an
                                            object-oriented system. <ul>
                                                <li>Step1- Identify all design classes that
                                                    correspond to the problem domain. </li>
                                                <li>Step2- Identify all design classes that
                                                    correspond to the infrastructure domain.
                                                </li>
                                                <li>Step3- Elaborate all design classes that are
                                                    not acquired as reusable components. <ul>
                                                        <li>Step3a- Specify message details when
                                                            classes or components collaborate.
                                                        </li>
                                                        <li>Step3b- Identify appropriate
                                                            interfaces for each component. </li>
                                                        <li>Step3c- Elaborate attributes and
                                                            defines data types and data
                                                            structures required to implement
                                                            them.</li>
                                                        <li>Step 3d- Describe processing flow
                                                            within each operation in detail.
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>Step4- Describe persistent data sources
                                                    (databases and files) and identify the
                                                    classes required to manage them.</li>
                                                <li>Step5- Develop and elaborate behavioural
                                                    representations for a class or </li>
                                                <li>Component.</li>
                                                <li>Step6- Elaborate deployment diagrams to
                                                    provide additional implementation detail.
                                                </li>
                                                <li>Step7- Refractor every component-level
                                                    design representation and always consider
                                                    alternatives.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>User Interface Design <ul>
                                <li>Introduction<ul>
                                        <li>User interface is the front-end application view to
                                            which user interacts in order to use the software.
                                            User can manipulate and control the software as well
                                            as hardware by means of user interface. Today, user
                                            interface is found at almost every place where
                                            digital technology exists, right from computers,
                                            mobile phones, cars, music players, airplanes, ships
                                            etc.</li>
                                        <li>User interface is part of software and is designed
                                            such a way that it is expected to provide the user
                                            insight of the software. UI provides fundamental
                                            platform for human-computer interaction.</li>
                                        <li>UI can be graphical, text-based, audio-video based,
                                            depending upon the underlying hardware and software
                                            combination. UI can be hardware or software or a
                                            combination of both.</li>
                                    </ul>
                                </li>
                                <li>The software becomes more popular if its user interface is:
                                    <ul>
                                        <li>Attractive </li>
                                        <li>Simple to use </li>
                                        <li>Responsive in short time </li>
                                        <li>Clear to understand </li>
                                        <li>Consistent on all interfacing screens</li>
                                    </ul>
                                </li>
                                <li>UI is broadly divided into two categories<ul>
                                        <li>Command Line Interface (CLI)<ul>
                                                <li>CLI has been a great tool of interaction
                                                    with computers until the video display
                                                    monitors came into existence. CLI is first
                                                    choice of many technical users and
                                                    programmers. CLI is minimum interface
                                                    software can provide to its users.</li>
                                                <li>CLI provides a command prompt, the place
                                                    where the user types the command and feeds
                                                    to the system. The user needs to remember
                                                    the syntax of command and its use. Earlier
                                                    CLI were not programmed to handle the user
                                                    errors effectively.</li>
                                                <li>A command is a text-based reference to set
                                                    of instructions, which are expected to be
                                                    executed by the system. There are methods
                                                    like macros, scripts that make it easy for
                                                    the user to operate.</li>
                                                <li>CLI uses less amount of computer resource as
                                                    compared to GUI.</li>
                                                <li>CLI Elements<ul>
                                                        <li>Command Prompt&nbsp;- It is
                                                            text-based notifier that is mostly
                                                            shows the context in which the user
                                                            is working. It is generated by the
                                                            software system.</li>
                                                        <li>Cursor&nbsp;- It is a small
                                                            horizontal line or a vertical bar of
                                                            the height of line, to represent
                                                            position of character while typing.
                                                            Cursor is mostly found in blinking
                                                            state. It moves as the user writes
                                                            or deletes something.</li>
                                                        <li>Command&nbsp;- A command is an
                                                            executable instruction. It may have
                                                            one or more parameters. Output on
                                                            command execution is shown inline on
                                                            the screen. When output is produced,
                                                            command prompt is displayed on the
                                                            next line.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Graphical User Interface<ul>
                                                <li>Graphical User Interface provides the user
                                                    graphical means to interact with the system.
                                                    GUI can be combination of both hardware and
                                                    software. Using GUI, user interprets the
                                                    software.</li>
                                                <li>Typically, GUI is more resource consuming
                                                    than that of CLI. With advancing technology,
                                                    the programmers and designers create complex
                                                    GUI designs that work with more efficiency,
                                                    accuracy and speed.</li>
                                                <li>GUI Elements</li>
                                                <li>GUI provides a set of components to interact
                                                    with software or hardware.</li>
                                                <li>Every graphical component provides a way to
                                                    work with the system. A GUI system has
                                                    following elements such as:<ul>
                                                        <li>Window&nbsp;- An area where contents
                                                            of application are displayed.
                                                            Contents in a window can be
                                                            displayed in the form of icons or
                                                            lists, if the window represents file
                                                            structure. It is easier for a user
                                                            to navigate in the file system in an
                                                            exploring window. Windows can be
                                                            minimized, resized or maximized to
                                                            the size of screen. They can be
                                                            moved anywhere on the screen. A
                                                            window may contain another window of
                                                            the same application, called child
                                                            window.</li>
                                                        <li>Tabs&nbsp;- If an application allows
                                                            executing multiple instances of
                                                            itself, they appear on the screen as
                                                            separate windows.&nbsp;Tabbed
                                                            Document Interface&nbsp;has come up
                                                            to open multiple documents in the
                                                            same window. This interface also
                                                            helps in viewing preference panel in
                                                            application. All modern web-browsers
                                                            use this feature.</li>
                                                        <li>Menu&nbsp;- Menu is an array of
                                                            standard commands, grouped together
                                                            and placed at a visible place
                                                            (usually top) inside the application
                                                            window. The menu can be programmed
                                                            to appear or hide on mouse clicks.
                                                        </li>
                                                        <li>Icon&nbsp;- An icon is small picture
                                                            representing an associated
                                                            application. When these icons are
                                                            clicked or double clicked, the
                                                            application window is opened. Icon
                                                            displays application and programs
                                                            installed on a system in the form of
                                                            small pictures.</li>
                                                        <li>Cursor&nbsp;- Interacting devices
                                                            such as mouse, touch pad, digital
                                                            pen are represented in GUI as
                                                            cursors. On screen cursor follows
                                                            the instructions from hardware in
                                                            almost real-time. Cursors are also
                                                            named pointers in GUI systems. They
                                                            are used to select menus, windows
                                                            and other application features.</li>
                                                    </ul>
                                                </li>
                                                <li>Application specific GUI components</li>
                                                <li>A GUI of an application contains one or more
                                                    of the listed GUI elements:<ul>
                                                        <li>Application Window&nbsp;- Most
                                                            application windows uses the
                                                            constructs supplied by operating
                                                            systems but many use their own
                                                            customer created windows to contain
                                                            the contents of application.</li>
                                                        <li>Dialogue Box&nbsp;- It is a child
                                                            window that contains message for the
                                                            user and request for some action to
                                                            be taken. For Example: Application
                                                            generates a dialogue to get
                                                            confirmation from user to delete a
                                                            file.</li>
                                                        <li>Text-Box&nbsp;- Provides an area for
                                                            user to type and enter text-based
                                                            data.</li>
                                                        <li>Buttons&nbsp;- They imitate real
                                                            life buttons and are used to submit
                                                            inputs to the software.</li>
                                                        <li>Radio-button&nbsp;- Displays
                                                            available options for selection.
                                                            Only one can be selected among all
                                                            offered.</li>
                                                        <li>Check-box&nbsp;- Functions similar
                                                            to list-box. When an option is
                                                            selected, the box is marked as
                                                            checked. Multiple options
                                                            represented by check boxes can be
                                                            selected.</li>
                                                        <li>List-box&nbsp;- Provides list of
                                                            available items for selection. More
                                                            than one item can be selected.</li>
                                                    </ul>
                                                </li>
                                                <li>Other impressive GUI components are:<ul>
                                                        <li>Sliders </li>
                                                        <li>Combo-box </li>
                                                        <li>Data-grid </li>
                                                        <li>Drop-down list</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>User Interface Design Activities<ul>
                                        <li>There are a number of activities performed for
                                            designing user interface. The process of GUI design
                                            and implementation is alike SDLC. Any model can be
                                            used for GUI implementation among Waterfall,
                                            Iterative or Spiral Model.</li>
                                        <li>A model used for GUI design and development should
                                            fulfill these GUI specific steps.<ul>
                                                <li>GUI Requirement Gathering&nbsp;- The
                                                    designers may like to have list of all
                                                    functional and non-functional requirements
                                                    of GUI. This can be taken from user and
                                                    their existing software solution.</li>
                                                <li>User Analysis&nbsp;- The designer studies
                                                    who is going to use the software GUI. The
                                                    target audience matters as the design
                                                    details change according to the knowledge
                                                    and competency level of the user. If user is
                                                    technical savvy, advanced and complex GUI
                                                    can be incorporated. For a novice user, more
                                                    information is included on how-to of
                                                    software.</li>
                                                <li>Task Analysis&nbsp;- Designers have to
                                                    analyze what task is to be done by the
                                                    software solution. Here in GUI, it does not
                                                    matter how it will be done. Tasks can be
                                                    represented in hierarchical manner taking
                                                    one major task and dividing it further into
                                                    smaller sub-tasks. Tasks provide goals for
                                                    GUI presentation. Flow of information among
                                                    sub-tasks determines the flow of GUI
                                                    contents in the software.</li>
                                                <li>GUI Design &amp; implementation&nbsp;-
                                                    Designers after having information about
                                                    requirements, tasks and user environment,
                                                    design the GUI and implements into code and
                                                    embed the GUI with working or dummy software
                                                    in the background. It is then self-tested by
                                                    the developers.</li>
                                                <li>Testing&nbsp;- GUI testing can be done in
                                                    various ways. Organization can have in-house
                                                    inspection, direct involvement of users and
                                                    release of beta version are few of them.
                                                    Testing may include usability,
                                                    compatibility, user acceptance etc.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>GUI Implementation Tools<ul>
                                        <li>There are several tools available using which the
                                            designers can create entire GUI on a mouse click.
                                            Some tools can be embedded into the software
                                            environment (IDE).</li>
                                        <li>GUI implementation tools provide powerful array of
                                            GUI controls. For software customization, designers
                                            can change the code accordingly.</li>
                                        <li>There are different segments of GUI tools according
                                            to their different use and platform.</li>
                                        <li>Example - Mobile GUI, Computer GUI, Touch-Screen GUI
                                            etc.</li>
                                        <li>Here is a list of few tools which come handy to
                                            build GUI:<ul>
                                                <li>FLUID </li>
                                                <li>AppInventor (Android) </li>
                                                <li>LucidChart </li>
                                                <li>Wavemaker </li>
                                                <li>Visual Studio</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>User Interface Golden rules<ul>
                                        <li>The following rules are mentioned to be the golden
                                            rules for GUI design, described by Shneiderman and
                                            Plaisant in their book (Designing the User
                                            Interface).</li>
                                        <li>Strive for consistency&nbsp;-<ul>
                                                <li> Consistent sequences of actions should be
                                                    required in similar situations. Identical
                                                    terminology should be used in prompts,
                                                    menus, and help screens. Consistent commands
                                                    should be employed throughout.</li>
                                            </ul>
                                        </li>
                                        <li>Enable frequent users to use short-cuts&nbsp;- <ul>
                                                <li>The user’s desire to reduce the number of
                                                    interactions increases with the frequency of
                                                    use. Abbreviations function keys, hidden
                                                    commands, and macro facilities are very
                                                    helpful to an expert user.</li>
                                            </ul>
                                        </li>
                                        <li>Offer informative feedback&nbsp;- <ul>
                                                <li>For every operator action, there should be
                                                    some system feedback. For frequent and minor
                                                    actions, the response must be modest, while
                                                    for infrequent and major actions, the
                                                    response must be more substantial.</li>
                                            </ul>
                                        </li>
                                        <li>Design dialog to yield closure&nbsp;- <ul>
                                                <li>Sequences of actions should be organized
                                                    into groups with a beginning, middle, and
                                                    end. The informative feedback at the
                                                    completion of a group of actions gives the
                                                    operators the satisfaction of
                                                    accomplishment, a sense of relief, the
                                                    signal to drop contingency plans and options
                                                    from their minds, and this indicates that
                                                    the way ahead is clear to prepare for the
                                                    next group of actions.</li>
                                            </ul>
                                        </li>
                                        <li>Offer simple error handling&nbsp;- <ul>
                                                <li>As much as possible, design the system so
                                                    the user will not make a serious error. If
                                                    an error is made, the system should be able
                                                    to detect it and offer simple,
                                                    comprehensible mechanisms for handling the
                                                    error.</li>
                                            </ul>
                                        </li>
                                        <li>Permit easy reversal of actions&nbsp;- <ul>
                                                <li>This feature relieves anxiety, since the
                                                    user knows that errors can be undone. Easy
                                                    reversal of actions encourages exploration
                                                    of unfamiliar options. The units of
                                                    reversibility may be a single action, a data
                                                    entry, or a complete group of actions.</li>
                                            </ul>
                                        </li>
                                        <li>Support internal locus of control&nbsp;- <ul>
                                                <li>Experienced operators strongly desire the
                                                    sense that they are in charge of the system
                                                    and that the system responds to their
                                                    actions. Design the system to make users the
                                                    initiators of actions rather than the
                                                    responders.</li>
                                            </ul>
                                        </li>
                                        <li>Reduce short-term memory load&nbsp;- <ul>
                                                <li>The limitation of human information
                                                    processing in short-term memory requires the
                                                    displays to be kept simple, multiple page
                                                    displays be consolidated, window-motion
                                                    frequency be reduced, and sufficient
                                                    training time be allotted for codes,
                                                    mnemonics, and sequences of actions</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Chapter 5<ul>
                        <li>Software Risk<ul>
                                <li>Introduction<ul>
                                        <li>i. Process of restating the risks as a set of more
                                            detailed risks that will be easier to mitigate,
                                            monitor, and manage. </li>
                                        <li>ii. CTC (Condition-Transition-Consequence) format
                                            may be a good representation for the detailed risks
                                            (e.g. given that &lt;condition&gt; then there is a
                                            concern that (possibly) &lt;consequence&gt;). </li>
                                        <li>iii. This general condition can be refined in the
                                            following manner: <ul>
                                                <li>Sub condition 1. Certain reusable components
                                                    were developed by a third party with no
                                                    knowledge of internal design standards.
                                                </li>
                                                <li>Sub condition 2. The design standard for
                                                    component interfaces has not been solidified
                                                    and may not conform to certain existing
                                                    reusable components. </li>
                                                <li>Sub condition 3. Certain reusable components
                                                    have been implemented in a language that is
                                                    not supported on the target environment. iv.
                                                    The consequences associated with these
                                                    refined sub conditions remains the same
                                                    (i.e., 30 percent of software components
                                                    must be customer engineered), but the
                                                    refinement helps to isolate the underlying
                                                    risks and might lead to easier analysis and
                                                    response.</li>
                                            </ul>
                                        </li>
                                        <li>I. Reactive risk strategies <ul>
                                                <li>i. Reactive risk strategies follows that the
                                                    risks have to be tackled at the time of
                                                    their occurrence. </li>
                                                <li>ii. No precautions are to be taken as per
                                                    this strategy. </li>
                                                <li>iii. They are meant for risks with
                                                    relatively smaller impact. </li>
                                            </ul>
                                        </li>
                                        <li>II. Proactive risk strategies <ul>
                                                <li>i. Proactive risk strategies follows that
                                                    the risks have to be identified before start
                                                    of the project. </li>
                                                <li>ii. They have to be analyzed by assessing
                                                    their probability of occurrence, their
                                                    impact after occurrence, and steps to be
                                                    followed for its precaution. </li>
                                                <li>iii. They are meant for risks with
                                                    relatively higher impact.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Risk Identification<ul>
                                        <li>i. Product Size—risks associated with the overall
                                            size of the software to be built or modified.</li>
                                        <li>ii. Business Impact—risks associated with
                                            constraints imposed by management or the
                                            marketplace.</li>
                                        <li>iii. Customer Characteristics—risks associated with
                                            the sophistication of the customer and the
                                            developer's ability to communicate with the customer
                                            in a timely manner. </li>
                                        <li>iv. Process Definition—risks associated with the
                                            degree to which the software process has been
                                            defined and is followed by the development
                                            organization.</li>
                                        <li>v. Development Environment—risks associated with the
                                            availability and quality of the tools to be used to
                                            build the product. </li>
                                        <li>vi. Technology to be built—risks associated with the
                                            complexity of the system to be built and the
                                            "newness" of the technology that is packaged by the
                                            system.</li>
                                        <li>vii. Staff size and Experience—risks associated with
                                            the overall technical and project experience of the
                                            software engineers who will do the work.</li>
                                    </ul>
                                </li>
                                <li>Risk Assessment<ul>
                                        <li>1. Risk assessment is another important case that
                                            integrates risk management and risk analysis.</li>
                                        <li>2. There are many risk assessment methodologies that
                                            focus on different types of risks. Risk assessment
                                            requires correct explanations of the target system
                                            and all security features. </li>
                                        <li>3. It is important that a risk referent levels like
                                            performance, cost, support and schedule must be
                                            defined properly for risk assessment to be useful.
                                        </li>
                                    </ul>
                                </li>
                                <li>Risk Projection<ul>
                                        <li>Risk projection also called <i>risk estimation</i>,
                                            attempts to rate each risk in two ways—the
                                            likelihood or probability that the risk is real and
                                            the consequences of the problems associated with the
                                            risk, should it occur.</li>
                                        <li>The project planner, along with other managers and
                                            technical staff, performs four risk projection
                                            activities:</li>
                                        <li>(1) Establish a scale that reflects the perceived
                                            likelihood of a risk.</li>
                                        <li>(2) Delineate the consequences of the risk.</li>
                                        <li>(3) Estimate the impact of the risk on the project
                                            and the product.</li>
                                        <li>(4) Note the overall accuracy of the risk projection
                                            so that there will be no misunderstandings.</li>
                                    </ul>
                                </li>
                                <li>Risk Components and Drivers<ul>
                                        <li>The risk components are defined in the following
                                            manner:</li>
                                        <li>1. Performance Risk—the degree of uncertainty that
                                            the product will meet its requirements and be fit
                                            for its intended use. </li>
                                        <li>2. Cost Risk—the degree of uncertainty that the
                                            project budget will be maintained.</li>
                                        <li>3. Support Risk—the degree of uncertainty that the
                                            resultant software will be easy to correct, adapt,
                                            and enhance.</li>
                                        <li>4. Schedule Risk—the degree of uncertainty that the
                                            project schedule will be maintained and that the
                                            product will be delivered on time.</li>
                                    </ul>
                                </li>
                                <li>Steps in Setting up Risk Table<ul>
                                        <li>(1) Project team begins by listing all risks in the
                                            first column of the table. Accomplished with the
                                            help of the risk item checklists.</li>
                                        <li>(2) Each risk is categorized in the second column.
                                        </li>
                                        <li>(3) The probability of occurrence of each risk is
                                            entered in the next column of the table.The
                                            probability value for each risk can be estimated by
                                            team members individually.</li>
                                        <li>(4) Individual team members are polled in
                                            round-robin fashion until their assessment of risk
                                            probability begins to converge.</li>
                                    </ul>
                                </li>
                                <li>Assessing Risk Impact<ul>
                                        <li>Nature of the risk - The problems that are likely if
                                            it occurs.</li>
                                        <li>e.g. a poorly defined external interface to customer
                                            hardware (a technical risk) will preclude early
                                            design and testing and will likely lead to system
                                            integration problems late in a project.</li>
                                        <li>Scope of a risk - combines the severity with its
                                            overall distribution (how much of the project will
                                            be affected or how many customers are harmed?).</li>
                                        <li>Timing of a risk - when and how long the impact will
                                            be felt.</li>
                                        <li>Overall risk exposure, RE, determined using:<ul>
                                                <li><b>RE = P x C</b></li>
                                                <li><b>P</b> is the probability of occurrence
                                                    for a risk.</li>
                                                <li><b>C</b> is the cost to the project should
                                                    the risk occur.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>RMMM<ul>
                                        <li>Introduction<ul>
                                                <li>An effective strategy for dealing with risk
                                                    must consider three issues </li>
                                                <li>1. Risk mitigation (i.e., avoidance) </li>
                                                <li>2. Risk monitoring </li>
                                                <li>3. Risk management and contingency planning
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Need for RMMM<ul>
                                                <li>i. Meet with current staff to determine
                                                    causes for turnover (e.g., poor working
                                                    conditions, low pay and competitive job
                                                    market) </li>
                                                <li>ii. Mitigate those causes that are under our
                                                    control before the project starts </li>
                                                <li>iii. Once the project commences, assume
                                                    turnover will occur and develop techniques
                                                    to ensure continuity when people leave </li>
                                                <li>iv. Organize project teams so that
                                                    information about each development activity
                                                    is widely dispersed </li>
                                                <li>v. Define documentation standards and
                                                    establish mechanisms to ensure that
                                                    documents are developed in a timely manner
                                                </li>
                                                <li>vi. Conduct peer reviews of all work (so
                                                    that more than one person is "up to speed")
                                                </li>
                                                <li>vii. Assign a backup staff member for every
                                                    critical technologist. </li>
                                                <li>viii. During risk monitoring, the project
                                                    manager monitors factors that may provide an
                                                    indication of whether a risk is becoming
                                                    more or less likely </li>
                                                <li>ix. Risk management and contingency planning
                                                    assume that mitigation efforts have failed
                                                    and that the risk has become a reality </li>
                                                <li>x. RMMM steps incur additional project cost.
                                                </li>
                                                <li>xi. Large projects may have identified 30 –
                                                    40 risks. </li>
                                                <li>xii. Risk is not limited to the software
                                                    project itself. </li>
                                                <li>xiii. Risks can occur after the software has
                                                    been delivered to the user. </li>
                                            </ul>
                                        </li>
                                        <li>Risk: Computer Crash<ul>
                                                <li>Mitigation the cost associated with a
                                                    computer crash resulting in a loss of data
                                                    is crucial. A computer crash itself is not
                                                    crucial, but rather the loss of data. A loss
                                                    of data will result in not being able to
                                                    deliver the product to the customer. This
                                                    will result in a not receiving a letter of
                                                    acceptance from the customer. Without the
                                                    letter of acceptance, the group will receive
                                                    a failing grade for the course. As a result
                                                    the organization is taking steps to make
                                                    multiple backup copies of the software in
                                                    development and all documentation associated
                                                    with it, in multiple locations. </li>
                                                <li>Monitoring when working on the product or
                                                    documentation, the staff member should
                                                    always be aware of the stability of the
                                                    computing environment they’re working in.
                                                    Any changes in the stability of the
                                                    environment should be recognized and taken
                                                    seriously. · </li>
                                                <li>Management The lack of a stable-computing
                                                    environment is extremely hazardous to a
                                                    software development team. In the event that
                                                    the computing environment is found unstable,
                                                    the development team should cease work on
                                                    that system until the environment is made
                                                    stable again, or should move to a system
                                                    that is stable and continue working there.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Risk: Late Delivery <ul>
                                                <li>Mitigation the cost associated with a late
                                                    delivery is critical. A late delivery will
                                                    result in a late delivery of a letter of
                                                    acceptance from the customer. Without the
                                                    letter of acceptance, the group will receive
                                                    a failing grade for the course. Steps have
                                                    been taken to ensure a timely delivery by
                                                    gauging the scope of project based on the
                                                    delivery deadline. </li>
                                                <li>Monitoring A schedule has been established
                                                    to monitor project status. Falling behind
                                                    schedule would indicate a potential for late
                                                    delivery. The schedule will be followed
                                                    closely during all development stages. </li>
                                                <li>Management Late delivery would be a
                                                    catastrophic failure in the project
                                                    development. If the project cannot be
                                                    delivered on time the development team will
                                                    not pass the course. If it becomes apparent
                                                    that the project will not be completed on
                                                    time, the only course of action available
                                                    would be to request an extension to the
                                                    deadline form the customer.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Configuration Management<ul>
                                <li>Software Configuration management<ul>
                                        <li>The output of the software process is information
                                            that may be divided into three broad categories:
                                            <ul>
                                                <li>(1) Computer programs (both source level and
                                                    executable forms)</li>
                                                <li>(2) Work products that describe the computer
                                                    programs (targeted at various stakeholders)
                                                </li>
                                                <li>(3) Data or content (contained within the
                                                    program or external to it). The items that
                                                    comprise all information produced as part of
                                                    the software process are collectively called
                                                    a <i>software configuration.</i></li>
                                            </ul>
                                        </li>
                                        <li>What is the origin of these changes? The answer to
                                            this question is as varied as the changes
                                            themselves. However, there are four fundamental
                                            sources of change:<ul>
                                                <li>New business or market conditions dictate
                                                    changes in product requirements or business
                                                    rules.</li>
                                                <li>New stakeholder needs demand modification of
                                                    data produced by information systems,
                                                    functionality delivered by products, or
                                                    services delivered by a computer-based
                                                    system.</li>
                                                <li>Reorganization or business growth/downsizing
                                                    causes changes in project priorities or
                                                    software engineering team structure.</li>
                                                <li>Budgetary or scheduling constraints cause a
                                                    redefinition of the system or product.</li>
                                            </ul>
                                        </li>
                                        <li>Baselines<ul>
                                                <li>A <i>baseline </i>is a software
                                                    configuration management concept that helps
                                                    you to control change without seriously
                                                    impeding justifiable change.</li>
                                                <li>Before a software configuration item becomes
                                                    a baseline, change may be made quickly and
                                                    informally. However, once a baseline is
                                                    established, changes can be made, but a
                                                    specific, formal procedure must be applied
                                                    to evaluate and verify each change.</li>
                                                <li>In the context of software engineering, a
                                                    baseline is a milestone in the development
                                                    of software. A baseline is marked by the
                                                    delivery of one or more software
                                                    configuration items that have been approved
                                                    as a consequence of a technical review.</li>
                                                <li>The progression of events that lead to a
                                                    baseline is Software engineering tasks
                                                    produce one or more SCIs. After SCIs are
                                                    reviewed and approved, they are placed in a
                                                    <i>project database. </i>When a member of a
                                                    software engineering<i> </i>team wants to
                                                    make a modification to a baseline SCI, it is
                                                    copied from the<i> </i>project database into
                                                    the engineer’s private workspace. However,
                                                    this extracted SCI<i> </i>can be modified
                                                    only if SCM controls are followed.
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>SCM repositories<ul>
                                        <li>Theory<ul>
                                                <li>The SCM repository is the set of mechanisms
                                                    and data structures that allow a software
                                                    team to manage change in an effective
                                                    manner. It provides the obvious functions of
                                                    a modern database management system by
                                                    ensuring data integrity, sharing, and
                                                    integration. In addition, the SCM repository
                                                    provides a hub for the integration of
                                                    software tools, is central to the ﬂ ow of
                                                    the software process, and can enforce
                                                    uniform structure and format for software
                                                    engineering work products. </li>
                                                <li>To achieve these capabilities, the
                                                    repository is deﬁ ned in terms of a
                                                    meta-model. The meta-model determines how
                                                    information is stored in the repository, how
                                                    data can be accessed by tools and viewed by
                                                    software engineers, how well data security
                                                    and integrity can be maintained, and how
                                                    easily the existing model can be extended to
                                                    accommodate new needs.</li>
                                            </ul>
                                        </li>
                                        <li>Functions of SCM repository<ul>
                                                <li>1. Data Integrity :Validates entries,
                                                    ensures consistency, cascades modifications
                                                </li>
                                                <li>2. Information Sharing :Shares information
                                                    among developers and tools, manages and
                                                    controls multi-user access</li>
                                                <li>3. Tool Integration : Establishes a data
                                                    model that can be accessed by many software
                                                    engineering tools, controls access to the
                                                    data </li>
                                                <li>4. Data Integration :Allows various SCM
                                                    tasks to be performed on one or more CSCIs
                                                </li>
                                                <li>5. Methodology Enforcement :Defines an
                                                    entity-relationship model for the repository
                                                    that implies a specific process model for
                                                    software engineering</li>
                                                <li>6. Document Standardization :Defines objects
                                                    in the repository to guarantee a standard
                                                    approach for creation of software
                                                    engineering documents</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>SCM process<ul>
                                        <li>The software conﬁguration management process deﬁnes
                                            a series of tasks that have four primary objectives:
                                            (1) to identify all items that collectively deﬁne
                                            the software conﬁguration, (2) to manage changes to
                                            one or more of these items, (3) to facilitate the
                                            construction of different versions of an
                                            application, and (4) to ensure that software quality
                                            is maintained as the conﬁguration evolves over time.
                                        </li>
                                        <li>A process that achieves these objectives need not be
                                            bureaucratic and ponderous, but it must be
                                            characterized in a manner that enables a software
                                            team to develop answers to a set of complex
                                            questions: <ul>
                                                <li>How does a software team identify the
                                                    discrete elements of a software
                                                    conﬁguration? </li>
                                                <li>How does an organization manage the many
                                                    existing versions of a program (and its
                                                    documentation) in a manner that will enable
                                                    change to be accommodated efﬁciently? </li>
                                                <li>How does an organization control changes
                                                    before and after software is released to a
                                                    customer? </li>
                                                <li>How does an organization assess the impact
                                                    of change and manage the impact effectively?
                                                </li>
                                                <li>Who has responsibility for approving and
                                                    ranking requested changes? </li>
                                                <li>How can we ensure that changes have been
                                                    made properly? </li>
                                                <li>What mechanism is used to apprise others of
                                                    changes that are made? </li>
                                            </ul>
                                        </li>
                                        <li>Change Control<ul>
                                                <li>1. Change control is vital. </li>
                                                <li>2. But the forces that make it necessary
                                                    also make it annoying. </li>
                                                <li>3. We worry about change because a tiny
                                                    perturbation in the code can create a big
                                                    failure in the product. </li>
                                                <li>4. But it can also fix a big failure or
                                                    enable wonderful new capabilities. </li>
                                                <li>5. We worry about change because a single
                                                    rogue developer could sink the project; yet
                                                    brilliant ideas originate in the minds of
                                                    those rogues, and a burdensome change
                                                    control process could effectively discourage
                                                    them from doing creative work.</li>
                                            </ul>
                                        </li>
                                        <li>Version Control<ul>
                                                <li>Version control combines procedures and
                                                    tools to manage different versions of
                                                    configuration objects that are created
                                                    during the software process.</li>
                                                <li>Version control in the context of SCM:
                                                    Configuration management allows a user to
                                                    specify alternative configurations of the
                                                    software system through the selection of
                                                    appropriate versions.</li>
                                                <li>This is supported by associating attributes
                                                    with each software version, and then
                                                    allowing a configuration to be specified
                                                    [and constructed] by describing the set of
                                                    desired attributes.</li>
                                            </ul>
                                        </li>
                                        <li>Configuration Audit<ul>
                                                <li>A software configuration audit complements
                                                    the formal technical review by assessing a
                                                    configuration object for characteristics
                                                    that are generally not considered during
                                                    review. </li>
                                                <li>The audit asks and answers the following
                                                    questions: </li>
                                                <li>1. Has the change specified in the ECO been
                                                    made? Have any additional modifications been
                                                    incorporated? </li>
                                                <li>2. Has a formal technical review been
                                                    conducted to assess technical correctness?
                                                </li>
                                                <li>3. Has the software process been followed
                                                    and have software engineering standards been
                                                    properly applied?</li>
                                                <li>4. Has the change been "highlighted" in the
                                                    SCI? Have the change date and change author
                                                    been specified? Do the attributes of the
                                                    configuration object reflect the change?
                                                </li>
                                                <li>5. Have SCM procedures for noting the
                                                    change, recording it, and reporting it been
                                                    followed? </li>
                                                <li>6. Have all related SCIs been properly
                                                    updated?</li>
                                            </ul>
                                        </li>
                                        <li>Status Reporting<ul>
                                                <li>1. Configuration Status Reporting (sometimes
                                                    called status accounting) is an SCM task
                                                    that answers the following questions:<ul>
                                                        <li>What happened?</li>
                                                        <li>Who did it?</li>
                                                        <li>When did it happen?</li>
                                                        <li>What else will be affected?</li>
                                                    </ul>
                                                </li>
                                                <li>2. The flow of information for configuration
                                                    status reporting (CSR) is illustrated in the
                                                    figure.</li>
                                                <li>3. Each time an SCI is assigned new or
                                                    updated identification, a CSR entry is made.
                                                    Each time a change is approved by the CCA
                                                    (i.e., an ECO is issued), a CSR entry is
                                                    made.</li>
                                                <li>4. Each time a configuration audit is
                                                    conducted, the results are reported as part
                                                    of the CSR task.</li>
                                                <li>5. Output from CSR may be placed in an
                                                    on-line database, so that software
                                                    developers or maintainers can access change
                                                    information by keyword category.</li>
                                                <li>6. In addition, a CSR report is generated on
                                                    a regular basis and is intended to keep
                                                    management and practitioners appraised of
                                                    important changes.</li>
                                                <li>7. Configuration status reporting plays a
                                                    vital role in the success of a large
                                                    software development project.</li>
                                                <li>8. When many people are involved, it is
                                                    likely that "the left hand not knowing what
                                                    the right hand is doing" syndrome will
                                                    occur.</li>
                                                <li>9. Two developers may attempt to modify the
                                                    same SCI with different and conflicting
                                                    intents.</li>
                                                <li>10. A software engineering team may spend
                                                    months of effort building software to an
                                                    obsolete hardware specification.</li>
                                                <li>11. The person who would recognize serious
                                                    side effects for a proposed change is not
                                                    aware that the change is being made.</li>
                                                <li>12. CSR helps to eliminate these problems by
                                                    improving communication among all people
                                                    involved.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Quality Assurance<ul>
                                <li>Software Quality Assurance Task and Plan<ul>
                                        <li>Introduction<ul>
                                                <li>Software requirements are the foundation
                                                    from which quality is measured.</li>
                                                <li>Lack of conformance to requirements is lack
                                                    of quality.</li>
                                                <li>Specified standards define a set of
                                                    development criteria that guide the manner
                                                    in which software is engineered. If the
                                                    criteria are not followed, lack of quality
                                                    will almost surely result.</li>
                                                <li>A set of implicit requirements often goes
                                                    unmentioned (e.g., the desire for ease of
                                                    use and good maintainability).</li>
                                                <li>If software conforms to its explicit
                                                    requirements but fails to meet implicit
                                                    requirements, software quality is suspect.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Quality Assurance<ul>
                                                <li>Quality assurance consists of the auditing
                                                    and reporting functions of management. </li>
                                                <li>The goal of quality assurance is to provide
                                                    management with the data necessary to be
                                                    informed about product quality, thereby
                                                    gaining insight and confidence that product
                                                    quality is meeting its goals. </li>
                                                <li>Of course, if the data provided through
                                                    quality assurance identify problems, it is
                                                    management’s responsibility to address the
                                                    problems and apply the necessary resources
                                                    to resolve quality issues.</li>
                                            </ul>
                                        </li>
                                        <li>SQA Task<ul>
                                                <li>Software quality assurance is composed of a
                                                    variety of tasks associated with two
                                                    different constituencies—the software
                                                    engineers who do technical work and an </li>
                                                <li>SQA group that has responsibility for
                                                    quality assurance planning, oversight,
                                                    record keeping, analysis, and reporting.
                                                </li>
                                                <li>Prepares an SQA plan for a project. The plan
                                                    is developed during project planning and is
                                                    reviewed by all interested parties. Quality
                                                    assurance activities performed by the
                                                    software engineering team and the SQA group
                                                    are governed by the plan. The plan
                                                    identifies <ul>
                                                        <li>Evaluations to be performed </li>
                                                        <li>Audits and reviews to be performed
                                                        </li>
                                                        <li>Standards that is applicable to the
                                                            project </li>
                                                        <li>Procedures for error reporting and
                                                            tracking</li>
                                                        <li>Documents to be produced by the SQA
                                                            group </li>
                                                        <li>Amount of feedback provided to the
                                                            software project team</li>
                                                    </ul>
                                                </li>
                                                <li>Participates in the development of the
                                                    project’s software process description. The
                                                    software team selects a process for the work
                                                    to be performed. The SQA group reviews the
                                                    process description for compliance with
                                                    organizational policy, internal software
                                                    standards, externally imposed standards
                                                    (e.g., ISO-9001), and other parts of the
                                                    software project plan.</li>
                                                <li>Reviews software engineering activities to
                                                    verify compliance with the defined software
                                                    process. The SQA group identifies,
                                                    documents, and tracks deviations from the
                                                    process and verifies that corrections have
                                                    been made. </li>
                                                <li>Audits designated software work products to
                                                    verify compliance with those defined as part
                                                    of the software process. The SQA group
                                                    reviews selected work products; identifies,
                                                    documents, and tracks deviations; verifies
                                                    that corrections have been made; and
                                                    periodically reports the results of its work
                                                    to the project manager.</li>
                                                <li>Ensures that deviations in software work and
                                                    work products are documented and handled
                                                    according to a documented procedure.
                                                    Deviations may be encountered in the project
                                                    plan, process description, applicable
                                                    standards, or technical work products.</li>
                                                <li>Records any noncompliance and reports to
                                                    senior management. Noncompliance items are
                                                    tracked until they are resolved.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Metrics<ul>
                                        <li> The SQA activities described in the preceding
                                            section are performed to achieve a set of pragmatic
                                            goals: </li>
                                        <li>Requirements quality<ul>
                                                <li>The correctness, completeness, and
                                                    consistency of the requirements model will
                                                    have a strong inﬂuence on the quality of all
                                                    work products that follow. SQA must ensure
                                                    that the software team has properly reviewed
                                                    the requirements model to achieve a high
                                                    level of quality. </li>
                                            </ul>
                                        </li>
                                        <li>Design quality<ul>
                                                <li>Every element of the design model should be
                                                    assessed by the software team to ensure that
                                                    it exhibits high quality and that the design
                                                    itself conforms to requirements. SQA looks
                                                    for attributes of the design that are
                                                    indicators of quality. </li>
                                            </ul>
                                        </li>
                                        <li>Code quality<ul>
                                                <li>Source code and related work products (e.g.,
                                                    other descriptive information) must conform
                                                    to local coding standards and exhibit
                                                    characteristics that will facilitate
                                                    maintainability. SQA should isolate those
                                                    attributes that allow a reasonable analysis
                                                    of the quality of code. </li>
                                            </ul>
                                        </li>
                                        <li> Quality control effectiveness<ul>
                                                <li>A software team should apply limited
                                                    resources in a way that has the highest
                                                    likelihood of achieving a high-quality</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Software Reliability<ul>
                                        <li>There is no doubt that the reliability of a computer
                                            program is an important element of its overall
                                            quality. If a program repeatedly and frequently
                                            fails to perform, it matters little whether other
                                            software quality factors are acceptable. </li>
                                        <li>Software reliability, unlike many other quality
                                            factors, can be measured directly and estimated
                                            using historical and developmental data. Software
                                            reliability is deﬁned in statistical terms as “the
                                            probability of failure-free operation of a computer
                                            program in a speciﬁed environment for a speciﬁed
                                            time”</li>
                                        <li>Mean time between failure (MTBF) = MTTF + MTTR </li>
                                        <li>MTTF = mean time to failure </li>
                                        <li>MTTR = mean time to repair </li>
                                        <li>Availability = [MTTF / (MTTF + MTTR)] x 100%</li>
                                        <li>The MTBF reliability measure is equally sensitive to
                                            MTTF and MTTR. The availability measure is somewhat
                                            more sensitive to MTTR, an indirect measure of the
                                            maintainability of software.</li>
                                    </ul>
                                </li>
                                <li>Formal Technical Review (FTR)<ul>
                                        <li>A formal technical review (FTR) is a software
                                            quality control activity performed by software
                                            engineers (and others). </li>
                                        <li>The objectives of an FTR are<ul>
                                                <li>To uncover errors in function, logic, or
                                                    implementation for any representation of the
                                                    software</li>
                                                <li>To verify that the software under review
                                                    meets its requirements</li>
                                                <li>To ensure that the software has been
                                                    represented according to predefined
                                                    standards</li>
                                                <li>To achieve software that is developed in a
                                                    uniform manner</li>
                                                <li>To make projects more manageable. In
                                                    addition, the FTR serves as a training
                                                    ground, enabling junior engineers to observe
                                                    different approaches to software analysis,
                                                    design, and implementation</li>
                                            </ul>
                                        </li>
                                        <li>The FTR also serves to promote backup and continuity
                                            because a number of people become familiar with
                                            parts of the software that they may not have
                                            otherwise seen.<ul>
                                                <li>1. Involves 3 to 5 people (including
                                                    reviewers) </li>
                                                <li>2. Advance preparation (no more than 2 hours
                                                    per person) required </li>
                                                <li>3. Duration of review meeting should be less
                                                    than 2 hours </li>
                                                <li>4. Focus of review is on a discrete work
                                                    product </li>
                                                <li>5. Review leader organizes the review
                                                    meeting at the producer's request </li>
                                                <li>6. Reviewers ask questions that enable the
                                                    producer to discover his or her own error
                                                    (the product is under review not the
                                                    producer) </li>
                                                <li>7. Producer of the work product walks the
                                                    reviewers through the product </li>
                                                <li>8. Recorder writes down any significant
                                                    issues raised during the review </li>
                                                <li>9. Reviewers decide to accept or reject the
                                                    work product and whether to require
                                                    additional reviews of product or not. </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Walkthrough<ul>
                                        <li>Method of conducting informal group/individual
                                            review is called walkthrough, in which a designer or
                                            programmer leads members of the development team and
                                            other interested parties through a software product,
                                            and the participants ask questions and make comments
                                            about possible errors, violation of development
                                            standards, and other problems or may suggest
                                            improvement on the article, walkthrough can be pre
                                            planned or can be conducted at need basis and
                                            generally people working on the work product are
                                            involved in the walkthrough process.</li>
                                        <li>The Purpose of walkthrough is to:<ul>
                                                <li>Find problems</li>
                                                <li>Discuss alternative solutions</li>
                                                <li>Focusing on demonstrating how work product
                                                    meets all requirements.It recommends three
                                                    specialist roles in a walkthrough.</li>
                                                <li><b>Leader</b>: who conducts the walkthrough,
                                                    handles administrative tasks, and ensures
                                                    orderly conduct (and who is often the
                                                    Author)</li>
                                                <li><b>Recorder</b>: who notes all anomalies
                                                    (potential defects), decisions, and action
                                                    items identified during the walkthrough
                                                    meeting, normally generate minutes of
                                                    meeting at the end of walkthrough session.
                                                </li>
                                                <li><b>Author</b>: who presents the software
                                                    product in step-by-step manner at the
                                                    walk-through meeting, and is probably
                                                    responsible for completing most action
                                                    items.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Chapter 6<ul>
                        <li>Strategic Approach to Software Testing<ul>
                                <li>Testing is a set of activities that can be planned in
                                    advance and conducted systematically. For this reason a
                                    template for software testing—a set of steps into which we
                                    can place specific test-case design techniques and testing
                                    methods—should be defined for the software process.</li>
                                <li>A number of software testing strategies have been proposed
                                    in the literature.</li>
                                <li>All provide you with a template for testing and all have the
                                    following generic</li>
                                <li>Characteristics:<ul>
                                        <li>To perform effective testing, you should conduct
                                            effective technical reviews. By doing this, many
                                            errors will be eliminated before testing commences.
                                        </li>
                                        <li>Testing begins at the component level and works
                                            “outward” toward the integration of the entire
                                            computer-based system.</li>
                                        <li>Different testing techniques are appropriate for
                                            different software engineering approaches and at
                                            different points in time.</li>
                                        <li>Testing is conducted by the developer of the
                                            software and (for large projects) an independent
                                            test group.</li>
                                        <li>Testing and debugging are different activities, but
                                            debugging must be accommodated in any testing
                                            strategy.</li>
                                    </ul>
                                </li>
                                <li>A strategy for software testing must accommodate low-level
                                    tests that are</li>
                                <li>necessary to verify that a small source code segment has
                                    been correctly implemented as well as high-level tests that
                                    validate major system functions against customer
                                    requirements. A strategy should provide guidance for the
                                    practitioner and a set of milestones for the manager.
                                    Because the steps of the test strategy occur at a time when
                                    deadline pressure begins to rise, progress must be
                                    measurable and problems should surface as early as possible.
                                </li>
                            </ul>
                        </li>
                        <li>Unit testing<ul>
                                <li>Introduction<ul>
                                        <li>i. <b>Unit Testing </b>is a level of the software
                                            testing process where individual units/components of
                                            a software/system are tested. </li>
                                        <li>ii. The purpose is to validate that each unit of the
                                            software performs as designed. </li>
                                        <li>iii. A unit is the smallest testable part of
                                            software. </li>
                                        <li>iv. It usually has one or a few inputs and usually a
                                            single output. </li>
                                        <li>v. In procedural programming a unit may be an
                                            individual program, function, procedure, etc. </li>
                                        <li>vi. In object-oriented programming, the smallest
                                            unit is a method, which may belong to a base/super
                                            class, abstract class or derived/child class. </li>
                                    </ul>
                                </li>
                                <li>Advantages<ul>
                                        <li>i. Unit testing increases confidence in
                                            changing/maintaining code. </li>
                                        <li>ii. If good unit tests are written and if they are
                                            run every time any code is changed, the likelihood
                                            of any defects due to the change being promptly
                                            caught is very high. </li>
                                        <li>iii. If unit testing is not in place, the most one
                                            can do is hope for the best and wait till the test
                                            results at higher levels of testing are out. </li>
                                        <li>iv. If codes are already made less interdependent to
                                            make unit testing possible, the unintended impact of
                                            changes to any code is less. </li>
                                        <li>v. Codes are more reusable. In order to make unit
                                            testing possible, codes need to be modular. This
                                            means that codes are easier to reuse. </li>
                                        <li>vi. The cost of fixing a defect detected during unit
                                            testing is lesser in comparison to that of defects
                                            detected at higher levels. </li>
                                        <li>vii. Compare the cost (time, effort, destruction,
                                            humiliation) of a defect detected during acceptance
                                            testing or say when the software is live. </li>
                                        <li>viii. Debugging is easy. When a test fails, only the
                                            latest changes need to be debugged. With testing at
                                            higher levels, changes made over the span of several
                                            days/weeks/months need to be debugged. </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Integration testing<ul>
                                <li>i. <b>Integration Testing </b>is a level of the software
                                    testing process where individual units are combined and
                                    tested as a group. </li>
                                <li>ii. The purpose of this level of testing is to expose faults
                                    in the interaction between integrated units. </li>
                                <li>iii. Test drivers and test stubs are used to assist in
                                    Integration Testing. </li>
                            </ul>
                        </li>
                        <li>Verification<ul>
                                <li>i. It makes sure that the product is designed to deliver all
                                    functionality to the customer. </li>
                                <li>ii. Verification is done at the starting of the development
                                    process. It includes reviews and meetings, walkthroughs,
                                    inspection, etc. to evaluate documents, plans, code,
                                    requirements and specifications. </li>
                                <li>iii. It answers the questions like: Am I building the
                                    product right? </li>
                                <li>iv. Am I accessing the data right (in the right place; in
                                    the right way). </li>
                                <li>v. It is a Low level activity </li>
                                <li>vi. Performed during development on key art facts, like
                                    walkthroughs, reviews and inspections, mentor feedback,
                                    training, checklists and standards. </li>
                                <li>vii. Demonstration of consistency, completeness, and
                                    correctness of the software at each stage and between each
                                    stage of the development life cycle. </li>
                            </ul>
                        </li>
                        <li>Validation Testing<ul>
                                <li>i. Determining if the system complies with the requirements
                                    and performs functions for which it is intended and meets
                                    the organization’s goals and user needs. </li>
                                <li>ii. Validation is done at the end of the development process
                                    and takes place after verifications are completed. </li>
                                <li>iii. It answers the question like: Am I building the right
                                    product? </li>
                                <li>iv. Am I accessing the right data (in terms of the data
                                    required to satisfy the requirement). </li>
                                <li>v. It is a High level activity. </li>
                                <li>vi. Performed after a work product is produced against
                                    established criteria ensuring that the product integrates
                                    correctly into the environment. </li>
                                <li>vii. Determination of correctness of the final software
                                    product by a development project with respect to the user
                                    needs and requirements. </li>
                            </ul>
                        </li>
                        <li>System Testing<ul>
                                <li>i. In system testing the behavior of whole system/product is
                                    tested as defined by the scope of the development project or
                                    product. </li>
                                <li>ii. It may include tests based on risks and/or requirement
                                    specifications, business process, use cases, or other high
                                    level descriptions of system behavior, interactions with the
                                    operating systems, and system resources. </li>
                                <li>iii. System testing is most often the final test to verify
                                    that the system to be delivered meets the specification and
                                    its purpose. </li>
                                <li>iv. System testing is carried out by specialist’s testers or
                                    independent testers. </li>
                                <li>v. System testing should investigate both functional and
                                    non-functional requirements of the testing. </li>
                            </ul>
                        </li>
                        <li>Software Testing Fundamentals<ul>
                                <li>Introduction<ul>
                                        <li>The goal of testing is to find errors, and a good
                                            test is one that has a high probability of finding
                                            an error. Therefore, you should design and implement
                                            a computer-based system or a product with
                                            “testability” in mind. At the same time, the tests
                                            themselves must exhibit a set of characteristics
                                            that achieve the goal of finding the most errors
                                            with a minimum of effort</li>
                                    </ul>
                                </li>
                                <li><b>Testability</b> The following characteristics lead to
                                    testable software.<ul>
                                        <li>Operability<ul>
                                                <li>The better it works, the more efficiently it
                                                    can be tested.” If a system is designed and
                                                    implemented with quality in mind, relatively
                                                    few bugs will block the execution of tests,
                                                    allowing testing to progress without fits
                                                    and starts.</li>
                                            </ul>
                                        </li>
                                        <li>Observability<ul>
                                                <li>What you see is what you test. Inputs
                                                    provided as part of testing produce distinct
                                                    outputs. System states and variables are
                                                    visible or queriable during execution.
                                                    Incorrect output is easily identified.
                                                    Internal errors are automatically detected
                                                    and reported. Source code is accessible.
                                                </li>
                                            </ul>
                                        </li>
                                        <li>Controllability<ul>
                                                <li>The better we can control the software, the
                                                    more the testing can be automated and
                                                    optimized. All possible outputs can be
                                                    generated through some combination of input,
                                                    and I/O formats are consistent and
                                                    structured. All code is executable through
                                                    some combination of input. Software and
                                                    hardware states and variables can be
                                                    controlled directly by the test engineer.
                                                    Tests can be conveniently specified,
                                                    automated, and reproduced.</li>
                                            </ul>
                                        </li>
                                        <li>Decomposability<ul>
                                                <li>By controlling the scope of testing, we can
                                                    more quickly isolate problems and perform
                                                    smarter retesting. The software system is
                                                    built from independent modules that can be
                                                    tested independently.</li>
                                            </ul>
                                        </li>
                                        <li>Simplicity<ul>
                                                <li>The less there is to test, the more quickly
                                                    we can test it. The program should exhibit
                                                    functional simplicity (e.g., the feature set
                                                    is the minimum necessary to meet
                                                    requirements); structural simplicity (e.g.,
                                                    architecture is modularized to limit the
                                                    propagation of faults), and code simplicity
                                                    (e.g., a coding standard is adopted for ease
                                                    of inspection and maintenance).</li>
                                            </ul>
                                        </li>
                                        <li>Stability<ul>
                                                <li>The fewer the changes, the fewer the
                                                    disruptions to testing. Changes to the
                                                    software are infrequent, controlled when
                                                    they do occur, and do not invalidate
                                                    existing tests. The software recovers well
                                                    from failures.</li>
                                            </ul>
                                        </li>
                                        <li>Understandability<ul>
                                                <li>The more information we have, the smarter we
                                                    will test. The architectural design and the
                                                    dependencies between internal, external, and
                                                    shared components are well understood.
                                                    Technical documentation is instantly
                                                    accessible, well organized, specific and
                                                    detailed, and accurate. Changes to the
                                                    design are communicated to testers.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>White-Box Testing<ul>
                                <li><i>White-box testing, </i>sometimes called <i>glass-box
                                        testing </i>or <i>structural testing, </i>is a test-case
                                    design philosophy that uses the control structure described
                                    as part of component-level design to derive test cases.
                                </li>
                                <li>Using white-box testing methods, you can derive test cases
                                    that <ul>
                                        <li>(1) guarantee that all independent paths within a
                                            module have been exercised at least once</li>
                                        <li>(2) exercise all logical decisions on their true and
                                            false sides</li>
                                        <li>(3) execute all loops at their boundaries and within
                                            their operational bounds</li>
                                        <li>(4) exercise internal data structures to ensure
                                            their validity.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Basis Path Testing<ul>
                                <li>Introduction<ul>
                                        <li>The basis path method enables the test-case designer
                                            to derive a logical complexity measure of a
                                            procedural design and use this measure as a guide
                                            for defining a basis set of execution paths. Test
                                            cases derived to exercise the basis set are
                                            guaranteed to execute every statement in the program
                                            at least one time during testing.</li>
                                    </ul>
                                </li>
                                <li>Cyclomatic Complexity<ul>
                                        <li>i. Cyclomatic complexity is software metric that
                                            provides a quantitative measure of the logical
                                            complexity of a program. </li>
                                        <li>ii. When used in the context of the basis path
                                            testing method, the value computed for Cyclomatic
                                            complexity defines the number of independent paths
                                            in the basis set of a program and provides us with
                                            an upper bound for the number of tests that must be
                                            conducted to ensure that all statements have been
                                            executed at least once. </li>
                                        <li>iii. An independent path is any path through the
                                            program that introduces at least one new set of
                                            processing statements or a new condition. </li>
                                        <li>iv. When stated in terms of a flow graph, an
                                            independent path must move along at least one edge
                                            that has not been traversed before the path is
                                            defined. </li>
                                        <li>Calculations<ul>
                                                <li>1. The number of regions of the flow graph
                                                    correspond to the Cyclomatic complexity.
                                                </li>
                                                <li>4</li>
                                                <li>2.Cyclomatic complexity, V(G), for a flow
                                                    graph, G, is defined as </li>
                                                <li>V (G) = (E –N) + 2 <ul>
                                                        <li>=(11-9)+2</li>
                                                        <li>=2+2</li>
                                                        <li>=4</li>
                                                    </ul>
                                                </li>
                                                <li>where E is the number of flow graph edges, N
                                                    is the number of flow graph nodes. </li>
                                                <li>3.Cyclomatic complexity, V(G), for a flow
                                                    graph, G, is also defined as </li>
                                                <li>V (G) = P + 1<ul>
                                                        <li>=3+1</li>
                                                        <li>=4 </li>
                                                    </ul>
                                                </li>
                                                <li>where P is the number of predicate nodes
                                                    contained in the flow graph G. </li>
                                                <li>1. The flow graph has four regions. </li>
                                                <li>2. V (G) = 11 edges 9 nodes + 2 = 4. </li>
                                                <li>3. V (G) = 3 predicate nodes + 1 = 4. </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Graph Matrices<ul>
                                        <li>The procedure for deriving the flow graph and even
                                            determining a set of basis paths is amenable to
                                            mechanization. A data structure, called a <i>graph
                                                matrix, </i>can be quite useful for developing a
                                            software tool that assists in basis path testing. A
                                            graph matrix is a square matrix whose size (i.e.,
                                            number of rows and columns) is equal to the number
                                            of nodes on the flow graph. Each row and column
                                            corresponds to an identified node, and matrix
                                            entries correspond to connections (an edge) between
                                            nodes.</li>
                                        <li>The graph matrix can become a powerful tool for
                                            evaluating program control structure during testing.
                                            The link weight provides additional information
                                            about control flow. In its simplest form, the link
                                            weight is 1 (a connection exists) or 0 (a connection
                                            does not exist).</li>
                                    </ul>
                                </li>
                                <li>Deriving Test Cases<ul>
                                        <li>The following steps can be applied to derive the
                                            basis set:</li>
                                        <li>1. Using the design or code as a foundation, draw a
                                            corresponding flow</li>
                                        <li>graph.</li>
                                        <li>2. Determine the cyclomatic complexity of the
                                            resultant flow graph.</li>
                                        <li>3. Determine a basis set of linearly independent
                                            paths.</li>
                                        <li>4. Prepare test cases that will force execution of
                                            each path in the basis set.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Control Structure Testing<ul>
                                <li>Basic testing is done to check the flow graph of any
                                    implementation. Control structure testing checks the various
                                    aspects like condition testing, data flow testing and loop
                                    testing. </li>
                                <li>Condition Testing<ul>
                                        <li>i. Condition testing is a test case design method
                                            that exercises the logical conditions contained in a
                                            program module. </li>
                                        <li>ii. A simple condition is a Boolean variable or a
                                            relational expression, possibly preceded with one
                                            NOT (¬) operator. </li>
                                        <li>iii. A relational expression takes the form </li>
                                        <li>E1 &lt;relational-operator&gt; E2 </li>
                                        <li>where E1 and E2 are arithmetic expressions and
                                            &lt;relational-operator&gt; is one of the following:
                                            &lt;, ≤, =, ≠ (none quality), &gt;, or ≥.</li>
                                        <li>iv. If a condition is incorrect, then at least one
                                            component of the condition is incorrect. Therefore,
                                            types of errors in a condition include the
                                            following: <ul>
                                                <li>1. Boolean operator error
                                                    (incorrect/missing/extra Boolean operators).
                                                </li>
                                                <li>2. Boolean variable error. </li>
                                                <li>3. Boolean parenthesis error. </li>
                                                <li>4. Relational operator error. </li>
                                                <li>5. Arithmetic expression error. </li>
                                            </ul>
                                        </li>
                                        <li>v. The various types of conditional testing that can
                                            be performed are branch testing and domain testing.
                                        </li>
                                    </ul>
                                </li>
                                <li>Flow Graph Notation<ul>
                                        <li>i. A simple notation to represent data in control
                                            flow graph is known as flow graph. </li>
                                        <li>ii. The flow graph depicts logical control flow
                                            using the notation. </li>
                                        <li>iii. Each structured construct has a corresponding
                                            flow graph symbol. </li>
                                        <li>iv. The procedural design is shown in Fig 2 below
                                        </li>
                                        <li>v. Fig 3 maps the flowchart into a corresponding
                                            flow graph (assuming that no compound conditions are
                                            contained in the decision diamonds of the
                                            flowchart). </li>
                                        <li>vi. Referring to Fig 3, each circle, called a flow
                                            graph node, represents one or more procedural
                                            statements. </li>
                                        <li>vii. A sequence of process boxes and a decision
                                            diamond can map into a single node. </li>
                                        <li>viii. The arrows on the flow graph, called edges or
                                            links, represent flow of control and are analogous
                                            to flowchart arrows. </li>
                                        <li>ix. An edge must terminate at a node, even if the
                                            node does not represent any procedural statements
                                            (e.g., see the symbol for the if-then-else
                                            construct). </li>
                                        <li>x. Areas bounded by edges and nodes are called
                                            regions. </li>
                                        <li>xi. When counting regions, we include the area
                                            outside the graph as a region.4. </li>
                                    </ul>
                                </li>
                                <li>Loop Testing<ul>
                                        <li>Introduction<ul>
                                                <li>i. Loop testing is a white-box testing
                                                    technique that focuses exclusively on the
                                                    validity of loop constructs. </li>
                                                <li>ii. Four different classes of loops can be
                                                    defined: simple loops, concatenated loops,
                                                    nested loops, and unstructured loops </li>
                                            </ul>
                                        </li>
                                        <li>1.<b><i> Simple Loops</i></b>. The following set of
                                            tests can be applied to simple loops, where n is the
                                            maximum number of allowable passes through the loop.
                                        </li>
                                        <li>2.<b><i> Nested Loops</i></b>. If we were to extend
                                            the test approach for simple loops to nested loops,
                                            the number of possible tests would grow
                                            geometrically as the level of nesting increases.
                                            This would result in an impractical number of tests.
                                            An approach that will help to reduce the number of
                                            tests: <ul>
                                                <li>a. Start at the innermost loop. Set all
                                                    other loops to minimum values. </li>
                                                <li>b. Conduct simple loop tests for the
                                                    innermost loop while holding the outer loops
                                                    at their minimum iteration parameter (e.g.,
                                                    loop counter) values. Add other tests for
                                                    out-of-range or excluded values. </li>
                                                <li>c. Work outward, conducting tests for the
                                                    next loop, but keeping all other outer loops
                                                    at minimum values and other nested loops to
                                                    "typical" values. </li>
                                                <li>d. Continue until all loops have been
                                                    tested. </li>
                                            </ul>
                                        </li>
                                        <li>3. <b><i>Concatenated Loops</i></b>. Concatenated
                                            loops can be tested using the approach defined for
                                            simple loops, if each of the loops is independent of
                                            the other. However, if two loops are concatenated
                                            and the loop counter for loop 1 is used as the
                                            initial value for loop 2, then the loops are not
                                            independent. When the loops are not independent, the
                                            approach applied to nested loops is recommended.
                                        </li>
                                        <li>4. <b><i>Unstructured Loops</i></b>. Whenever
                                            possible, this class of loops should be redesigned
                                            to reflect the use of the structured programming
                                            constructs. </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Black-Box Testing<ul>
                                <li>Introduction<ul>
                                        <li>i. Black-box testing, also called behavioral
                                            testing, focuses on the functional requirements of
                                            the software. </li>
                                        <li>ii. That is, black-box testing enables the software
                                            engineer to derive sets of input conditions that
                                            will fully exercise all functional requirements for
                                            a program. </li>
                                        <li>iii. Black-box testing is not an alternative to
                                            white-box techniques. Rather, it is a complementary
                                            approach that is likely to uncover a different class
                                            of errors than white-box methods. </li>
                                    </ul>
                                </li>
                                <li>Graph-Based Testing Methods<ul>
                                        <li>i. The first step in black-box testing is to
                                            understand the objects that are modeled in software
                                            and the relationships that connect these objects.
                                        </li>
                                        <li>ii. Once this has been accomplished, the next step
                                            is to define a series of tests that verify “all
                                            objects have the expected relationship to one
                                            another.” </li>
                                        <li>iii. Stated in another way, software testing begins
                                            by creating a graph of important objects and their
                                            relationships and then devising a series of tests
                                            that will cover the graph so that each object and
                                            relationship is exercised and errors are uncovered.
                                        </li>
                                    </ul>
                                </li>
                                <li>Equivalence Partitioning<ul>
                                        <li><i>Equivalence partitioning </i>is a black-box
                                            testing method that divides the input domain of a
                                            program into classes of data from which test cases
                                            can be derived. An ideal test case single-handedly
                                            uncovers a class of errors (e.g., incorrect
                                            processing of all character data) that might
                                            otherwise require many test cases to be executed
                                            before the general error is observed.</li>
                                        <li>Test-case design for equivalence partitioning is
                                            based on an evaluation of <i>equivalence classes
                                            </i>for an input condition. Using concepts
                                            introduced in the preceding section, if a set of
                                            objects can be linked by relationships that are
                                            symmetric, transitive, and reflexive, an equivalence
                                            class is present. An equivalence class represents a
                                            set of valid or invalid states for input conditions.
                                        </li>
                                        <li>Typically, an input condition is either a specific
                                            numeric value, a range of values, a set of related
                                            values, or a Boolean condition. Equivalence classes
                                            may be defined according to the following
                                            guidelines:<ul>
                                                <li>1. If an input condition specifies a range,
                                                    one valid and two invalid equivalence
                                                    classes are defined.<ul>
                                                        <li>Range 21 to 25</li>
                                                        <li>21-25 valid class</li>
                                                        <li>&lt;21 invalid class</li>
                                                        <li>&gt;25 invalid class</li>
                                                    </ul>
                                                </li>
                                                <li><b>2. </b>If an input condition requires a
                                                    specific value, one valid and two invalid
                                                    equivalence classes are defined.<ul>
                                                        <li>Value 25</li>
                                                        <li>25 valid class</li>
                                                        <li>&lt;25 invalid </li>
                                                        <li>&gt;25 invalid</li>
                                                    </ul>
                                                </li>
                                                <li><b>3. </b>If an input condition specifies a
                                                    member of a set, one valid and one invalid
                                                    equivalence class are defined.<ul>
                                                        <li>Value 4 set {1,2,3,4,5}</li>
                                                        <li>4 valid class</li>
                                                        <li>6 invlid </li>
                                                    </ul>
                                                </li>
                                                <li><b>4. </b>If an input condition is Boolean,
                                                    one valid and one invalid class are defined.
                                                    <ul>
                                                        <li>True </li>
                                                        <li>false</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>By applying the guidelines for the derivation of
                                            equivalence classes, test cases for each input
                                            domain data item can be developed and executed. Test
                                            cases are selected so that the largest number of
                                            attributes of an equivalence class are exercised at
                                            once.</li>
                                    </ul>
                                </li>
                                <li>Boundary Value Analysis<ul>
                                        <li>A greater number of errors occurs at the boundaries
                                            of the input domain rather than in the “center.” It
                                            is for this reason that boundary value analysis
                                            (BVA) has been developed as a testing technique.
                                        </li>
                                        <li>Boundary value analysis leads to a selection of test
                                            cases that exercise bounding values. Boundary value
                                            analysis is a test-case design technique that
                                            complements equivalence partitioning. Rather than
                                            selecting any element of an equivalence class, BVA
                                            leads to the selection of test cases at the “edges”
                                            of the class. Rather than focusing solely on input
                                            conditions, BVA derives test cases from the output
                                            domain.</li>
                                        <li>Guidelines for BVA are similar in many respects to
                                            those provided for equivalence partitioning:<ul>
                                                <li>1. If an input condition specifies a range
                                                    bounded by values a and b, test cases should
                                                    be designed with values a and b and just
                                                    above and just below a and b.<ul>
                                                        <li>1-100</li>
                                                        <li>0-100</li>
                                                        <li>1-101</li>
                                                        <li>0-101</li>
                                                    </ul>
                                                </li>
                                                <li>2. If an input condition specifies a number
                                                    of values, test cases should be developed
                                                    that exercise the minimum and maximum
                                                    numbers. Values just above and below minimum
                                                    and maximum are also tested.<ul>
                                                        <li>{20, 18, 21, 24}</li>
                                                        <li>Min-18</li>
                                                        <li>Max-24</li>
                                                    </ul>
                                                </li>
                                                <li>3. Apply guidelines 1 and 2 to output
                                                    conditions. For example, assume that a
                                                    temperature versus pressure table is
                                                    required as output from an engineering
                                                    analysis program. Test cases should be
                                                    designed to create an output report that
                                                    produces the maximum (and minimum) allowable
                                                    number of table entries.</li>
                                                <li>4. If internal program data structures have
                                                    prescribed boundaries (e.g., a table has a
                                                    defined limit of 100 entries), be certain to
                                                    design a test case to exercise the data
                                                    structure at its boundary.</li>
                                            </ul>
                                        </li>
                                        <li>Most software engineers intuitively perform BVA to
                                            some degree. By applying these guidelines, boundary
                                            testing will be more complete, thereby having a
                                            higher likelihood for error detection.</li>
                                    </ul>
                                </li>
                                <li>Orthogonal Array Testing<ul>
                                        <li>Introduction<ul>
                                                <li>Orthogonal Array Testing (OAT)&nbsp;is
                                                    software testing technique that uses
                                                    orthogonal arrays to create test cases. It
                                                    is statistical testing approach especially
                                                    useful when system to be tested has huge
                                                    data inputs. Orthogonal array testing helps
                                                    to maximize test coverage by pairing and
                                                    combining the inputs and testing the system
                                                    with comparatively less number of test cases
                                                    for time saving.</li>
                                                <li>For example, when a train ticket has to be
                                                    verified, factors such as - the number of
                                                    passengers, ticket number, seat numbers, and
                                                    train numbers have to be tested. One by one
                                                    testing of each factor/input is burdensome.
                                                    It is more efficient when the QA engineer
                                                    combines more inputs together and does
                                                    testing. In such cases, we can use the
                                                    Orthogonal Array testing method.</li>
                                                <li>This type of pairing or combining of inputs
                                                    and testing the system to save time is
                                                    called pairwise testing. OATS technique is
                                                    used for pairwise testing.</li>
                                            </ul>
                                        </li>
                                        <li>Why OAT (Orthogonal Array Testing)?<ul>
                                                <li>In the present scenario, delivering a
                                                    quality software product to the customer has
                                                    become challenging due to the complexity of
                                                    the code.</li>
                                                <li>In the conventional method, test suites
                                                    include test cases that have been derived
                                                    from all combination of input values and
                                                    pre-conditions. As a result, n number of
                                                    test cases has to be covered.</li>
                                                <li>But in a real scenario, the testers won't
                                                    have the leisure to execute all the test
                                                    cases to uncover the defects as there are
                                                    other processes such as documentation,
                                                    suggestions, and feedback from the customer
                                                    that has to be taken into account while in
                                                    the testing phase.</li>
                                                <li>Hence, the test managers wanted to optimize
                                                    the number and quality of the test cases to
                                                    ensure maximum&nbsp;Test coverage&nbsp;with
                                                    minimum effort. This effort is
                                                    called&nbsp;Test Case&nbsp;Optimization.<ul>
                                                        <li>Systematic and Statistical way to
                                                            test pairwise interactions </li>
                                                        <li>Interactions and Integration points
                                                            are a major source of defects. </li>
                                                        <li>Execute a well-defined, concise of
                                                            test cases that are likely to
                                                            uncover most (not all) bugs. </li>
                                                        <li>Orthogonal approach guarantees the
                                                            pairwise coverage of all variables.
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>How OAT's is represented<ul>
                                                <li>The formula to calculate OAT<ul>
                                                        <li>L runs (Levels^Factors)</li>
                                                        <li>Runs (N) – Number of rows in the
                                                            array, which translates into a
                                                            number of test cases that will be
                                                            generated. </li>
                                                        <li>Factors (K) – Number of columns in
                                                            the array, which translates into a
                                                            maximum number of variables that can
                                                            be handled. </li>
                                                        <li>Levels (V) – Maximum number of
                                                            values that can be taken on any
                                                            single factor.</li>
                                                    </ul>
                                                </li>
                                                <li>A single factor has 2 to 3 inputs to be
                                                    tested. That maximum number of inputs
                                                    decides the Levels.</li>
                                            </ul>
                                        </li>
                                        <li>How to do Orthogonal Array Testing: Examples<ul>
                                                <li>Identify the independent variable for the
                                                    scenario. </li>
                                                <li>Find the smallest array with the number of
                                                    runs. </li>
                                                <li>Map the factors to the array. </li>
                                                <li>Choose the values for any "leftover" levels.
                                                </li>
                                                <li>Transcribe the Runs into test cases, adding
                                                    any particularly suspicious combinations
                                                    that aren't generated.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Software maintenance and its types<ul>
                                <li>Introduction<ul>
                                        <li>Software Maintenance is the process of modifying a
                                            software product after it has been delivered to the
                                            customer. The main purpose of software maintenance
                                            is to modify and update software application after
                                            delivery to correct faults and to improve
                                            performance.</li>
                                    </ul>
                                </li>
                                <li>Need for Maintenance – Software Maintenance must be
                                    performed in order to:<ul>
                                        <li>Correct faults.</li>
                                        <li>Improve the design.</li>
                                        <li>Implement enhancements.</li>
                                        <li>Interface with other systems.</li>
                                        <li>Accommodate programs so that different hardware,
                                            software, system features, and telecommunications
                                            facilities can be used.</li>
                                        <li>Migrate legacy software.</li>
                                        <li>Retire software.</li>
                                    </ul>
                                </li>
                                <li>Categories of Software Maintenance – Maintenance can be
                                    divided into the following:<ul>
                                        <li>Corrective maintenance<ul>
                                                <li>Corrective maintenance of a software product
                                                    may be essential either to rectify some bugs
                                                    observed while the system is in use, or to
                                                    enhance the performance of the system.</li>
                                            </ul>
                                        </li>
                                        <li>Adaptive maintenance<ul>
                                                <li>This includes modifications and updation
                                                    when the customers need the product to run
                                                    on new platforms, on new operating systems,
                                                    or when they need the product to interface
                                                    with new hardware and software.</li>
                                            </ul>
                                        </li>
                                        <li>Perfective maintenance<ul>
                                                <li>A software product needs maintenance to
                                                    support the new features that the users want
                                                    or to change different types of
                                                    functionalities of the system according to
                                                    the customer demands.</li>
                                            </ul>
                                        </li>
                                        <li>Preventive maintenance<ul>
                                                <li>This type of maintenance includes
                                                    modifications and updation to prevent future
                                                    problems of the software. It goals to attend
                                                    problems, which are not significant at this
                                                    moment but may cause serious issues in
                                                    future.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Software Re-engineering<ul>
                                <li>Introduction<ul>
                                        <li>Software Re-Engineering&nbsp;is the examination and
                                            alteration of a system to reconstitute it in a new
                                            form. The principles of Re-Engineering when applied
                                            to the software development process are called
                                            software re-engineering. It affects positively at
                                            software cost, quality, service to the customer and
                                            speed of delivery. In Software Re-engineering, we
                                            are improving the software to make it more efficient
                                            and effective.</li>
                                        <li>The need of software Re-engineering:&nbsp;Software
                                            re-engineering is an economical process for software
                                            development and quality enhancement of the product.
                                            This process enables us to identify the useless
                                            consumption of deployed resources and the
                                            constraints that are restricting the development
                                            process so that the development process could be
                                            made easier and cost-effective (time, financial,
                                            direct advantage, optimize the code, indirect
                                            benefits, etc.) and maintainable. </li>
                                    </ul>
                                </li>
                                <li>The software reengineering is necessary for having-<ul>
                                        <li>a)&nbsp;Boost up productivity:&nbsp;Software
                                            reengineering increase productivity by optimizing
                                            the code and database so that processing gets
                                            faster.</li>
                                        <li>b)&nbsp;Processes in continuity:&nbsp;The
                                            functionality of older software product can be still
                                            used while the testing or development of software.
                                        </li>
                                        <li>c)&nbsp;Improvement opportunity:&nbsp;Meanwhile the
                                            process of software reengineering, not only software
                                            qualities, features and functionality but also your
                                            skills are refined, new ideas hit in your mind. This
                                            makes the developers mind accustomed to capturing
                                            new opportunities so that more and more new features
                                            can be developed.</li>
                                        <li>d)&nbsp;Reduction in risks:&nbsp;Instead of
                                            developing the software product from scratch or from
                                            the beginning stage here developers develop the
                                            product from its existing stage to enhance some
                                            specific features that are brought in concern by
                                            stakeholders or its users. Such kind of practice
                                            reduces the chances of fault fallibility.</li>
                                        <li>e)&nbsp;Saves time:&nbsp;As we stated above here
                                            that the product is developed from the existing
                                            stage rather than the beginning stage so the time
                                            consumes in software engineering is lesser.</li>
                                        <li>f)&nbsp;Optimization:&nbsp;This process refines the
                                            system features, functionalities and reduces the
                                            complexity of the product by consistent optimization
                                            as maximum as possible.</li>
                                    </ul>
                                </li>
                                <li>Re-Engineering cost factors:<ul>
                                        <li>The quality of the software to be re-engineered.
                                        </li>
                                        <li>The tool support availability for engineering.</li>
                                        <li>The extent of the data conversion which is required.
                                        </li>
                                        <li>The availability of expert staff for Re-engineering.
                                        </li>
                                    </ul>
                                </li>
                                <li>Software Re-Engineering Activities:<ul>
                                        <li>1. Inventory Analysis:&nbsp; <ul>
                                                <li>Every software organization should have an
                                                    inventory of all the applications.</li>
                                                <li>Inventory can be nothing more than a
                                                    spreadsheet model containing information
                                                    that provides a detailed description of
                                                    every active application.</li>
                                                <li>By sorting this information according to
                                                    business criticality, longevity, current
                                                    maintainability and other local important
                                                    criteria, candidates for re-engineering
                                                    appear.</li>
                                                <li>The resource can then be allocated to a
                                                    candidate application for re-engineering
                                                    work.</li>
                                            </ul>
                                        </li>
                                        <li>2. Document reconstructing:&nbsp; <ul>
                                                <li>Documentation of a system either explains
                                                    how it operates or how to use it.</li>
                                                <li>Documentation must be updated.</li>
                                                <li>It may not be necessary to fully document an
                                                    application.</li>
                                                <li>The system is business-critical and must be
                                                    fully re-documented.</li>
                                            </ul>
                                        </li>
                                        <li>3. Reverse Engineering:&nbsp; <ul>
                                                <li>Reverse engineering is a process of design
                                                    recovery. Reverse engineering tools extract
                                                    data, architectural and procedural design
                                                    information from an existing program.</li>
                                            </ul>
                                        </li>
                                        <li>4. Code Reconstructing:<ul>
                                                <li>To accomplish code reconstructing, the
                                                    source code is analysed using a
                                                    reconstructing tool. Violations of
                                                    structured programming construct are noted
                                                    and code is then reconstructed.</li>
                                                <li>The resultant restructured code is reviewed
                                                    and tested to ensure that no anomalies have
                                                    been introduced.</li>
                                            </ul>
                                        </li>
                                        <li>5. Data Restructuring:<ul>
                                                <li>Data restructuring begins with a reverse
                                                    engineering activity.</li>
                                                <li>Current data architecture is dissected, and
                                                    the necessary data models are defined.</li>
                                                <li>Data objects and attributes are identified,
                                                    and existing data structure is reviewed for
                                                    quality.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Reverse Engineering<ul>
                                <li>i. Reverse engineering can extract design information from
                                    source code, but the abstraction level, the completeness of
                                    the documentation, the degree to which tools and a human
                                    analyst work together, and the directionality of the process
                                    are highly variable. </li>
                                <li>ii. The Abstraction level of a reverse engineering process
                                    and the tools used to affect it refers to the sophistication
                                    of the design information that can be extracted from source
                                    code. Ideally, the abstraction level should be as high as
                                    possible. </li>
                                <li>iii. The Completeness of a reverse engineering process
                                    refers to the level of detail that is provided at an
                                    abstraction level. In most cases, the completeness decreases
                                    as the abstraction level increases. </li>
                                <li>iv. Interactivity refers to the degree to which the human is
                                    "integrated" with automated tools to create an effective
                                    reverse engineering process. In most cases, as the
                                    abstraction level increases, interactivity must increase or
                                    completeness will suffer. </li>
                                <li>v. If the directionality of the reverse engineering process
                                    is one way, all information extracted from the source code
                                    is provided to the software engineer who can then use it
                                    during any maintenance activity. </li>
                                <li>vi. The core of reverse engineering is an activity called
                                    extract abstractions. The engineer must evaluate the old
                                    program and from the (often undocumented) source code,
                                    extract a meaningful </li>
                                <li>Specification of the processing that is performed, the user
                                    interface that is applied, and the program data structures
                                    or database that is used. </li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>

    <footer>
        <div style="text-align-last: center;">
            <p> © 2021 Vinay Panchal All Rights Reserved.</p>
            <p><a href="http://www.vinaypanchal.com/">vinaypanchal.com</a></p>
        </div>
    </footer>
</body>
<script type="text/javascript" src="CollapsibleLists.src.js"></script>


</html>